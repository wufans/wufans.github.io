<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fan Wu&#39;s Blog</title>
  
  <subtitle>Nothing is impossible!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yoursite.com/"/>
  <updated>2019-04-07T10:23:56.418Z</updated>
  <id>https://yoursite.com/</id>
  
  <author>
    <name>Fan Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java并发(3)-线程安全</title>
    <link href="https://yoursite.com/2019/04/05/Java%E5%B9%B6%E5%8F%91(3)-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <id>https://yoursite.com/2019/04/05/Java并发(3)-线程安全/</id>
    <published>2019-04-05T15:20:20.000Z</published>
    <updated>2019-04-07T10:23:56.418Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551345094255&amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;imgtype=0&amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png" alt="此处输入图片的描述"><br><code>volatile</code>, <code>synchronized</code>, <code>Lock</code>? 详解Java的线程安全与锁！<br><a id="more"></a></p><h2 id="一、内存模型"><a href="#一、内存模型" class="headerlink" title="一、内存模型"></a>一、内存模型</h2><h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a><strong>高速缓存</strong></h3><p>因为CPU执行速度和内存数据读写速度差距很大，因此CPU往往包含<code>高速缓存</code>结构。<br><img src="https://s2.ax1x.com/2019/04/07/AhAl28.jpg" alt="此处输入图片的描述"><br>当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</p><h3 id="缓存不一致问题"><a href="#缓存不一致问题" class="headerlink" title="缓存不一致问题"></a><strong>缓存不一致问题</strong></h3><p>执行下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = i + <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><p>当线程执行这个语句时，会先从主存当中读取i的值<code>i = 0</code>，然后复制一份到<code>高速缓存</code>当中，然后CPU执行指令对<code>i</code>进行加1操作，然后将数据写入高速缓存，最后将高速缓存中<code>i</code>最新的值刷新到<code>主存</code>当中。</p><p>可能存在情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后<code>线程1</code>进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后<code>线程2</code>把i的值写入内存。</p><p>也就是说，如果一个变量在多个CPU中都存在缓存（多线程情况），那么就可能存在<strong>缓存不一致</strong>的问题。</p><h3 id="缓存不一致的解决"><a href="#缓存不一致的解决" class="headerlink" title="缓存不一致的解决"></a><strong>缓存不一致的解决</strong></h3><p>一般有两种解决办法：</p><ul><li><p><strong>总线加锁</strong></p><blockquote><p>因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。</p></blockquote></li><li><p><strong>缓存一致性协议</strong></p><blockquote><p>由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。所以就出现了缓存一致性协议。最出名的就是Intel的<code>MESI协议</code>，<code>MESI协议</code>保证了每个缓存中使用的共享变量的副本是一致的。<br><code>MESI协议</code>核心思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p></blockquote></li></ul><h2 id="二、线程安全问题"><a href="#二、线程安全问题" class="headerlink" title="二、线程安全问题"></a>二、线程安全问题</h2><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a><strong>产生原因</strong></h3><p>从前面的分析，在并发编程（多线程编程）中，可能出现线程安全的问题：</p><ul><li><p>多个线程在操作共享的数据。</p></li><li><p>操作共享数据的线程代码有多条。</p></li><li><p>当一个线程在执行操作共享数据的多条代码过程中，其他线程参与了运算。</p></li></ul><h3 id="并发的核心概念"><a href="#并发的核心概念" class="headerlink" title="并发的核心概念"></a><strong>并发的核心概念</strong></h3><p><strong>三个核心概念：原子性、可见性、顺序性。</strong></p><ul><li>原子性：跟数据库事务的原子性概念差不多，即一个操作（有可能包含有多个子操作）要么全部执行（生效），要么全部都不执行（都不生效）。<blockquote><p><code>锁和同步</code>（同步方法和同步代码块）、<code>CAS</code>（CPU级别的CAS指令<code>cmpxchg</code>）。</p></blockquote></li></ul><ul><li><p>可见性：当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即看到。</p><blockquote><p><code>volatile</code>关键字来保证可见性。</p></blockquote></li><li><p>顺序性：程序执行的顺序按照代码的先后顺序执行。因为处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的-即<code>指令重排序</code>。</p><blockquote><p><code>volatile</code>在一定程序上保证顺序性，另外还可以通过<code>synchronized</code>和<code>锁</code>来保证顺序性。</p></blockquote></li></ul><h2 id="三、Java对象头的结构"><a href="#三、Java对象头的结构" class="headerlink" title="三、Java对象头的结构"></a>三、Java对象头的结构</h2><p>Java对象可以作为并发编程中的锁。而锁实际上存在于Java对象头里。如果对象是数组类型，则虚拟机用 3 个 Word（字宽）存储对象头，如果对象是非数组类型，则用 2 字宽存储对象头。在 64 位虚拟机中，一字宽等于八字节，即 <code>64bit</code>。</p><p>Java 对象头里的 <code>Mark Word</code> 里默认存储对象的 HashCode，分代年龄和锁标记位。32 位 JVM 的 Mark Word 的默认存储结构如下：</p><div class="table-container"><table><thead><tr><th>-</th><th>25 bit</th><th>4bit</th><th>偏向锁标志位(1bit)</th><th>锁标志位(2bit)</th></tr></thead><tbody><tr><td>无锁状态</td><td>对象的hashCode</td><td>对象分代年龄</td><td></td><td>01</td></tr></tbody></table></div><p>64 位JVM的存储结构如下：</p><table><tbody><tr><td rowspan="2">            <p><b><span>锁状态<span lang="EN-US"></span></span></b></p>            </td>            <td>            <p><span lang="EN-US">25bit</span></p>            </td>            <td>            <p><span lang="EN-US">31bit</span></p>            </td>            <td>            <p><span lang="EN-US">1bit</span></p>            </td>            <td>            <p><span lang="EN-US">4bit</span></p>            </td>            <td colspan="2">            <p><span lang="EN-US">1bit</span></p>            </td>            <td>            <p><span lang="EN-US">2bit</span></p>            </td>        </tr><tr><td>            </td>            <td>            </td>            <td>            <p><span lang="EN-US">cms_free</span></p>            </td>            <td>            <p><span>分代年龄<span lang="EN-US"></span></span></p>            </td>            <td colspan="2">            <p><span>偏向锁<span lang="EN-US"></span></span></p>            </td>            <td>            <p><span>锁标志位<span lang="EN-US"></span></span></p>            </td>        </tr><tr><td>            <p><span>无锁<span lang="EN-US"></span></span></p>            </td>            <td>            <p><span lang="EN-US">unused</span></p>            </td>            <td>            <p><span lang="EN-US">hashCode</span></p>            </td>            <td>            </td>            <td>            </td>            <td>            </td>            <td colspan="2">            <p><span lang="EN-US">01</span></p>            </td>        </tr><tr><td>            <p><span>偏向锁<span lang="EN-US"></span></span></p>            </td>            <td colspan="2">            <p><span lang="EN-US">ThreadID(54bit) Epoch(2bit)</span></p>            </td>            <td>            </td>            <td>            </td>            <td>            <p><span lang="EN-US">1</span></p>            </td>            <td colspan="2">            <p><span lang="EN-US">01</span></p>            </td>        </tr></tbody></table>在运行期间 `Mark Word` 里存储的数据会随着锁标志位的变化而变化。---<font color="red">**在了解了相关概念后，接下来介绍Java是如何保证并发编程中的安全的。**</font>---## <font color="red">**四、synchronized**</font>### **用法** - 修饰同步代码块 >将多条操作共享数据的线程代码封装起来，当有线程在执行这些代码的时候，其他线程时不可以参与运算的。必须要当前线程把这些代码都执行完毕后，其他线程才可以参与运算。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">synchronized</span>(对象)</span><br><span class="line">&#123;</span><br><span class="line">需要被同步的代码 ；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> - 修饰同步函数(方法) <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 修饰符 <span class="keyword">synchronized</span> 返回值 方法名()&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> - 修饰一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； - 修饰一个类，其作用的范围是`synchronized`后面括号括起来的部分，作用主的对象是这个类的所有对象。>`synchronized`的作用主要有三个：（1）确保线程互斥的访问同步代码（2）保证共享变量的修改能够及时可见（3）有效解决重排序问题。### **锁对象** - 对于同步方法，锁是当前`实例对象`。 - 对于静态同步方法，锁是当前对象的 `Class 对象`。 - 对于同步方法块，锁是 `synchonized` 括号里配置的对象。### **实现原理**在编译的字节码中加入了两条指令来进行代码的同步。#### **monitorenter ：**每个对象有一个`监视器锁（monitor）`。当`monitor`被占用时就会处于锁定状态，线程执行`monitorenter`指令时尝试获取`monitor`的所有权，过程如下：- 如果`monitor`的进入数为0，则该线程进入`monitor`，然后将进入数设置为1，该线程即为`monitor`的所有者。- 如果线程已经占有该`monitor`，只是重新进入，则进入`monitor`的进入数加1.- 如果其他线程已经占用了`monitor`，则该线程进入阻塞状态，直到`monitor`的进入数为0，再重新尝试获取`monitor`的所有权。#### **monitorexit：**执行`monitorexit`的线程必须是`objectref`所对应的`monitor`的所有者。指令执行时，`monitor`的进入数减1，如果减1后进入数为0，那线程退出`monitor`，不再是这个`monitor`的所有者。其他被这个`monitor`阻塞的线程可以尝试去获取这个 `monitor`的所有权。>`synchronized`的语义底层是通过一个`monitor`的对象来完成，其实`wait/notify`等方法也依赖于`monitor`对象，这就是为什么只有在同步的块或者方法中才能调用`wait/notify`等方法，否则会抛出`java.lang.IllegalMonitorStateException`的异常的原因。### **好处和弊端****好处**：解决了线程的安全问题。**弊端**：相对降低了效率，因为同步外的线程的都会判断同步锁。获得锁和释放锁带来性能消耗。### **编译器对synchronized优化**Java6 为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java6 里锁一共有四种状态：**无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态**，它会随着竞争情况逐渐升级。锁可以升级但不能降级。- **偏向锁**：大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后（线程的id会记录在对象的`Mark Wod`中），消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。- **轻量级锁（CAS）**：轻量级锁是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁；轻量级锁的意图是在没有多线程竞争的情况下，通过CAS操作尝试将MarkWord更新为指向LockRecord的指针，减少了使用重量级锁的系统互斥量产生的性能消耗。- **重量级锁**：虚拟机使用CAS操作尝试将MarkWord更新为指向LockRecord的指针，如果更新成功表示线程就拥有该对象的锁；如果失败，会检查MarkWord是否指向当前线程的栈帧，如果是，表示当前线程已经拥有这个锁；如果不是，说明这个锁被其他线程抢占，此时膨胀为重量级锁。### **锁状态对应的Mark Word**以32位JVM为例：<table><tbody><tr><td rowspan="2">            <p><b><span>锁状态<span lang="EN-US"></span></span></b></p>            </td>            <td colspan="3">            <p><span lang="EN-US">25   bit</span></p>            </td>            <td rowspan="2">            <p><span lang="EN-US">4bit</span></p>            </td>            <td>            <p><span lang="EN-US">1bit</span></p>            </td>            <td>            <p><span lang="EN-US">2bit</span></p>            </td>        </tr><tr><td colspan="2">            <p><span lang="EN-US">23bit</span></p>            </td>            <td>            <p><span lang="EN-US">2bit</span></p>            </td>            <td>            <p><span>是否是偏向锁<span lang="EN-US"></span></span></p>            </td>            <td>            <p><span>锁标志位<span lang="EN-US"></span></span></p>            </td>        </tr><tr><td>            <p><span>轻量级锁<span lang="EN-US"></span></span></p>            </td>            <td colspan="5">            <p><span>指向栈中锁记录的指针<span lang="EN-US"></span></span></p>            </td>            <td>            <p><span lang="EN-US">00</span></p>            </td>        </tr><tr><td>            <p><span>重量级锁<span lang="EN-US"></span></span></p>            </td>            <td colspan="5">            <p><span>指向互斥量（重量级锁）的指针<span lang="EN-US"></span></span></p>            </td>            <td>            <p><span lang="EN-US">10</span></p>            </td>        </tr><tr><td>            <p><span lang="EN-US">GC</span><span>标记<span lang="EN-US"></span></span></p>            </td>            <td colspan="5">            <p><span>空<span lang="EN-US"></span></span></p>            </td>            <td>            <p><span lang="EN-US">11</span></p>            </td>        </tr><tr><td>            <p><span>偏向锁<span lang="EN-US"></span></span></p>            </td>            <td>            <p><span>线程<span lang="EN-US">ID</span></span></p>            </td>            <td colspan="2">            <p><span lang="EN-US">Epoch</span></p>            </td>            <td>            <p><span>对象分代年龄<span lang="EN-US"></span></span></p>            </td>            <td>            <p><span lang="EN-US">1</span></p>            </td>            <td>            <p><span lang="EN-US">01</span></p>            </td>        </tr></tbody></table><h2 id="五、volatile"><a href="#五、volatile" class="headerlink" title="五、volatile"></a><font color="red"><strong>五、volatile</strong></font></h2><p><strong><code>volatile</code>是Java中的一个关键字，用来修饰共享变量（类的成员变量、类的静态成员变量）。</strong></p><p><strong>被修饰的变量包含两层语义：</strong></p><ul><li><p><strong>保证可见性</strong></p><blockquote><p>线程写入变量时不会把变量写入缓存，而是直接把值刷新回主存。同时，其他线程在读取该共享变量的时候，会从主内存重新获取值，而不是使用当前缓存中的值。（因此会带来一部分性能损失）。<font color="red"><strong>注意：往主内存中写入的操作不能保证原子性。</strong></font></p></blockquote></li><li><p><strong>禁止指令重排</strong></p><blockquote><p>禁止指令重排序有两层意思：<br>　1）当程序执行到<code>volatile</code>变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；<br>　2）在进行指令优化时，不能将在对<code>volatile</code>变量访问的语句放在其后面执行，也不能把<code>volatile</code>变量后面的语句放到其前面执行。</p></blockquote></li></ul><p><strong>底层实现：</strong>观察加入<code>volatile</code>关键字和没有加入<code>volatile</code>关键字时所生成的汇编代码发现，加入<code>volatile</code>关键字时，会多出一个<code>lock前缀指令</code>。</p><h2 id="六、Lock"><a href="#六、Lock" class="headerlink" title="六、Lock"></a><font color="red"><strong>六、Lock</strong></font></h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3><p>如果一个代码块被<code>synchronized</code>修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有<strong>两种情况</strong>：</p><ul><li>获取锁的线程执行完了该代码块，然后线程释放对锁的占有；</li><li>线程执行发生异常，此时JVM会让线程自动释放锁。</li></ul><p>如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，会让程序效率很差。</p><p><strong>因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过<code>Lock</code>就可以办到。</strong></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a><strong>源码分析</strong></h3><p>与Lock相关的接口和类位于<code>J.U.C</code>的<code>java.util.concurrent.locks</code>包下。<br><img src="https://s2.ax1x.com/2019/04/07/AhykrV.png" alt="此处输入图片的描述"></p><h4 id="1-Lock接口"><a href="#1-Lock接口" class="headerlink" title="(1)Lock接口"></a>(1)<strong>Lock接口</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>获取锁</strong><br><strong>lock()</strong>：获取锁，如果锁被暂用则一直等待。<br><strong>tryLock()</strong>: 有返回值的获取锁。注意返回类型是<code>boolean</code>，如果获取锁的时候锁被占用就返回<code>false</code>，否则返回<code>true</code>。<br><strong>tryLock(long time, TimeUnit unit)</strong>：比起tryLock()就是给了一个时间期限，保证等待参数时间。<br><strong>lockInterruptibly()</strong>：当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过<code>lock.lockInterruptibly()</code>想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用<code>threadB.interrupt()</code>方法能够中断线程B的等待过程。</p><blockquote><p><strong>注意</strong>：当一个线程获取了锁之后，是不会被<code>interrupt()</code>方法中断的。因为本身在前面的文章中讲过单独调用<code>interrupt()</code>方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。因此当通过<code>lockInterruptibly()</code>方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。用<code>synchronized</code>修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。</p></blockquote></li><li><p><strong>释放锁</strong><br><strong>unlock()</strong>:释放锁。</p></li></ul><h4 id="2-ReentrantLock类"><a href="#2-ReentrantLock类" class="headerlink" title="(2)ReentrantLock类"></a>(2)<strong>ReentrantLock类</strong></h4><p><code>ReentrantLock</code>，意思是“可重入锁”。<code>ReentrantLock</code>是唯一实现了<code>Lock</code>接口的类，并且<code>ReentrantLock</code>提供了更多的方法，基于<code>AQS(AbstractQueuedSynchronizer)</code>来实现的。</p><blockquote><p>并且，<code>ConcurrentHashMap</code>并没有采用<code>synchronized</code>进行控制，而是使用了<code>ReentrantLock</code>。</p></blockquote><ul><li><p><strong>构造方法</strong><br><code>ReentrantLock</code> 分为<strong>公平锁</strong>和<strong>非公平锁</strong>，可以通过构造方法来指定具体类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>获取锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>而<code>sync</code>是一个<code>abstract</code>内部类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">    private static final long serialVersionUID = -5179523762034025860L;</span><br><span class="line">    abstract void lock();</span><br></pre></td></tr></table></figure></p><p>其<code>lock()</code>方法用的是构造得到的<code>FairSync</code>对象，即<code>sync</code>的实现类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删去一些方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而<code>compareAndSetState</code>是<code>AQS</code>的一个方法，也就是基于<code>CAS</code>操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>尝试进一步获取锁（调用继承自父类<code>sync</code>的<code>final</code>方法）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先会判断 <code>AQS</code> 中的 <code>state</code> 是否等于 0，0表示目前没有其他线程获得锁，当前线程就可以尝试获取锁。如果 <code>state</code> 大于 0 时，说明锁已经被获取了，则需要判断获取锁的线程是否为当前线程(<code>ReentrantLock</code> 支持重入)，是则需要将 state + 1，并将值更新。</p><p>如果 <code>tryAcquire(arg)</code> 获取锁失败，则需要用<code>addWaiter(Node.EXCLUSIVE)</code> 将当前线程写入队列中。写入之前需要将当前线程包装为一个 <code>Node</code>对象<code>(addWaiter(Node.EXCLUSIVE))</code>。</p><p>即回到：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><strong>释放锁</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">公平锁和非公平锁的释放流程都是一样的：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">           <span class="comment">//唤醒被挂起的线程</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-ReadWriteLock接口与ReentrantReadWriteLock类"><a href="#3-ReadWriteLock接口与ReentrantReadWriteLock类" class="headerlink" title="(3)ReadWriteLock接口与ReentrantReadWriteLock类"></a>(3)<strong>ReadWriteLock接口</strong>与<strong>ReentrantReadWriteLock类</strong></h4><ul><li><strong>定义</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在<code>ReentrantLock</code>中，线程之间的同步都是互斥的，不管是读操作还是写操作，但是在一些场景中读操作是可以并行进行的，只有写操作才是互斥的，这种情况虽然也可以使用<code>ReentrantLock</code>来解决，但是在性能上也会损失，<code>ReadWriteLock</code>就是用来解决这个问题的。</p><ul><li><strong>实现-ReentrantReadWriteLock类</strong></li></ul><p>在<code>ReentrantReadWriteLock</code>中分别定义了读锁和写锁，与<code>ReentrantLock</code>类似，读锁和写锁的功能也是通过<code>Sync</code>实现的，<code>Sync</code>存在<strong>公平和非公平</strong>两种实现方式，不同的是表示锁状态的<code>state</code>的定义，在<code>ReentrantReadWriteLock</code>中具体定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT     = <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取读锁的占有次数</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line">  <span class="comment">//获取写锁的占有次数</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//线程的id和对应线程获取的读锁的数量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Use id, not reference, to avoid garbage retention</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> tid = Thread.currentThread().getId();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//线程变量保存线程和线程中获取的读写的数量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line">  <span class="comment">//缓存最后一个获取读锁的线程</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line">  <span class="comment">//保存第一个获取读锁的线程</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br></pre></td></tr></table></figure></p><p>其中，包含两个静态内部类：<code>ReadLock()</code>与<code>WriteLock()</code>,都实现了<code>Lock接口</code>。</p><p><strong>获取读锁</strong>：</p><ul><li>如果不存在线程持有写锁，则获取读锁成功。</li><li>如果其他线程持有写锁，则获取读锁失败。</li><li>如本线程持有写锁，并且不存在等待写锁的其他线程，则获取读锁成功。</li><li>如本线程持有写锁，并且存在等待写锁的其他线程，则如果本线程已经持有读锁，则获取读锁成功，如果不能存在读锁，则此次获取读锁失败。</li></ul><p><strong>获取写锁</strong>：</p><ul><li>判断是否有线程持有锁，包括读锁和写锁，如果有，则执行步骤2，否则步骤3</li><li>如果写锁为空(此时由于1步骤判断存在锁，则存在持有读锁的线程)，或者持有写锁的不是本线程,直接返回失败，如果写锁数量大于MAX_COUNT，返回失败，否则更新state，并且返回true</li><li>如果需要写锁堵塞判断，或者CAS失败直接返回false，否则设置持有写锁的线程为本线程，并且返回true</li><li>通过writerShouldBlock写锁堵塞判断<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//判断是否堵塞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">      ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="七、比较"><a href="#七、比较" class="headerlink" title="七、比较"></a><font color="red"><strong>七、比较</strong></font></h2><h3 id="Lock和synchronized"><a href="#Lock和synchronized" class="headerlink" title="Lock和synchronized"></a><strong>Lock和synchronized</strong></h3><p><code>synchronized</code>是基于JVM层面实现的，而Lock是基于JDK层面实现的。<code>Lock</code>需要<code>lock</code>和<code>release</code>，比<code>synchronized</code>复杂，但<code>Lock</code>可以做更细粒度的锁，支持获取超时、获取中断，这是<code>synchronized</code>所不具备的。Lock的实现主要有<code>ReentrantLock</code>、<code>ReadLock</code>和<code>WriteLock</code>,读读共享，写写互斥，读写互斥。</p><ul><li><p>Lock是一个<strong>接口</strong>，而synchronized是Java中的<strong>关键字</strong>，synchronized是内置的语言实现；</p></li><li><p>synchronized在发生异常时，会<strong>自动释放</strong>线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成<strong>死锁现象</strong>，因此使用Lock时需要在finally块中释放锁；</p></li><li><p>Lock可以让等待锁的线程<strong>响应中断</strong>，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</p></li><li><p>通过Lock可以知道有没有<strong>成功获取锁</strong>，而synchronized却无法办到。</p></li><li><p>Lock可以提高多个线程进行读操作的<strong>效率</strong>。　　</p></li><li>Lock实现和synchronized不一样，后者是一种<strong>悲观锁</strong>，它胆子很小，它很怕有人和它抢吃的，所以它每次吃东西前都把自己关起来。而Lock底层其实是CAS <strong>乐观锁</strong>的体现，它无所谓，别人抢了它吃的，它重新去拿吃的就好啦，所以它很乐观。底层主要靠<code>volatile</code>和<code>CAS</code>操作实现的。</li></ul><h3 id="synchronized和volatile"><a href="#synchronized和volatile" class="headerlink" title="synchronized和volatile"></a><strong>synchronized和volatile</strong></h3><ul><li><p>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；</p></li><li><p>synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</p></li><li><p>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的</p></li><li><p>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性</p></li><li><p>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</p></li><li><p>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化</p></li></ul><h2 id="七、死锁问题"><a href="#七、死锁问题" class="headerlink" title="七、死锁问题"></a><strong>七、死锁问题</strong></h2><p>死锁有四个必要条件，打破一个即可去除死锁。</p><h3 id="四个必要条件："><a href="#四个必要条件：" class="headerlink" title="四个必要条件："></a><strong>四个必要条件：</strong></h3><ul><li><p>互斥条件</p><blockquote><p>一个资源每次只能被一个进程使用。</p></blockquote></li><li><p>请求与保持条件</p><blockquote><p>一个线程因请求资源而阻塞时，对已获得的资源保持不放。</p></blockquote></li><li><p>不剥夺条件</p><blockquote><p>线程已获得的资源，在末使用完之前，不能强行剥夺。</p></blockquote></li><li><p>循环等待条件</p><blockquote><p>若干线程之间形成一种头尾相接的循环等待资源关系。</p></blockquote></li></ul><h3 id="死锁的例子"><a href="#死锁的例子" class="headerlink" title="死锁的例子"></a><strong>死锁的例子</strong></h3><p>同步嵌套时，两个线程互相锁住，都不释放，造成死锁。<br><strong>举例：</strong><br>创建两个字符串a和b，再创建两个线程A和B，让每个线程都用synchronized锁住字符串（A先锁a，再去锁b；B先锁b，再锁a），如果A锁住a，B锁住b，A就没办法锁住b，B也没办法锁住a，这时就陷入了死锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String obj1 = <span class="string">"obj1"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String obj2 = <span class="string">"obj2"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread a = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Lock1());</span><br><span class="line">        Thread b = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Lock2());</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Lock1 running"</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(DeadLock.obj1)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Lock1 lock obj1"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);<span class="comment">//获取obj1后先等一会儿，让Lock2有足够的时间锁住obj2</span></span><br><span class="line">                    <span class="keyword">synchronized</span>(DeadLock.obj2)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"Lock1 lock obj2"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Lock2 running"</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(DeadLock.obj2)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Lock2 lock obj2"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span>(DeadLock.obj1)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"Lock2 lock obj1"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="八、锁的概念"><a href="#八、锁的概念" class="headerlink" title="八、锁的概念"></a><strong>八、锁的概念</strong></h2><p><strong>在 java 中锁的实现主要有两类：内部锁 <code>synchronized</code>（对象内置的monitor锁）和显示锁<code>java.util.concurrent.locks.Lock</code>。</strong></p><ul><li><p><strong>可重入锁</strong></p><blockquote><p>指的是同一线程外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响，执行对象中所有同步方法不用再次获得锁。<code>synchronized</code>和<code>Lock</code>都具备可重入性。</p></blockquote></li><li><p><strong>可中断锁</strong></p><blockquote><p><code>synchronized</code>就不是可中断锁，而Lock是可中断锁。</p></blockquote></li><li><p><strong>公平锁</strong></p><blockquote><p>按等待获取锁的线程的等待时间进行获取，<strong>等待时间长</strong>的具有优先获取锁权利。<code>synchronized</code>就是非公平锁；对于<code>ReentrantLock</code>和<code>ReentrantReadWriteLock</code>，它默认情况下是非公平锁，但是可以设置为公平锁。</p></blockquote></li><li><p><strong>读写锁</strong></p><blockquote><p>对资源读取和写入的时候拆分为2部分处理，读的时候可以多线程一起读，写的时候必须同步地写。<code>ReadWriteLock</code>就是读写锁，它是一个接口，<code>ReentrantReadWriteLock</code>实现了这个接口。</p></blockquote></li><li><p><strong>自旋锁</strong></p><blockquote><p>让线程去执行一个无意义的循环，循环结束后再去重新竞争锁，如果竞争不到继续循环，循环过程中线程会一直处于<code>running</code>状态，但是基于JVM的线程调度，会让出时间片，所以其他线程依旧有申请锁和释放锁的机会。自旋锁省去了阻塞锁的时间空间（队列的维护等）开销，但是长时间自旋就变成了“忙式等待”，忙式等待显然还不如阻塞锁。所以自旋的次数一般控制在一个范围内，例如10,100等，在超出这个范围后，自旋锁会升级为阻塞锁。</p></blockquote></li><li><p><strong>独占锁</strong></p><blockquote><p>是一种<strong>悲观锁</strong>，<code>synchronized</code>就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。</p></blockquote></li><li><p><strong>乐观锁</strong></p><blockquote><p>每次不加锁，假设没有冲突去完成某项操作，如果因为冲突失败就重试，直到成功为止。</p></blockquote></li><li><p><strong>悲观锁</strong></p><blockquote><p>导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。</p></blockquote></li></ul><h3 id="关于JUC"><a href="#关于JUC" class="headerlink" title="关于JUC"></a><strong>关于JUC</strong></h3><p>包含了两个子包：atomic以及lock，另外在concurrent下的阻塞队列以及executors，以后再深入学习吧，下面这个图很是经典：<br><img src="https://user-gold-cdn.xitu.io/2018/5/3/163260cff7cb847c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="此处输入图片的描述"></p><hr><p><strong>参考链接</strong></p><ul><li><a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">Java并发编程：volatile关键字解析</a></li><li><a href="https://www.cnblogs.com/dolphin0520/p/3923167.html" target="_blank" rel="noopener">Java SE1.6 中的 Synchronized</a></li><li><a href="https://www.cnblogs.com/dolphin0520/p/3923167.html" target="_blank" rel="noopener">Java并发编程：Lock</a></li><li><a href="https://juejin.im/post/5a067fa251882578d84eee8f" target="_blank" rel="noopener">Java并发机制的底层实现</a></li><li><a href="https://www.cnblogs.com/mudao/p/5867107.html" target="_blank" rel="noopener">Java死锁</a></li><li><a href="https://book.douban.com/subject/6522893/" target="_blank" rel="noopener">深入理解JVM</a></li><li><a href="https://juejin.im/post/5aeb055b6fb9a07abf725c8c" target="_blank" rel="noopener">初识Lock与AbstractQueuedSynchronizer(AQS)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1551345094255&amp;amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;amp;imgtype=0&amp;amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;code&gt;volatile&lt;/code&gt;, &lt;code&gt;synchronized&lt;/code&gt;, &lt;code&gt;Lock&lt;/code&gt;? 详解Java的线程安全与锁！&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Java源码" scheme="https://yoursite.com/tags/Java%E6%BA%90%E7%A0%81/"/>
    
      <category term="Java并发" scheme="https://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>算法之美-剑指Offer题解(Java实现)</title>
    <link href="https://yoursite.com/2019/03/21/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3(Java%E5%AE%9E%E7%8E%B0)/"/>
    <id>https://yoursite.com/2019/03/21/算法之美-剑指Offer题解(Java实现)/</id>
    <published>2019-03-21T07:01:01.000Z</published>
    <updated>2019-03-30T03:21:44.394Z</updated>
    
    <content type="html"><![CDATA[<p>剑指Offer的所有题目和分类，<code>Solution</code>用<code>Java</code>语言实现。</p><a id="more"></a><h2 id="剑指Offer题解"><a href="#剑指Offer题解" class="headerlink" title="剑指Offer题解"></a><font color="red"><strong>剑指Offer题解</strong></font></h2><p><code>点击每个题目对应的分类即可看到题目和解答</code></p><div class="table-container"><table><thead><tr><th style="text-align:center">#</th><th style="text-align:center">名称</th><th style="text-align:center">分类</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">左旋转字符串</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution1.java" target="_blank" rel="noopener">字符串</a></td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">实现 Singleton</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution2.java" target="_blank" rel="noopener">设计模式</a></td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">数组中重复的数字</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution3.java" target="_blank" rel="noopener">数组</a></td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">二维数组中的查找</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution4.java" target="_blank" rel="noopener">数组</a></td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">替换空格</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution5.java" target="_blank" rel="noopener">字符串</a></td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">从尾到头打印链表</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution6.java" target="_blank" rel="noopener">链表</a></td></tr><tr><td style="text-align:center">7</td><td style="text-align:center"><strong>重建二叉树</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution7.java" target="_blank" rel="noopener">树</a></td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">二叉树的下一个节点</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution8.java" target="_blank" rel="noopener">树</a></td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">用两个栈实现队列</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution9.java" target="_blank" rel="noopener">栈、队列</a></td></tr><tr><td style="text-align:center">10.1</td><td style="text-align:center">斐波那契数列</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution10_1.java" target="_blank" rel="noopener">动态规划、递归</a></td></tr><tr><td style="text-align:center">10.2</td><td style="text-align:center">（变态）跳台阶</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution10_2.java" target="_blank" rel="noopener">动态规划、递归</a></td></tr><tr><td style="text-align:center">10.3</td><td style="text-align:center">矩形覆盖</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution10_3.java" target="_blank" rel="noopener">动态规划、递归</a></td></tr><tr><td style="text-align:center">10.4</td><td style="text-align:center"><strong>背包问题详解</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution10_4.java" target="_blank" rel="noopener">动态规划、递归</a></td></tr><tr><td style="text-align:center">11</td><td style="text-align:center"><strong>旋转数组的最小数字</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution11.java" target="_blank" rel="noopener">数组</a></td></tr><tr><td style="text-align:center">12</td><td style="text-align:center"><strong>矩阵中的路径</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution12.java" target="_blank" rel="noopener">回溯</a></td></tr><tr><td style="text-align:center">13</td><td style="text-align:center"><strong>机器人的运动范围</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution13.java" target="_blank" rel="noopener">回溯</a></td></tr><tr><td style="text-align:center">14</td><td style="text-align:center"><strong>剪绳子</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution14.java" target="_blank" rel="noopener">动态规划、贪心算法</a></td></tr><tr><td style="text-align:center">15</td><td style="text-align:center"><strong>二进制中 1 的个数</strong>，附<a href="https://blog.csdn.net/zhouzipeng000/article/details/56676885" target="_blank" rel="noopener">源码解析</a></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution15.java" target="_blank" rel="noopener">位运算</a></td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">数值的整数次方</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution16.java" target="_blank" rel="noopener">递归</a></td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">打印从 1 到最大的 n 位数</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution17.java" target="_blank" rel="noopener">回溯</a></td></tr><tr><td style="text-align:center">18.1</td><td style="text-align:center">在 O(1) 时间内删除链表节点</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution18_1.java" target="_blank" rel="noopener">链表</a></td></tr><tr><td style="text-align:center">18.2</td><td style="text-align:center">删除链表中重复的结点</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution18_2.java" target="_blank" rel="noopener">链表,回溯</a></td></tr><tr><td style="text-align:center">19</td><td style="text-align:center"><strong>正则表达式匹配</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution19.java" target="_blank" rel="noopener">递归，动态规划</a></td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">表示数字的字符串</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution20.java" target="_blank" rel="noopener">正则</a></td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">调整数组顺序使奇数位于偶数前面</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution21.java" target="_blank" rel="noopener">数组</a></td></tr><tr><td style="text-align:center">22</td><td style="text-align:center">链表中倒数第 K 个结点</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution22.java" target="_blank" rel="noopener">链表，双指针</a></td></tr><tr><td style="text-align:center">23</td><td style="text-align:center"><strong>链表中环的入口结点</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution23.java" target="_blank" rel="noopener">双指针</a></td></tr><tr><td style="text-align:center">24</td><td style="text-align:center"><strong>反转链表</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution24.java" target="_blank" rel="noopener">递归，链表</a></td></tr><tr><td style="text-align:center">25</td><td style="text-align:center">合并两个排序的链表</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution25.java" target="_blank" rel="noopener">链表，递归</a></td></tr><tr><td style="text-align:center">26</td><td style="text-align:center"><strong>树的子结构</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution26.java" target="_blank" rel="noopener">递归，树</a></td></tr><tr><td style="text-align:center">27</td><td style="text-align:center">二叉树的镜像</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution27.java" target="_blank" rel="noopener">树，递归</a></td></tr><tr><td style="text-align:center">28</td><td style="text-align:center">对称的二叉树</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution28.java" target="_blank" rel="noopener">树，递归</a></td></tr><tr><td style="text-align:center">29</td><td style="text-align:center">顺时针打印矩阵</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution29.java" target="_blank" rel="noopener">逻辑能力</a></td></tr><tr><td style="text-align:center">30</td><td style="text-align:center">包含 min 函数的栈</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution30.java" target="_blank" rel="noopener">栈,类似9</a></td></tr><tr><td style="text-align:center">31</td><td style="text-align:center"><strong>栈的压入、弹出序</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution31.java" target="_blank" rel="noopener">栈</a></td></tr><tr><td style="text-align:center">32.1</td><td style="text-align:center"><strong>从上往下打印二叉树</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution32.java" target="_blank" rel="noopener">队列</a></td></tr><tr><td style="text-align:center">32.2</td><td style="text-align:center"><strong>分层打印二叉树</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution32_2.java" target="_blank" rel="noopener">队列</a></td></tr><tr><td style="text-align:center">32.3</td><td style="text-align:center">之字形打印二叉树</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution32_3.java" target="_blank" rel="noopener">队列</a></td></tr><tr><td style="text-align:center">33</td><td style="text-align:center">二叉搜索树的后序遍历序列</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution33.java" target="_blank" rel="noopener">树的遍历，递归</a></td></tr><tr><td style="text-align:center">34</td><td style="text-align:center"><strong>二叉树中和为某一值的路径</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution34.java" target="_blank" rel="noopener">树，递归</a></td></tr><tr><td style="text-align:center">35</td><td style="text-align:center"><strong>复杂链表的复制</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution35.java" target="_blank" rel="noopener">复杂链表</a></td></tr><tr><td style="text-align:center">36</td><td style="text-align:center"><strong>二叉搜索树与双向链表</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution36.java" target="_blank" rel="noopener">二叉树、链表</a></td></tr><tr><td style="text-align:center">37</td><td style="text-align:center"><strong>序列化二叉树</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution37.java" target="_blank" rel="noopener">二叉树、递归</a></td></tr><tr><td style="text-align:center">38</td><td style="text-align:center"><strong>字符串的排列</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution38.java" target="_blank" rel="noopener">回溯</a></td></tr><tr><td style="text-align:center">39</td><td style="text-align:center"><strong>数组中出现次数超过一半的数字</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution39.java" target="_blank" rel="noopener">多数投票问题</a></td></tr><tr><td style="text-align:center">40</td><td style="text-align:center"><strong>最小的 K 个数</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution40.java" target="_blank" rel="noopener">快排，大根堆小根堆</a></td></tr><tr><td style="text-align:center">41.1</td><td style="text-align:center">数据流中的中位数</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution41_1.java" target="_blank" rel="noopener">大根堆小根堆</a></td></tr><tr><td style="text-align:center">41.2</td><td style="text-align:center">字符流中第一个不重复的字符</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution41_2.java" target="_blank" rel="noopener">数据流</a></td></tr><tr><td style="text-align:center">42</td><td style="text-align:center">连续子数组的最大和</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution42.java" target="_blank" rel="noopener">数组</a></td></tr><tr><td style="text-align:center">43</td><td style="text-align:center"><strong>从 1 到 n 整数中 1 出现的次数</strong>，leetcode-233（Hard）</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution43.java" target="_blank" rel="noopener">逻辑</a></td></tr><tr><td style="text-align:center">44</td><td style="text-align:center">数字序列中的某一位数字</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution44.java" target="_blank" rel="noopener">逻辑</a></td></tr><tr><td style="text-align:center">45</td><td style="text-align:center"><strong>把数组排成最小的数</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution45.java" target="_blank" rel="noopener">排序，逻辑</a></td></tr><tr><td style="text-align:center">46</td><td style="text-align:center"><strong>把数字翻译成字符串</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution46.java" target="_blank" rel="noopener">动态规划</a></td></tr><tr><td style="text-align:center">47</td><td style="text-align:center">礼物的最大价值</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution47.java" target="_blank" rel="noopener">动态规划</a></td></tr><tr><td style="text-align:center">48</td><td style="text-align:center">最长不含重复字符的子字符串</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution48.java" target="_blank" rel="noopener">双指针</a></td></tr><tr><td style="text-align:center">49</td><td style="text-align:center"><strong>丑数</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution49.java" target="_blank" rel="noopener">动态规划，逻辑</a></td></tr><tr><td style="text-align:center">50</td><td style="text-align:center"><strong>第一个只出现一次的字符位置</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution50.java" target="_blank" rel="noopener">BitSet</a></td></tr><tr><td style="text-align:center">51</td><td style="text-align:center"><strong>数组中的逆序对</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution51.java" target="_blank" rel="noopener">排序问题</a></td></tr><tr><td style="text-align:center">52</td><td style="text-align:center"><strong>两个链表的第一个公共结点</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution52.java" target="_blank" rel="noopener">链表，双指针</a></td></tr><tr><td style="text-align:center">53</td><td style="text-align:center"><strong>数字在排序数组中出现的次数</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution53.java" target="_blank" rel="noopener">二分查找</a></td></tr><tr><td style="text-align:center">54</td><td style="text-align:center"><font color="red"><strong>二叉查找树的第 K 个结点</strong><font></font></font></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution54.java" target="_blank" rel="noopener">二叉树，中序遍历</a></td></tr><tr><td style="text-align:center">55.1</td><td style="text-align:center">二叉树的深度</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution55_1.java" target="_blank" rel="noopener">回溯</a></td></tr><tr><td style="text-align:center">55.2</td><td style="text-align:center">平衡二叉树</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution55_2.java" target="_blank" rel="noopener">回溯</a></td></tr><tr><td style="text-align:center">56</td><td style="text-align:center"><strong>数组中只出现一次的数字</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution56.java" target="_blank" rel="noopener">位运算</a></td></tr><tr><td style="text-align:center">57.1</td><td style="text-align:center">和为S的两个数字</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution57_1.java" target="_blank" rel="noopener">数组，双指针</a></td></tr><tr><td style="text-align:center">57.2</td><td style="text-align:center">和为 S 的连续正数序列</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution57_2.java" target="_blank" rel="noopener">数组，双指针</a></td></tr><tr><td style="text-align:center">58</td><td style="text-align:center">翻转单词顺序列</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution58_1.java" target="_blank" rel="noopener">字符串</a></td></tr><tr><td style="text-align:center">59</td><td style="text-align:center">滑动窗口的最大值</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution59.java" target="_blank" rel="noopener">大根堆，滑动窗口</a></td></tr><tr><td style="text-align:center">60</td><td style="text-align:center"><strong>动态规划解法</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution60.java" target="_blank" rel="noopener">动态规划，旋转数组</a></td></tr><tr><td style="text-align:center">61</td><td style="text-align:center">扑克牌顺子</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution61.java" target="_blank" rel="noopener">数组</a></td></tr><tr><td style="text-align:center">62</td><td style="text-align:center"><font color="red"><strong>圆圈中最后剩下的数</strong><font></font></font></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution62.java" target="_blank" rel="noopener">约瑟夫环</a></td></tr><tr><td style="text-align:center">63</td><td style="text-align:center">股票的最大利润</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution63.java" target="_blank" rel="noopener">数组</a></td></tr><tr><td style="text-align:center">64</td><td style="text-align:center">求 1+2+3+…+n</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution64.java" target="_blank" rel="noopener">递归，&amp;&amp;短路</a></td></tr><tr><td style="text-align:center">65</td><td style="text-align:center"><strong>不用加减乘除做加法</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution65.java" target="_blank" rel="noopener">位运算，BigInteger</a></td></tr><tr><td style="text-align:center">66</td><td style="text-align:center">构建乘积数组</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution66.java" target="_blank" rel="noopener">逻辑</a></td></tr><tr><td style="text-align:center">67</td><td style="text-align:center">把字符串转换成整数</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution67.java" target="_blank" rel="noopener">字符串</a></td></tr><tr><td style="text-align:center">68</td><td style="text-align:center">树中两个节点的最低公共祖先</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution68.java" target="_blank" rel="noopener">二分查找树，递归</a></td></tr></tbody></table></div><hr><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h3><ol><li>何海涛. 剑指 Offer[M]. 电子工业出版社, 2012.</li><li>题目顺序参考：<a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md" target="_blank" rel="noopener">CS-Notes-剑指offer题解</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指Offer的所有题目和分类，&lt;code&gt;Solution&lt;/code&gt;用&lt;code&gt;Java&lt;/code&gt;语言实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="https://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="algorithms" scheme="https://yoursite.com/tags/algorithms/"/>
    
      <category term="Java算法" scheme="https://yoursite.com/tags/Java%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="https://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>算法之美-用两个X实现一个Y</title>
    <link href="https://yoursite.com/2019/02/21/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E2%80%94%E7%94%A8%E4%B8%A4%E4%B8%AAX%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAY/"/>
    <id>https://yoursite.com/2019/02/21/算法之美—用两个X实现一个Y/</id>
    <published>2019-02-21T12:01:01.000Z</published>
    <updated>2019-03-21T16:08:11.010Z</updated>
    
    <content type="html"><![CDATA[<p>对于经典面试题：“两个栈实现队列”和“两个队列实现栈”,应该怎么考虑呢？<br><a id="more"></a></p><h2 id="两个栈实现队列"><a href="#两个栈实现队列" class="headerlink" title="两个栈实现队列"></a>两个栈实现队列</h2><p><strong>思路:</strong> 利用inStack作为进队的缓存。出队时，因为考虑到“先进先出”，可以利用另一个栈outStack转存当前的缓存。出队时，为了保证再入队依旧满足规律，若outStack为空，先<strong>全部</strong>倒入outStack；若不为空，则outStack直接出栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Stack&lt;Integer&gt; inStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> Stack&lt;Integer&gt; outStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(Integer in)</span></span>&#123;</span><br><span class="line">    inStack.push(in);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Integer <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(outStack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(!inStack.isEmpty())&#123;</span><br><span class="line">            outStack.push(inStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(outStack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"no data"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> outStack.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Solution9 test = <span class="keyword">new</span> Solution9();</span><br><span class="line">    test.push(<span class="number">8</span>);</span><br><span class="line">    test.push(<span class="number">9</span>);</span><br><span class="line">    test.push(<span class="number">99</span>);</span><br><span class="line">    System.out.println(test.pop());</span><br><span class="line">    test.push(<span class="number">999</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两个队列实现栈"><a href="#两个队列实现栈" class="headerlink" title="两个队列实现栈"></a>两个队列实现栈</h2><p><strong>思路：</strong> 利用一个队存储，另一个队作为缓存。当出栈时，让非空的队列先出队n-1，最后剩下的一个出队则完成了栈的“先入先出”的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; queue1=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();  </span><br><span class="line">LinkedList&lt;Integer&gt; queue2=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span><span class="comment">//入栈  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    queue1.addLast(value);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span><span class="comment">//出栈     必须是非空的栈才能出栈啊  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(sSize()!=<span class="number">0</span>)<span class="comment">//栈不为空  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//移动一个队的n-1个到另一个中  </span></span><br><span class="line">        <span class="keyword">if</span>(!queue1.isEmpty())<span class="comment">//q1 空  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            putN_1ToAnthor();  </span><br><span class="line">            <span class="keyword">return</span> queue1.removeFirst();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//q2 空  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            putN_1ToAnthor();  </span><br><span class="line">            <span class="keyword">return</span> queue2.removeFirst();  </span><br><span class="line">        &#125;          </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">"栈已经为空啦，不能出栈"</span>);  </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sSize</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> queue1.size()+queue2.size();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putN_1ToAnthor</span><span class="params">()</span><span class="comment">//从非空中出队n-1个到另一个队列   因为队列总是一空一非空  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(!queue1.isEmpty())  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">while</span>(queue1.size()&gt;<span class="number">1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            queue2.addLast(queue1.removeFirst());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!queue2.isEmpty())  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">while</span>(queue2.size()&gt;<span class="number">1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            queue1.addLast(queue2.removeFirst());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其他类似题目（更新中。。）</p></blockquote><h2 id="包含-min-函数的栈"><a href="#包含-min-函数的栈" class="headerlink" title="包含 min 函数的栈"></a>包含 min 函数的栈</h2><p><strong>题目描述</strong>：定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; datastack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minstack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        datastack.push(node);</span><br><span class="line"><span class="comment">//        if(minstack.isEmpty())&#123;</span></span><br><span class="line"><span class="comment">//            minstack.push(node);</span></span><br><span class="line"><span class="comment">//        &#125;else&#123;</span></span><br><span class="line"><span class="comment">//            if(minstack.peek()&lt;node)&#123;</span></span><br><span class="line"><span class="comment">//                minstack.push(minstack.peek());</span></span><br><span class="line"><span class="comment">//            &#125;else&#123;</span></span><br><span class="line"><span class="comment">//                minstack.push(node);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//注意minstack栈顶始终存储的当前栈的最小值，且长度和datastack一样</span></span><br><span class="line">        minStack.push(minStack.isEmpty() ? node : Math.min(minStack.peek(), node));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        datastack.pop();</span><br><span class="line">        minstack.pop();<span class="comment">//注意这里</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> datastack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minstack.peek();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a>数据流中的中位数</h2><p><strong>题目描述</strong>：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p><blockquote><p>两个栈实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用两个栈实现的</span></span><br><span class="line">    Stack&lt;Integer&gt; min = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; max = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        number++;</span><br><span class="line">        <span class="keyword">if</span>(min.size() == <span class="number">0</span> &amp;&amp; (max.size() == <span class="number">0</span> || num &lt;= max.peek()))&#123;</span><br><span class="line">            min.push(num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max.size() == <span class="number">0</span> &amp;&amp; (min.size() == <span class="number">0</span> || num &gt;= min.peek()))&#123;</span><br><span class="line">            max.push(num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num &gt; max.peek())&#123;</span><br><span class="line">            <span class="keyword">while</span>(max.size() != <span class="number">0</span> &amp;&amp; num&gt;max.peek())&#123;</span><br><span class="line">                min.push(max.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; min.peek())&#123;</span><br><span class="line">            <span class="keyword">while</span>( min.size() != <span class="number">0</span>&amp;&amp; num&lt;min.peek() )&#123;</span><br><span class="line">                max.push(min.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        min.push(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(min.size()&lt;number/<span class="number">2</span>)&#123;</span><br><span class="line">            min.push(max.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(min.size()&gt;number/<span class="number">2</span>)&#123;</span><br><span class="line">            max.push(min.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(number%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (min.peek()+max.peek())/<span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)max.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>两个大根堆实现：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//用堆实现的</span></span><br><span class="line">    <span class="comment">/* 大顶堆，存储左半边元素 */</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; left = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line">    <span class="comment">/* 小顶堆，存储右半边元素，并且右半边元素都大于左半边 */</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; right = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="comment">/* 当前数据流读入的元素个数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert2</span><span class="params">(Integer val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 插入要保证两个堆存于平衡状态 */</span></span><br><span class="line">        <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* N 为偶数的情况下插入到右半边。</span></span><br><span class="line"><span class="comment">* 因为右半边元素都要大于左半边，但是新插入的元素不一定比左半边元素</span></span><br><span class="line"><span class="comment">来的大，</span></span><br><span class="line"><span class="comment">* 因此需要先将元素插入左半边，然后利用左半边为大顶堆的特点，取出堆</span></span><br><span class="line"><span class="comment">顶元素即为最大元素，此时插入右半边 */</span></span><br><span class="line">            left.add(val);</span><br><span class="line">            right.add(left.poll());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right.add(val);</span><br><span class="line">            left.add(right.poll());</span><br><span class="line">        &#125; N</span><br><span class="line">                ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (left.peek() + right.peek()) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) right.peek();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于经典面试题：“两个栈实现队列”和“两个队列实现栈”,应该怎么考虑呢？&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="https://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="algorithms" scheme="https://yoursite.com/tags/algorithms/"/>
    
      <category term="Java算法" scheme="https://yoursite.com/tags/Java%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据库(4)-事务与数据库连接池</title>
    <link href="https://yoursite.com/2019/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93(4)-%E4%BA%8B%E5%8A%A1%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <id>https://yoursite.com/2019/02/17/数据库(4)-事务与数据库连接池/</id>
    <published>2019-02-17T12:48:20.000Z</published>
    <updated>2019-03-26T13:40:23.335Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/03/14/AAvGd0.jpg" alt="此处输入图片的描述"><br>本文总结<code>数据库事务</code>、<code>安全问题与隔离级别</code>，以及<code>数据库连接池</code>的相关知识。<br><a id="more"></a></p><h2 id="一、MySQL事务-Transaction"><a href="#一、MySQL事务-Transaction" class="headerlink" title="一、MySQL事务(Transaction)"></a>一、MySQL事务(Transaction)</h2><blockquote><p><strong>MySQL 事务</strong>主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务。</p><p>MYSQL 事务处理主要有两种方法：</p></blockquote><ul><li><p>1、用 BEGIN, ROLLBACK, COMMIT来实现</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> 开始一个事务</span><br><span class="line">//<span class="keyword">START</span> <span class="keyword">TRANSACTION</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> 事务回滚</span><br><span class="line"><span class="keyword">COMMIT</span> 事务确认</span><br></pre></td></tr></table></figure></li><li><p>2、直接用 SET 来改变 MySQL 的自动提交模式:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> AUTOCOMMIT=<span class="number">0</span> 禁止自动提交</span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT=<span class="number">1</span> 开启自动提交</span><br></pre></td></tr></table></figure></li></ul><p>在JDBC代码中，需要有两个声明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用Connection对象的setAutoCommit();</span></span><br><span class="line">Connection conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost/database_name"</span>, <span class="string">"user"</span>, <span class="string">"password"</span>);</span><br><span class="line">conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//随后执行数据库操作</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//最后提交</span></span><br><span class="line">conn.commit()</span><br><span class="line"><span class="comment">//并且在异常处理中回滚</span></span><br><span class="line">conn.rollback();</span><br></pre></td></tr></table></figure></p><p><code>注意：</code>setAutoCommit()只针对<code>Connection</code>对象，如果新建一个连接对象，仍然是默认提交。</p><h2 id="二、事务的特性"><a href="#二、事务的特性" class="headerlink" title="二、事务的特性"></a>二、事务的特性</h2><blockquote><p>事务是必须满足4个条件（ACID）：<strong>原子性</strong>（Atomicity，或称不可分割性）、<strong>一致性</strong>（Consistency）、<strong>隔离性</strong>（Isolation，又称独立性）、<strong>持久性</strong>（Durability）。</p></blockquote><ul><li><p>原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p></li><li><p>一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p></li><li><p>隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括<strong>读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</strong></p></li><li><p>持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p></li></ul><h2 id="三、数据库的安全问题和隔离级别"><a href="#三、数据库的安全问题和隔离级别" class="headerlink" title="三、数据库的安全问题和隔离级别"></a>三、数据库的安全问题和隔离级别</h2><h3 id="（1）安全问题-读"><a href="#（1）安全问题-读" class="headerlink" title="（1）安全问题-读"></a>（1）安全问题-读</h3><p><strong>脏读、 不可重复读、幻读</strong></p><blockquote><p>脏读:一个事务读到了另一个事务未提交的数据。</p><p>不可重复读:一个事务读到了另一个事务提交的数据，多次查询结果不一致。</p><p>幻读:一个事务读到了另一个事务已提交的插入的数据，导致多次查询结果不一致。</p></blockquote><h3 id="（2）安全问题-写"><a href="#（2）安全问题-写" class="headerlink" title="（2）安全问题-写"></a>（2）安全问题-写</h3><blockquote><p>丢失更新问题，指一个事务去修改数据库， 另一个事务也修改数据库，最后的那个事务，不管是提交还是回滚都会造成前面一个事务的数据更新丢失</p></blockquote><p>主要解决办法是加锁：<strong>乐观锁、悲观锁</strong>。</p><blockquote><p><strong>悲观锁：</strong>指事务在一开始就认为丢失更新一定会发生， 这是一件很悲观的事情。类似synchronized加锁。悲观锁通过在查询条件后面加<code>for udate</code>实现。</p><p><strong>乐观锁:</strong>指从来不会觉得丢失更新会发生。通过手动在数据库中设置字段，利用<code>CAS</code>操作实现。</p></blockquote><h3 id="（3）不可重复读和幻读的区别"><a href="#（3）不可重复读和幻读的区别" class="headerlink" title="（3）不可重复读和幻读的区别"></a>（3）不可重复读和幻读的区别</h3><p>幻读更加关注于insert操作,事务在插入已经检查过不存在的记录时，惊奇的发现这些数据已经存在了，之前的检测获取到的数据如同鬼影一般。</p><h3 id="（4）隔离级别-四种"><a href="#（4）隔离级别-四种" class="headerlink" title="（4）隔离级别-四种"></a>（4）<strong>隔离级别-四种</strong></h3><blockquote><p><strong>读未提交</strong>:Read Uncommitted</p></blockquote><p>引发问题： 脏读</p><blockquote><p><strong>读已提交</strong>:Read Committed</p></blockquote><p>解决： 脏读 ， 引发： 不可重复读</p><blockquote><p><strong>可重复读</strong>:Repeatable Read</p></blockquote><p>解决： 脏读 、 不可重复读 ， 未解决： 幻读</p><blockquote><p><strong>可串行化</strong>:Serializable</p></blockquote><p>解决： 脏读、 不可重复读 、 幻读。</p><blockquote><p><code>mySql</code> 默认的隔离级别是 可重复读<br><code>Oracle</code> 默认的隔离级别是  读已提交</p></blockquote><h3 id="（5）设置隔离级别"><a href="#（5）设置隔离级别" class="headerlink" title="（5）设置隔离级别"></a>（5）设置隔离级别</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//读未提交</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> uncommited;</span><br><span class="line">//读已提交</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> commited;</span><br><span class="line">//可重复读</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> repeatable <span class="keyword">read</span>;</span><br><span class="line">//可串行化</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">serializable</span>;</span><br></pre></td></tr></table></figure><h2 id="四、数据库连接池"><a href="#四、数据库连接池" class="headerlink" title="四、数据库连接池"></a>四、数据库连接池</h2><h3 id="（1）作用"><a href="#（1）作用" class="headerlink" title="（1）作用"></a>（1）作用</h3><blockquote><p>1． 资源重用</p></blockquote><p>由于数据库连接得到重用，避免了频繁创建、释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增进了系统运行环境的平稳性（减少内存碎片以及数据库临时进程/线程的数量）。</p><blockquote><p>2． 更快的系统响应速度</p></blockquote><p>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而缩减了系统整体响应时间。</p><blockquote><p>3． 新的资源分配手段</p></blockquote><p>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接的配置，实现数据库连接池技术，几年钱也许还是个新鲜话题，对于目前的业务系统而言，如果设计中还没有考虑到连接池的应用，那么…….快在设计文档中加上这部分的内容吧。某一应用最大可用数据库连接数的限制，避免某一应用独占所有数据库资源。</p><blockquote><p>4． 统一的连接管理，避免数据库连接泄漏</p></blockquote><p>在较为完备的数据库连接池实现中，可根据预先的连接占用超时设定，强制收回被占用连接。从而避免了常规数据库连接操作中可能出现的资源泄漏。一个最小化的数据库连接池实现：</p><h3 id="（2）常用数据库连接池"><a href="#（2）常用数据库连接池" class="headerlink" title="（2）常用数据库连接池"></a>（2）常用数据库连接池</h3><p>常用的数据库连接池包括<code>DBCP</code>,<code>C3P0</code>,<code>Druid</code>。<br><strong>关键配置：</strong></p><blockquote><p>最小连接数:</p></blockquote><p>是数据库一直保持的数据库连接数，所以如果应用程序对数据库连接的使用量不大，将有大量的数据库资源被浪费。</p><blockquote><p>初始化连接数：</p></blockquote><p>连接池启动时创建的初始化数据库连接数量。</p><blockquote><p>最大连接数：</p></blockquote><p>是连接池能申请的最大连接数，如果数据库连接请求超过此数，后面的数据库连接请求被加入到等待队列中。</p><blockquote><p>最大等待时间：</p></blockquote><p>当没有可用连接时，连接池等待连接被归还的最大时间，超过时间则抛出异常，可设置参数为0或者负数使得无限等待(根据不同连接池配置)。</p><h4 id="A-DBCP使用"><a href="#A-DBCP使用" class="headerlink" title="A. DBCP使用"></a>A. <code>DBCP</code>使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDBCP01</span><span class="params">()</span></span>&#123;</span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//1. 构建数据源对象</span></span><br><span class="line">BasicDataSource dataSource = <span class="keyword">new</span> BasicDataSource();</span><br><span class="line"><span class="comment">//连的是什么类型的数据库， 访问的是哪个数据库 ， 用户名， 密码。。</span></span><br><span class="line"><span class="comment">//jdbc:mysql://localhost/bank 主协议：子协议 ://本地/数据库</span></span><br><span class="line">dataSource.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">dataSource.setUrl(<span class="string">"jdbc:mysql://localhost/databasename"</span>);</span><br><span class="line">dataSource.setUsername(<span class="string">"root"</span>);</span><br><span class="line">dataSource.setPassword(<span class="string">"root"</span>);</span><br><span class="line"><span class="comment">//2. 得到连接对象</span></span><br><span class="line">conn = dataSource.getConnection();</span><br><span class="line">String sql = <span class="string">"insert into account values(null , ? , ?)"</span>;</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">"admin"</span>);</span><br><span class="line">ps.setInt(<span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line">ps.executeUpdate();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//3.释放连接对象</span></span><br><span class="line">JDBCUtil.release(conn, ps);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="B-C3P0使用"><a href="#B-C3P0使用" class="headerlink" title="B.C3P0使用"></a>B.<code>C3P0</code>使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//1. 创建datasource</span></span><br><span class="line">ComboPooledDataSource dataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line"><span class="comment">//2. 设置连接数据的信息</span></span><br><span class="line">dataSource.setDriverClass(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">dataSource.setJdbcUrl(<span class="string">"jdbc:mysql://localhost/database_name"</span>);</span><br><span class="line">dataSource.setUser(<span class="string">"root"</span>);</span><br><span class="line">dataSource.setPassword(<span class="string">"root"</span>);</span><br><span class="line"><span class="comment">//3. 得到连接对象</span></span><br><span class="line">conn = dataSource.getConnection();</span><br><span class="line">String sql = <span class="string">"insert into account values(null , ? , ?)"</span>;</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">"admin"</span>);</span><br><span class="line">ps.setInt(<span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">ps.executeUpdate();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">JDBCUtil.release(conn, ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，在使用c3p0连接池的时候，可能遇到无法连接的问题，而此时，可以尝试将配置文件<code>c3p0-config.xml</code>改为如下内容：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用默认的配置读取连接池对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default-config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  连接参数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  主要注意这行内容，需要用 &amp;amp; 代替 &amp; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span>&gt;</span>jdbc:mysql://localhost:3306/stu?serverTimezone=GMT&amp;amp;characterEncoding=UTF-8&amp;amp;useSSL=false<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 连接池参数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"checkoutTimeout"</span>&gt;</span>3000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">default-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">"otherc3p0"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  连接参数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span>&gt;</span>jdbc:mysql://localhost:3306/??<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 连接池参数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span>&gt;</span>8<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"checkoutTimeout"</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="（3）自定义数据库连接池"><a href="#（3）自定义数据库连接池" class="headerlink" title="（3）自定义数据库连接池"></a>（3）<strong>自定义数据库连接池</strong></h3><blockquote><p>使用<strong>栈</strong>来存放数据库连接，每次都从上面取出连接，使用完也放回上面。假如使用的频率特别低会导致栈底部的连接长时间未使用，则可以直接释放以节省资源。</p><p>连接容器中超时连接的释放有两种方式：<br>（1）在往容器中添加或者取出连接的时候释放。<br>（2）单独开一个线程不断轮询所有连接释放超时的连接。一般采用第一种方式。</p><p>栈中连接的使用时间是有序的。所以每次释放的时候，只需要从底部向上开始扫描，遇到超时的连接则进行释放，遇上非超时的连接则停止扫描，如果栈中连接均未超时，则只需要扫描最后一个就可以了。</p></blockquote><hr><p><strong>参考文献</strong><br><a href="https://www.cnblogs.com/JavaSubin/p/5294721.html" target="_blank" rel="noopener">常用数据库连接池 (DBCP、c3p0、Druid) 配置说明</a><br><a href="https://www.cnblogs.com/wym789/p/6374440.html" target="_blank" rel="noopener">数据库连接池的实现及原理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/03/14/AAvGd0.jpg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;本文总结&lt;code&gt;数据库事务&lt;/code&gt;、&lt;code&gt;安全问题与隔离级别&lt;/code&gt;，以及&lt;code&gt;数据库连接池&lt;/code&gt;的相关知识。&lt;br&gt;
    
    </summary>
    
      <category term="Database" scheme="https://yoursite.com/categories/Database/"/>
    
    
      <category term="数据库" scheme="https://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://yoursite.com/tags/MySQL/"/>
    
      <category term="JDBC" scheme="https://yoursite.com/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>算法之美-回溯</title>
    <link href="https://yoursite.com/2019/01/21/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E5%9B%9E%E6%BA%AF/"/>
    <id>https://yoursite.com/2019/01/21/算法之美-回溯/</id>
    <published>2019-01-21T08:01:01.000Z</published>
    <updated>2019-04-02T14:25:12.820Z</updated>
    
    <content type="html"><![CDATA[<p>N皇后的问题应该怎么解决？回溯法来帮忙！<br><img src="https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike72%2C5%2C5%2C72%2C24/sign=b8f564729c22720e6fc3eaa81aa26123/b2de9c82d158ccbfdd83742a1dd8bc3eb13541e7.jpg" alt="此处输入图片的描述"><br><a id="more"></a></p><h2 id="什么是回溯？"><a href="#什么是回溯？" class="headerlink" title="什么是回溯？"></a>什么是回溯？</h2><p><strong>回溯</strong>法思路的简单描述是：把问题的解空间转化成了图或者树的结构表示，然后使用<code>深度优先搜索策略</code>进行遍历，遍历的过程中记录和寻找所有可行解或者最优解。基本思想类同于图的深度优先搜索和二叉树的后序遍历。</p><p>回溯法按深度优先策略搜索问题的解空间树。首先从根节点出发搜索解空间树，当算法搜索至解空间树的某一节点时，先利用剪枝函数判断该节点是否可行（即能得到问题的解）。如果不可行，则跳过对该节点为根的子树的搜索，逐层向其祖先节点回溯；否则，进入该子树，继续按深度优先策略搜索。</p><p>回溯法的基本思想是按照输入数组的顺序，每一层递归处理一个元素，当处理到最后一层的时候，也就是把数组中的所有元素都处理完的时候，把当前结果加入到最后的返回结果中。值得注意的是，每次在递归到下一层之前，我们加入了某个要处理的元素X，在下一层递归返回之后，我们要把之前加入的元素X从当前结果中取出来。如果我们不把元素X取出来，那么在下一次循环中，我们还会加入新的元素Y。那么在这一层递归中就相当于处理了不止一个新元素。</p><h2 id="经典题目实例"><a href="#经典题目实例" class="headerlink" title="经典题目实例"></a>经典题目实例</h2><h3 id="1-矩阵中的路径"><a href="#1-矩阵中的路径" class="headerlink" title="(1) 矩阵中的路径"></a>(1) 矩阵中的路径</h3><p><strong>题目描述</strong>：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。<br><strong>题解：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rows;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cols;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] array, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//异常情况判断</span></span><br><span class="line">    <span class="keyword">if</span>(array.length == <span class="number">0</span> || array.length != rows * cols)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(str.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">char</span>[rows][cols];</span><br><span class="line">    <span class="keyword">boolean</span>[][] mark = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.rows = rows;</span><br><span class="line">    <span class="keyword">this</span>.cols = cols;</span><br><span class="line">    <span class="comment">//把一维数组转化成二维矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>, idx = <span class="number">0</span>; r &lt; rows; r++) &#123;  <span class="comment">//注意括号内的inx的定义方式</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; cols; c++) &#123;</span><br><span class="line">            matrix[r][c] = array[idx++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历数组每个元素，依次与字符串比较</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; rows; r++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; cols; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[r][c] == str[<span class="number">0</span>]) &#123;</span><br><span class="line">                mark[r][c] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(helper(matrix, r, c, str,mark, <span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                mark[r][c] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回溯算法的主体，依次迭代，直到最后的结论；</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">char</span>[][] matrix, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">char</span>[] str,<span class="keyword">boolean</span>[][] mark, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(number == str.length-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    number += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r-<span class="number">1</span> &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[r-<span class="number">1</span>][c] == str[number] &amp;&amp; !mark[r-<span class="number">1</span>][c])&#123;</span><br><span class="line">            mark[r-<span class="number">1</span>][c] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(helper(matrix, r-<span class="number">1</span>, c, str, mark, number))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r+<span class="number">1</span> &lt; rows)&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[r+<span class="number">1</span>][c] == str[number] &amp;&amp; !mark[r+<span class="number">1</span>][c])&#123;</span><br><span class="line">            mark[r+<span class="number">1</span>][c] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(helper(matrix, r+<span class="number">1</span>, c, str, mark, number))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c-<span class="number">1</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[r][c-<span class="number">1</span>] == str[number] &amp;&amp; !mark[r][c-<span class="number">1</span>])&#123;</span><br><span class="line">            mark[r][c-<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(helper(matrix, r, c-<span class="number">1</span>, str, mark, number))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c+<span class="number">1</span> &lt; cols)&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[r][c+<span class="number">1</span>] == str[number] &amp;&amp; !mark[r][c+<span class="number">1</span>])&#123;</span><br><span class="line">            mark[r][c+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(helper(matrix, r, c+<span class="number">1</span>, str, mark, number))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="（2）机器人的运动范围"><a href="#（2）机器人的运动范围" class="headerlink" title="（2）机器人的运动范围"></a>（2）机器人的运动范围</h3><p><strong>题目描述：</strong>地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k 的格子。例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,38)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？<br><strong>题解：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rows;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cols;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[][] mark;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.rows = rows;</span><br><span class="line">    <span class="keyword">this</span>.cols = cols;</span><br><span class="line">    <span class="keyword">this</span>.mark = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">    <span class="keyword">boolean</span>[][] marktmp = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">    <span class="comment">//注意边界问题</span></span><br><span class="line">    <span class="keyword">if</span>(!(threshold &lt;= <span class="number">0</span> || rows &lt;=<span class="number">0</span> || cols &lt;=<span class="number">0</span>))&#123;</span><br><span class="line">        helper(threshold,rows,cols,<span class="number">0</span>,<span class="number">0</span>,marktmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//回溯法核心</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">boolean</span>[][] marktmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(judge(threshold,r,c) &amp;&amp; !marktmp[r][c])&#123;</span><br><span class="line">        System.out.println(Integer.toString(threshold)+<span class="string">" "</span>+Integer.toString(r)+<span class="string">" "</span>+Integer.toString(c));</span><br><span class="line">        marktmp[r][c] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(mark[r][c] == <span class="keyword">false</span>)&#123;</span><br><span class="line">            mark[r][c] = <span class="keyword">true</span>;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r+<span class="number">1</span> &lt; rows)&#123;</span><br><span class="line">            helper(threshold,rows,cols,r+<span class="number">1</span>,c,marktmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c+<span class="number">1</span>&lt;cols)&#123;</span><br><span class="line">            helper(threshold,rows,cols,r,c+<span class="number">1</span>,marktmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r-<span class="number">1</span> &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            helper(threshold,rows,cols,r-<span class="number">1</span>,c,marktmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c-<span class="number">1</span> &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            helper(threshold,rows,cols,r,c-<span class="number">1</span>,marktmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否符合规则</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(row &gt;<span class="number">0</span>)&#123;</span><br><span class="line">        tmp += row%<span class="number">10</span>;</span><br><span class="line">        row/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(col &gt;<span class="number">0</span>)&#123;</span><br><span class="line">        tmp += col%<span class="number">10</span>;</span><br><span class="line">        col/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> threshold &gt;= tmp?<span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="（3）N皇后问题"><a href="#（3）N皇后问题" class="headerlink" title="（3）N皇后问题"></a>（3）N皇后问题</h3><p><strong>题目描述：</strong>要求在一个n×n的棋盘上放置n个皇后，使得它们彼此不受攻击。按照国际象棋的规则，一个皇后可以攻击与之同一行或同一列或同一斜线上的任何棋子。因此，n皇后问题等价于：要求在一个n×n的棋盘上放置n个皇后，使得任意两个皇后不在同一行或同一列或同一斜线上。<br><strong>题解：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> SIZE = <span class="number">0</span>;<span class="comment">//皇后的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//记录摆放的方式数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">"请输入你要解决几个皇后的问题"</span>);</span><br><span class="line">SIZE = input.nextInt();</span><br><span class="line">input.close();</span><br><span class="line"> LinkedList&lt;Location&gt; list = <span class="keyword">new</span> LinkedList&lt;Location&gt;();</span><br><span class="line">     NQueen(list, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">//从棋盘的第0行第0列开始</span></span><br><span class="line">     System.out.println(SIZE + <span class="string">"皇后共有 "</span> + count + <span class="string">"种摆放方式"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Location</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x;<span class="comment">//对应棋盘的行</span></span><br><span class="line"><span class="keyword">int</span> y;<span class="comment">//对应棋盘的列</span></span><br><span class="line"></span><br><span class="line">Location(<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line"><span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"("</span> + x + <span class="string">","</span> + y + <span class="string">")"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 主要函数，用回溯法。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NQueen</span><span class="params">(LinkedList&lt;Location&gt; list, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;   </span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(list.size() == SIZE)&#123;  <span class="comment">//当list元素个数为SIZE时，表示SIZE个皇后都摆放完毕，打印后即可退出函数。</span></span><br><span class="line">           printLocation(list);  <span class="comment">//打印皇后摆放方式</span></span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = x ; i &lt; SIZE ; i++)&#123;</span><br><span class="line">           Location loc = <span class="keyword">new</span> Location(i, y);</span><br><span class="line">           <span class="keyword">if</span>(isLegalLoc(list, loc))&#123;</span><br><span class="line">               list.offer(loc);  <span class="comment">//将第y行的皇后摆放好</span></span><br><span class="line">               NQueen(list, <span class="number">0</span>, y+<span class="number">1</span>);  <span class="comment">//开始摆放y+1行的皇后，同样从第0列开始摆放</span></span><br><span class="line">               list.pollLast();  <span class="comment">//每次摆放完一个皇后后，都要将其撤回，再试探其它的摆法。</span></span><br><span class="line">           &#125;                   </span><br><span class="line">       &#125;           </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断位置为loc的皇后是否合法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLegalLoc</span><span class="params">(LinkedList&lt;Location&gt; list, Location loc)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(Location each : list)&#123;</span><br><span class="line">           <span class="keyword">if</span>(loc.x == each.x || loc.y == each.y)  <span class="comment">//判断是否在同一行或同一列</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (Math.abs(loc.x - each.x) == Math.abs(loc.y - each.y))  <span class="comment">//判断是否在同斜线上</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 打印皇后摆放方式</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLocation</span><span class="params">(LinkedList&lt;Location&gt; list)</span> </span>&#123;</span><br><span class="line">   String[][] show = <span class="keyword">new</span> String[SIZE][SIZE];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;SIZE;i++) &#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;SIZE;j++) &#123;</span><br><span class="line">   show[i][j] = <span class="string">"0"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(Location each : list)&#123;</span><br><span class="line">           System.out.print(each.toString() + <span class="string">"\t"</span>);</span><br><span class="line">           show[each.x][each.y] = <span class="string">"1"</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;SIZE;i++) &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;SIZE;j++) &#123;</span><br><span class="line">       System.out.print(show[i][j] + <span class="string">" "</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println();</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println();</span><br><span class="line"></span><br><span class="line">       count ++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-迷宫问题"><a href="#4-迷宫问题" class="headerlink" title="(4)迷宫问题"></a>(4)迷宫问题</h3><p><strong>题目描述：</strong>以一个M×N的长方阵表示迷宫，0和1分别表示迷宫中的通路和障碍。设计一个程序，对任意设定的迷宫，求出一条从入口到出口的通路，或得出没有通路的结论。<br> （1） 根据二维数组，输出迷宫的图形。<br> （2） 探索迷宫的四个方向：RIGHT为向右，DOWN向下，LEFT向左，UP向上，输出从入口到出口的行走路径。<br><strong>题解：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Position</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Position</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Position</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.col = col;</span><br><span class="line">    <span class="keyword">this</span>.row = row;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"("</span> + row + <span class="string">" ,"</span> + col + <span class="string">")"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> row;</span><br><span class="line">  <span class="keyword">int</span> col;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Maze</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Maze</span><span class="params">()</span></span>&#123;</span><br><span class="line">    maze = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line">    stack = <span class="keyword">new</span> Stack&lt;Position&gt;();</span><br><span class="line">    p = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 构造迷宫</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">"请输入迷宫的行数"</span>);</span><br><span class="line">    row = scanner.nextInt();</span><br><span class="line">    System.out.println(<span class="string">"请输入迷宫的列数"</span>);</span><br><span class="line">    col = scanner.nextInt();</span><br><span class="line">    System.out.println(<span class="string">"请输入"</span> + row + <span class="string">"行"</span> + col + <span class="string">"列的迷宫"</span>);</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j) &#123;</span><br><span class="line">        temp = scanner.nextInt();</span><br><span class="line">        maze[i][j] = temp;</span><br><span class="line">        p[i][j] = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 回溯迷宫，查看是否有出路</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPath</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 给原始迷宫的周围家一圈围墙</span></span><br><span class="line">    <span class="keyword">int</span> temp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[row + <span class="number">2</span>][col + <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row + <span class="number">2</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col + <span class="number">2</span>; ++j) &#123;</span><br><span class="line">        temp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        temp[row + <span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">        temp[i][<span class="number">0</span>] = temp[i][col + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将原始迷宫复制到新的迷宫中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j) &#123;</span><br><span class="line">        temp[i + <span class="number">1</span>][j + <span class="number">1</span>] = maze[i][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从左上角开始按照顺时针开始查询</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    p[i][j] = <span class="keyword">true</span>;</span><br><span class="line">    stack.push(<span class="keyword">new</span> Position(i, j));</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty() &amp;&amp; (!(i == (row) &amp;&amp; (j == col)))) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((temp[i][j + <span class="number">1</span>] == <span class="number">0</span>) &amp;&amp; (p[i][j + <span class="number">1</span>] == <span class="keyword">false</span>)) &#123;</span><br><span class="line">        p[i][j + <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        stack.push(<span class="keyword">new</span> Position(i, j + <span class="number">1</span>));</span><br><span class="line">        j++;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((temp[i + <span class="number">1</span>][j] == <span class="number">0</span>) &amp;&amp; (p[i + <span class="number">1</span>][j] == <span class="keyword">false</span>)) &#123;</span><br><span class="line">        p[i + <span class="number">1</span>][j] = <span class="keyword">true</span>;</span><br><span class="line">        stack.push(<span class="keyword">new</span> Position(i + <span class="number">1</span>, j));</span><br><span class="line">        i++;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((temp[i][j - <span class="number">1</span>] == <span class="number">0</span>) &amp;&amp; (p[i][j - <span class="number">1</span>] == <span class="keyword">false</span>)) &#123;</span><br><span class="line">        p[i][j - <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        stack.push(<span class="keyword">new</span> Position(i, j - <span class="number">1</span>));</span><br><span class="line">        j--;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((temp[i - <span class="number">1</span>][j] == <span class="number">0</span>) &amp;&amp; (p[i - <span class="number">1</span>][j] == <span class="keyword">false</span>)) &#123;</span><br><span class="line">        p[i - <span class="number">1</span>][j] = <span class="keyword">true</span>;</span><br><span class="line">        stack.push(<span class="keyword">new</span> Position(i - <span class="number">1</span>, j));</span><br><span class="line">        i--;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(stack.empty())&#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i = stack.peek().row;</span><br><span class="line">        j = stack.peek().col;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Position&gt; newPos = <span class="keyword">new</span> Stack&lt;Position&gt;();</span><br><span class="line">    <span class="keyword">if</span> (stack.empty()) &#123;</span><br><span class="line">      System.out.println(<span class="string">"没有路径"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"有路径"</span>);</span><br><span class="line">      System.out.println(<span class="string">"路径如下："</span>);</span><br><span class="line">      <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        Position pos = <span class="keyword">new</span> Position();</span><br><span class="line">        pos = stack.pop();</span><br><span class="line">        newPos.push(pos);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 图形化输出路径</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line"></span><br><span class="line">    String resault[][]=<span class="keyword">new</span> String[row+<span class="number">1</span>][col+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;row;++k)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;col;++t)&#123;</span><br><span class="line">        resault[k][t]=(maze[k][t])+<span class="string">""</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!newPos.empty()) &#123;</span><br><span class="line">      Position p1=newPos.pop();</span><br><span class="line">      resault[p1.row-<span class="number">1</span>][p1.col-<span class="number">1</span>]=<span class="string">"#"</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;row;++k)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;col;++t)&#123;</span><br><span class="line">        System.out.print(resault[k][t]+<span class="string">"\t"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> maze[][];</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> row = <span class="number">9</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> col = <span class="number">8</span>;</span><br><span class="line">  Stack&lt;Position&gt; stack;</span><br><span class="line">  <span class="keyword">boolean</span> p[][] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hello</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Maze demo = <span class="keyword">new</span> Maze();</span><br><span class="line">    demo.init();</span><br><span class="line">    demo.findPath();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;N皇后的问题应该怎么解决？回溯法来帮忙！&lt;br&gt;&lt;img src=&quot;https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike72%2C5%2C5%2C72%2C24/sign=b8f564729c22720e6fc3eaa81aa26123/b2de9c82d158ccbfdd83742a1dd8bc3eb13541e7.jpg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="https://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="algorithms" scheme="https://yoursite.com/tags/algorithms/"/>
    
      <category term="Java算法" scheme="https://yoursite.com/tags/Java%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法之美-十大排序算法</title>
    <link href="https://yoursite.com/2019/01/21/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://yoursite.com/2019/01/21/算法之美-十大排序算法/</id>
    <published>2019-01-21T02:01:01.000Z</published>
    <updated>2019-04-02T08:46:29.138Z</updated>
    
    <content type="html"><![CDATA[<p>各种排序算法的<code>Java</code>实现。<br><a id="more"></a></p><h2 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a>排序算法分类</h2><h3 id="比较类"><a href="#比较类" class="headerlink" title="比较类"></a>比较类</h3><p>通过比较来决定元素间的相对次序，由于其时间复杂度不能突破<code>O(nlogn)</code>，因此也称为非线性时间比较类排序。</p><h3 id="非比较类"><a href="#非比较类" class="headerlink" title="非比较类"></a>非比较类</h3><p>不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</p><h3 id="算法的时间复杂度比较"><a href="#算法的时间复杂度比较" class="headerlink" title="算法的时间复杂度比较"></a>算法的时间复杂度比较</h3><p><img src="https://s2.ax1x.com/2019/03/12/AiBfNd.png" alt="Picture"></p><blockquote><p>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</p><p>不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</p></blockquote><h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><p>重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = testList.length-<span class="number">1</span>; i &gt;= <span class="number">1</span> ;i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(testList[j]&gt;testList[j+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = testList[j];</span><br><span class="line">            testList[j] = testList[j+<span class="number">1</span>];</span><br><span class="line">            testList[j+<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><p><code>选择排序(Selection-sort)</code>是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最小值选择排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] minSort(<span class="keyword">int</span>[] list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(list.length == <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = list[i], indexMin = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; list.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(list[j] &lt; min)&#123;</span><br><span class="line">                min = list[j];</span><br><span class="line">                indexMin = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list[i] &gt; min)&#123;</span><br><span class="line">            list[indexMin] = list[i];</span><br><span class="line">            list[i] = min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大值选择排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] maxSort(<span class="keyword">int</span>[] list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(list.length == <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = list.length- <span class="number">1</span>; i &gt; <span class="number">0</span> ; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i -<span class="number">1</span>  ; j &gt;= <span class="number">0</span> ; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(list[j] &gt; list[maxIndex])&#123;</span><br><span class="line">                maxIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list[maxIndex] &gt; list[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = list[i];</span><br><span class="line">            list[i] = list[maxIndex];</span><br><span class="line">            list[maxIndex] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h2><p><code>插入排序（Insertion-Sort）</code>是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h3 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h3><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(list.length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; list.length ; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = list[i];</span><br><span class="line">        <span class="keyword">int</span> index = i-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(index&gt;=<span class="number">0</span> &amp;&amp; list[index]&gt;temp)&#123;</span><br><span class="line">            list[index+<span class="number">1</span>] = list[index];</span><br><span class="line">            index --;</span><br><span class="line">        &#125;</span><br><span class="line">        list[index+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h2><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。<code>希尔排序</code>又叫缩小增量排序。</p><h3 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h3><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] shellSort(<span class="keyword">int</span>[] testList) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = testList.length/<span class="number">2</span>; gap &gt;= <span class="number">1</span>; gap/=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//对子序列插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; testList.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">int</span> current = testList[i];</span><br><span class="line">            <span class="keyword">while</span>(j-gap&gt;=<span class="number">0</span> &amp;&amp; testList[j-gap]&gt;current)&#123;</span><br><span class="line">                testList[j] = testList[j-gap];</span><br><span class="line">                j-=gap;</span><br><span class="line">            &#125;</span><br><span class="line">            testList[j] = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> testList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h2><p><code>归并排序</code>是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p><h3 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h3><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] testList,<span class="keyword">int</span> left,<span class="keyword">int</span> right) &#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">        mergeSort(testList,left,(left+right)/<span class="number">2</span>);</span><br><span class="line">        mergeSort(testList,(left+right)/<span class="number">2</span>+<span class="number">1</span>,right);</span><br><span class="line">        merge(testList,left,(left+right)/<span class="number">2</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> testList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] testList, <span class="keyword">int</span> left, <span class="keyword">int</span> middle, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> j = middle+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=middle&amp;&amp;j&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">if</span> (testList[i] &lt; testList[j]) &#123;</span><br><span class="line">            temp[k++] = testList[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = testList[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=middle)&#123;</span><br><span class="line">        temp[k++] = testList[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=right)&#123;</span><br><span class="line">        temp[k++] = testList[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k2 = <span class="number">0</span>; k2 &lt; temp.length; k2++) &#123;</span><br><span class="line">        testList[k2 + left] = temp[k2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title=" 快速排序（Quick Sort）"></a><strong> 快速排序（Quick Sort）</strong></h2><p><code>快速排序</code>的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h3 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h3><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（<code>pivot</code>）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（<code>partition</code>）操作；</li><li>递归地（<code>recursive</code>）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分治的方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] testList, <span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">    <span class="keyword">if</span> (testList == <span class="keyword">null</span> || start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span> testList;</span><br><span class="line">    <span class="keyword">int</span> i = start, j = end;</span><br><span class="line">    <span class="keyword">int</span> pivotKey = testList[start];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; testList[j] &gt;= pivotKey)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)&#123;</span><br><span class="line">            testList[i++] = testList[j];</span><br><span class="line">            System.out.println(<span class="string">"i++"</span>+Arrays.toString(testList));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; testList[i] &lt;= pivotKey)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)&#123;</span><br><span class="line">            testList[j--] = testList[i];</span><br><span class="line">            System.out.println(<span class="string">"j--"</span>+Arrays.toString(testList));&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    testList[i] = pivotKey;</span><br><span class="line">    quickSort(testList, start, i - <span class="number">1</span>);</span><br><span class="line">    quickSort(testList, i + <span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> testList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//经典的解法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort2(<span class="keyword">int</span>[] testList, <span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">    <span class="keyword">if</span> (testList == <span class="keyword">null</span> || start &lt; <span class="number">0</span> || end &gt; testList.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid Parameters"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (start == end) <span class="keyword">return</span> testList;</span><br><span class="line">    <span class="keyword">int</span> index = partition(testList, start, end);</span><br><span class="line">    <span class="keyword">if</span> (index &gt; start) &#123;</span><br><span class="line">        quickSort2(testList, start, index - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; end) &#123;</span><br><span class="line">        quickSort2(testList, index + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> testList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] testList, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = start + (<span class="keyword">int</span>)(Math.random() * (end - start + <span class="number">1</span>));</span><br><span class="line">    swap(testList, index, end);</span><br><span class="line">    <span class="keyword">int</span> small = start - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (index = start; index &lt; end; index++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (testList[index] &lt; testList[end]) &#123;</span><br><span class="line">            small++;</span><br><span class="line">            <span class="keyword">if</span> (small != index) &#123;</span><br><span class="line">                swap(testList, index, small);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(testList, small + <span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> small + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] testList, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = testList[i];</span><br><span class="line">    testList[i] = testList[j];</span><br><span class="line">    testList[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a><strong>堆排序（Heap Sort）</strong></h2><p><code>堆排序（Heapsort）</code>是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h3 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h3><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul><h3 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] list, <span class="keyword">int</span> currentindex, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (currentindex &lt; length) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span> * currentindex + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span> * currentindex + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> max = currentindex;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list[max] &lt; list[left]) &#123;</span><br><span class="line">                max = left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list[max] &lt; list[right]) &#123;</span><br><span class="line">                max = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最大的不是根元素位置，那么就交换</span></span><br><span class="line">        <span class="keyword">if</span> (max != currentindex) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = list[max];</span><br><span class="line">            list[max] = list[currentindex];</span><br><span class="line">            list[currentindex] = temp;</span><br><span class="line">            heapify(list, max, length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] list,<span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = list[index2];</span><br><span class="line">    list[index2]= list[index1];</span><br><span class="line">    list[index1] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildheap</span><span class="params">(<span class="keyword">int</span>[] list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = list.length-<span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">        heapify(list,i,list.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapsort</span><span class="params">(<span class="keyword">int</span>[] list)</span></span>&#123;</span><br><span class="line">    buildheap(list);</span><br><span class="line">    System.out.println(Arrays.toString(list));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = list.length-<span class="number">1</span>; i &gt;= <span class="number">1</span> ; i--) &#123;</span><br><span class="line">        swap(list,i,<span class="number">0</span>);</span><br><span class="line">        heapify(list,<span class="number">0</span>,i-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计数排序（Counting-Sort）"><a href="#计数排序（Counting-Sort）" class="headerlink" title="计数排序（Counting Sort）"></a>计数排序（Counting Sort）</h2><p><code>计数排序</code>不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><h3 id="算法描述-7"><a href="#算法描述-7" class="headerlink" title="算法描述"></a>算法描述</h3><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><h3 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[list.length];</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[list.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; list.length - <span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; list.length;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(list[i] &lt; list[j])</span><br><span class="line">                count[j]++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                count[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; list.length;i++)</span><br><span class="line">        temp[count[i]] = list[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; list.length;i++)</span><br><span class="line">        list[i] = temp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="桶排序（Bucket-Sort）"><a href="#桶排序（Bucket-Sort）" class="headerlink" title="桶排序（Bucket Sort）"></a>桶排序（Bucket Sort）</h2><p><code>桶排序</code>是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p><h3 id="算法描述-8"><a href="#算法描述-8" class="headerlink" title="算法描述"></a>算法描述</h3><ul><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。</li></ul><h3 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span> [] arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> min = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= arr.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i] &lt; min)&#123;</span><br><span class="line">min = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(arr[i] &gt; max)&#123;</span><br><span class="line">max = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> bucketCount = max - min + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[bucketCount];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= arr.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">bucket[arr[i] - min]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; bucketCount; i++)&#123;</span><br><span class="line">bucket[i] = bucket[i] + bucket[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> [] copy = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">System.arraycopy(arr, <span class="number">0</span>, copy, <span class="number">0</span>, arr.length);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">arr[--bucket[copy[i] - min]] = copy[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h2><p><code>基数排序</code>是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><h3 id="算法描述-9"><a href="#算法描述-9" class="headerlink" title="算法描述"></a>算法描述</h3><ul><li>取得数组中的最大数，并取得位数；</li><li>array为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ul><h3 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> length=array.length;</span><br><span class="line">    <span class="keyword">int</span>[][] bucket=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][length];</span><br><span class="line">    <span class="keyword">int</span>[] order=<span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    <span class="keyword">while</span>(n&lt;d)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:array)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> digit=(num/n)%<span class="number">10</span>;</span><br><span class="line">            bucket[digit][order[digit]]=num;</span><br><span class="line">            order[digit]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(order[i]!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;order[i];j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    array[k]=bucket[i][j];</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            order[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n*=<span class="number">10</span>;</span><br><span class="line">        k=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考链接：</strong><br><a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">十大经典排序算法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;各种排序算法的&lt;code&gt;Java&lt;/code&gt;实现。&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="https://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="algorithms" scheme="https://yoursite.com/tags/algorithms/"/>
    
      <category term="Java算法" scheme="https://yoursite.com/tags/Java%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java的艺术-Java容器(2)之并发修改异常</title>
    <link href="https://yoursite.com/2019/01/06/Java%E7%9A%84%E8%89%BA%E6%9C%AF-Java%E5%AE%B9%E5%99%A8(2)%E4%B9%8B%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E5%BC%82%E5%B8%B8/"/>
    <id>https://yoursite.com/2019/01/06/Java的艺术-Java容器(2)之并发修改异常/</id>
    <published>2019-01-06T12:18:20.000Z</published>
    <updated>2019-03-21T16:05:00.301Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551345094255&amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;imgtype=0&amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png" alt="此处输入图片的描述"><br>ConcurrentModificationException（并发修改异常）为什么会出现？怎么解决呢？<br><a id="more"></a></p><h2 id="什么时候出现“并发修改异常”？"><a href="#什么时候出现“并发修改异常”？" class="headerlink" title="什么时候出现“并发修改异常”？"></a><strong>什么时候出现“并发修改异常”？</strong></h2><p>看下面这两段代码</p><blockquote><p>(1)增强for</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">res.add(<span class="string">"a"</span>);</span><br><span class="line">res.add(<span class="string">"b"</span>);</span><br><span class="line"><span class="keyword">for</span> (String s:res)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="string">"a"</span>)&#123;</span><br><span class="line">        res.add(<span class="string">"c"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>(2)迭代器</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">res.add(<span class="string">"a"</span>);</span><br><span class="line">res.add(<span class="string">"b"</span>);</span><br><span class="line">Iterator it = res.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    String s =(String) it.next();</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="string">"a"</span>)&#123;</span><br><span class="line">        res.add(<span class="string">"c"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码都会出现下面的异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.util.ConcurrentModificationException</span><br><span class="line">at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class="number">909</span>)</span><br><span class="line">at java.util.ArrayList$Itr.next(ArrayList.java:<span class="number">859</span>)</span><br><span class="line">at offer.Solution38.Permutation(Solution38.java:<span class="number">25</span>)</span><br><span class="line">at offer.Solution38.main(Solution38.java:<span class="number">35</span>)</span><br></pre></td></tr></table></figure><h2 id="为什么会出现“并发修改异常”？"><a href="#为什么会出现“并发修改异常”？" class="headerlink" title="为什么会出现“并发修改异常”？"></a><strong>为什么会出现“并发修改异常”？</strong></h2><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a><font color="red"><strong>源码分析</strong></font></h3><p>首先我们看ArrayList类的源码，其iterator()方法为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>返回一个新建的<strong>Itr</strong>对象，源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Itr() &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>是个没有内容内部类，我们只能看看ArrayList的父类AbstractList有没有对应的内容：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Index of element to be returned by subsequent call to next.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> cursor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Index of element returned by most recent call to next or</span></span><br><span class="line"><span class="comment">         * previous.  Reset to -1 if this element is deleted by a call</span></span><br><span class="line"><span class="comment">         * to remove.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The modCount value that the iterator believes that the backing</span></span><br><span class="line"><span class="comment">         * List should have.  If this expectation is violated, the iterator</span></span><br><span class="line"><span class="comment">         * has detected concurrent modification.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = cursor;</span><br><span class="line">                E next = get(i);</span><br><span class="line">                lastRet = i;</span><br><span class="line">                cursor = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                AbstractList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">                <span class="keyword">if</span> (lastRet &lt; cursor)</span><br><span class="line">                    cursor--;</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>是一个实现了<strong>Iterator</strong>接口的私有内部类。</p><p>分析它的<strong>hasNext()</strong>方法，会发现一个成员变量<strong>cursor</strong>。分析发现，这个变量表示下一个要访问元素的索引，当索引大于集合的<strong>size()</strong>后，则<strong>hasNext()=false</strong>。并且，<strong>next()</strong>方法返回的元素调用了<strong>get(cursor)</strong>,而get()方法在ArrayList中为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<strong>elementData</strong>就是用来存储ArrayList的Object数组。</p><blockquote><p>什么时候会出现ConcurrentModificationException呢？</p></blockquote><p>我们发现了Itr类的两个方法<strong>remove()和checkForComodification()</strong>会抛出这个异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            AbstractList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; cursor)</span><br><span class="line">                cursor--;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以及<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final void checkForComodification() &#123;</span><br><span class="line">            if (modCount != expectedModCount)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>我们观察上面抛出异常的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">res.add(&quot;a&quot;);</span><br><span class="line">res.add(&quot;b&quot;);</span><br><span class="line">Iterator it = res.iterator();</span><br><span class="line">while(it.hasNext())&#123;</span><br><span class="line">    String s =(String) it.next();</span><br><span class="line">    if(s == &quot;a&quot;)&#123;</span><br><span class="line">        res.add(&quot;c&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先在next()方法中会调用<strong>checkForComodification()</strong>方法，然后根据cursor的值获取到元素，接着将cursor的值赋给lastRet，并对cursor的值进行加1操作。初始时，cursor为0，lastRet为-1，那么调用一次之后，cursor的值为1，lastRet的值为0。注意此时，<strong>modCount为0，expectedModCount也为0</strong>。</p><p>随后，代码调用了res.add(“c”)。</p><p>查看源码，ArrayList的add()方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>再查看<strong>ensureCapacityInternal()</strong>的源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们发现了关键一行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modCount++;</span><br></pre></td></tr></table></figure><p>此时，<strong>modCount为1，expectedModCount为0</strong>。</p><p>在调用next()方法时，执行<strong>checkForComodification()</strong>显然就会抛出<strong>ConcurrentModificationException()</strong>！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>终于解决了这个疑惑！</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><blockquote><p>分析源码，在多线程程序中，如果有多个线程都在使用一个集合对象X，线程继续迭代，当A线程调用迭代器的next()方法时，发现modCount不等于expectedModCount，因此就抛出了ConcurrentModificationException异常。这可能就是它为什么叫并发修改异常的原因。<strong>从这一点也能说明ArrayList不是线程安全的。</strong></p><p>简单来说，调用list.remove(),list.add()方法导致modCount和expectedModCount的值不一致。使用for-each进行迭代实际上也会出现这种问题。</p></blockquote><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a><strong>解决办法</strong></h2><p>一般有2种解决办法：</p><blockquote><p>(1)不使用迭代器遍历集合,就可以在遍历的时候使用集合的方法进行增加或删除</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">res.add(<span class="string">"a"</span>);</span><br><span class="line">res.add(<span class="string">"b"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(res.get(i) == <span class="string">"a"</span>)</span><br><span class="line">        res.add(<span class="string">"c"</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><blockquote><p>(2)依然使用迭代器遍历,那么就需要使用Iterator的子接口ListIterator来实现向集合中添加</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ListIterator lit = res.listIterator();</span><br><span class="line"><span class="keyword">while</span>(lit.hasNext()) &#123;</span><br><span class="line">String s = (String)lit.next();</span><br><span class="line"><span class="keyword">if</span>(s.equals(<span class="string">"a"</span>)) &#123;</span><br><span class="line">lit.add(<span class="string">"c"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他解决同步问题的办法：</p><blockquote><p>(3)在使用iterator迭代的时候使用synchronized或者Lock进行同步；</p><p>(4)使用并发容器CopyOnWriteArrayList代替ArrayList和Vector。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1551345094255&amp;amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;amp;imgtype=0&amp;amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;ConcurrentModificationException（并发修改异常）为什么会出现？怎么解决呢？&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Java容器" scheme="https://yoursite.com/tags/Java%E5%AE%B9%E5%99%A8/"/>
    
      <category term="Java源码" scheme="https://yoursite.com/tags/Java%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Java的艺术-Java容器(1)之容器基础</title>
    <link href="https://yoursite.com/2019/01/05/Java%E7%9A%84%E8%89%BA%E6%9C%AF-Java%E5%AE%B9%E5%99%A8(1)%E4%B9%8B%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80/"/>
    <id>https://yoursite.com/2019/01/05/Java的艺术-Java容器(1)之容器基础/</id>
    <published>2019-01-05T11:48:20.000Z</published>
    <updated>2019-04-03T08:12:29.643Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551345094255&amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;imgtype=0&amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png" alt="此处输入图片的描述"><br>简要介绍JAVA容器。<br><a id="more"></a></p><h2 id="Java容器是什么？"><a href="#Java容器是什么？" class="headerlink" title="Java容器是什么？"></a><font color="red"><strong>Java容器是什么？</strong></font></h2><blockquote><p><strong>容器</strong>，顾名思义，就是盛东西的地方。我们的程序中经常要管理大量的对象，比如在学校的信息管理系统里，每一个学生的相关信息，都可以抽象成一个对象；再比如在web server的场景下，一个客户端可以抽象成一个对象。这些情况下，都会产生很多同类型的对象，这时候，我们就会把同一个类型的对象放到同一个容器中进行集中管理。</p><p><strong>Java的容器</strong>是前人为我们设计好的一套存储对象和数据的一套轮子，<br>通过使用Java中写好的容器API我们可以很方便的存储、操作我们的数据。</p><p><strong>容器的作用：</strong><br>Java容器类库是用来保存对象的，他有两种不同的概念：（1）<strong>Collection</strong>，独立元素的序列，这些元素都服从一条或多条规则。List、Set以及Queue都是Collection的一种，List必须按照顺序保存元素，而Set不能有重复元素，Queue需要按照排队规则来确定对象的顺序。（2）<strong>Map</strong>，Map是键值对类型，允许用户通过键来查找对象。Hash表允许我们使用另一个对象来查找某个对象。</p><p>为什么需要容器呢？<br><strong>《thinking in java》</strong>书中说：“如果一个程序只包含固定数量的且生命周期都已知的对象，那么这是一个非常简单的数据。”但是事实上，我们平时接触的程序都不是如此简单的，很多程序都是在运行时才知道需要创建什么对象、创建多少对象，因此很可能我们需要在任意时刻任意位置创建任意数量的对象。因此，不能依靠创建命名的引用持有每一个对象，因为不确定性，我们必须要动态的创建对象，保存对象（其实是对象的引用）。</p></blockquote><h2 id="Java常见容器"><a href="#Java常见容器" class="headerlink" title="Java常见容器"></a><font color="red"><strong>Java常见容器</strong></font></h2><h3 id="Java完整容器类结构"><a href="#Java完整容器类结构" class="headerlink" title="Java完整容器类结构"></a>Java完整容器类结构</h3><p><img src="https://s2.ax1x.com/2019/03/07/kxN22n.md.jpg" alt="此处输入图片的描述"></p><h3 id="详细结构及概述"><a href="#详细结构及概述" class="headerlink" title="详细结构及概述"></a><strong>详细结构及概述</strong></h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a><strong>结构</strong></h4><p><strong>Collection</strong>接口<br>　├<strong>List</strong>接口<br>　　│├LinkedList 双向链表，顺序访问，快速增删，栈、队列、双向队列<br>　　│├ArrayList 顺序结构动态数组实现，随机访问<br>　　│└Vector 向量<br>　　　│└Stack 栈<br>　├<strong>Set</strong>接口<br>　　│├TreeSet 红黑树实现，有序，查找O(logN)<br>　　│├HashSet 哈希表实现，无序，查找O(1)<br>　　　│└LinkedHashSet<br>　├<strong>Queue</strong>接口<br>　　│├PriorityQueue 堆实现，可实现优先队列<br>　　│└LinkedList 双向链表，顺序访问，快速增删，栈、队列、双向队列<br><strong>Map</strong>接口<br>　├<strong>HashMap</strong> 哈希表实现，线程不安全<br>　　├Hashtable 线程安全，现为ConcurrentHashMap替换，分段锁<br>　　├LinkedHashMap 双向链表实现<br>　├<strong>TreeMap</strong> 红黑树实现　<br>　├WeakHashMap<br>　└IdentityHashMap</p><h4 id="一句话概括常用不同容器类"><a href="#一句话概括常用不同容器类" class="headerlink" title="一句话概括常用不同容器类"></a><strong>一句话概括常用不同容器类</strong></h4><blockquote><p><strong>1.Set</strong><br>1.1 <strong>TreeSet</strong>：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。<br>1.2 <strong>HashSet</strong>：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。<br>1.3 <strong>LinkedHashSet</strong>：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</p><p><strong>2.List</strong><br>2.1 <strong>ArrayList</strong>：基于动态数组实现，支持随机访问。<br>2.2 <strong>Vector</strong>：和 ArrayList 类似，但它是线程安全的。<br>2.3 <strong>LinkedList</strong>：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间<br>插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</p><p><strong>3.Queue</strong><br>3.1 <strong>LinkedList</strong>：可以用它来实现双向队列。<br>3.2 <strong>PriorityQueue</strong>：基于堆结构实现，可以用它来实现优先队列。</p><p><strong>4.Map</strong><br>4.1 <strong>TreeMap</strong>：基于红黑树实现。<br>4.2 <strong>HashMap</strong>：基于哈希表实现。<br>4.3 <strong>HashTable</strong>：和 HashMap类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用ConcurrentHashMap 来支持线程安全，并且ConcurrentHashMap 的效率会更高，因为ConcurrentHashMap引入了分段锁。<br>4.4 <strong>LinkedHashMap</strong>：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（ LRU） 顺序。</p></blockquote><hr><blockquote><p><strong>接下来，详细比较不同容器的区别和联系！</strong></p></blockquote><h2 id="顶层接口-Collections接口"><a href="#顶层接口-Collections接口" class="headerlink" title="顶层接口-Collections接口"></a><font color="red"><strong>顶层接口-Collections接口</strong></font></h2><p>Collection是序列容器的顶级接口，这个interface定义了序列容器必须实现的所有成员方法。</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a><strong>常用方法</strong></h3><p>包括：容器容量，判断是否为空，检查容器元素，迭代器，增删等操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line">     <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">     Object[] toArray();</span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="List接口及常用实现类"><a href="#List接口及常用实现类" class="headerlink" title="List接口及常用实现类"></a><font color="red"><strong>List接口及常用实现类</strong></font></h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>实现List接口的常用类有LinkedList，ArrayList，Vector和Stack。</p><p>LinkedList、ArrayList都实现了List接口，都是不同步的，线程不安全，元素是有序的、可重复。</p><p>一般情况下使用LinkedList、ArrayList这两个就可以了，因为非同步，所以<strong>效率比较高</strong>。</p><p>ArrayList的随机访问效率较好，但是插入、删除元素较慢；LinkedList提供了优化的顺序访问，随机访问逊色于ArrayList，但插入、删除的代价较低。</p><p>总之，如果涉及到<strong>堆栈，队列</strong>等操作，应该考虑用List，对于需要<strong>快速插入，删除元素</strong>，应该使用LinkedList，如果需要<strong>快速随机</strong>访问元素，应该使用ArrayList。</p></blockquote><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a><strong>LinkedList</strong></h3><blockquote><p>基于双向链表的数据结构，允许null元素，增加、删除、修改元素方面效率比ArrayList高。</p><p>LinkedList提供额外的get，remove，insert方法在 LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。</p><p><strong>注意:LinkedList没有同步方法。</strong>如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：List list = Collections.synchronizedList(new LinkedList(…));</p></blockquote><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a><strong>ArrayList</strong></h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote><p>基于顺序结构的动态数组的数据结构，不同步，线程不安全，查询（get，set）效率高。</p><p>size()，isEmpty()，get()，set()方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。</p></blockquote><h4 id="Array和ArrayList的区别及各自适用的场景："><a href="#Array和ArrayList的区别及各自适用的场景：" class="headerlink" title="Array和ArrayList的区别及各自适用的场景："></a><strong>Array和ArrayList的区别及各自适用的场景：</strong></h4><blockquote><p>Array是数组，ArrayList是Array的加强版。</p><p>（1）array可以保存基本类型和对象类型，arrayList只能保存对象类型</p><p>（2）array数组的大小是固定的不能更改，而ArrayList的大小可以改变</p><p>（3）Array数组在存放的时候一定是同种类型的元素。ArrayList就不一定了，因为ArrayList可以存储Object。</p><p>（4）ArrayList有更加丰富的方法如addAll（）、removeAll()、iterator()</p><p><strong>适用场景：</strong><br>如果想要保存一些在整个程序运行期间都会存在而且不变的数据，我们可以将它们放进一个全局数组里，但是如果我们单纯只是想要以数组的形式保存数据，而不对数据进行增加等操作，只是方便我们进行查找的话，那么，我们就选择ArrayList。</p><p>如果我们需要对元素进行频繁的移动或删除，或者是处理的是超大量的数据，那么，使用ArrayList就真的不是一个好的选择，因为它的效率很低，使用数组进行这样的动作就很麻烦，那么，我们可以考虑选择LinkedList。</p></blockquote><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a><strong>Vector</strong></h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><blockquote><p>Vector类似ArrayList，但是Vector是<strong>线程同步</strong>的。由Vector创建的Iterator，虽然和ArrayList创建的 Iterator是同一接口，但是，因为Vector是同步的，当一个Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出ConcurrentModificationException，因此必须捕获该异常。</p></blockquote><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a><strong>Stack</strong></h3><blockquote><p>Stack继承自Vector，实现一个<strong>后进先出的堆栈</strong>。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop方法，还有 peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。</p></blockquote><hr><h2 id="Set接口及常用实现类"><a href="#Set接口及常用实现类" class="headerlink" title="Set接口及常用实现类"></a><font color="red"><strong>Set接口及常用实现类</strong></font></h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><blockquote><p>Set容器类主要有<strong>HashSet</strong>和<strong>TreeSet</strong>等。<br>元素不重复。</p></blockquote><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a><strong>HashSet</strong></h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><blockquote><p>允许包含值为null的元素，但最多只能有一个null元素。</p><p>基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</p></blockquote><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a><strong>TreeSet</strong></h3><blockquote><p>TreeSet基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</p></blockquote><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a><strong>LinkedHashSet</strong></h3><blockquote><p>LinkedHashSet的实现借助LinkedHashMap使用适配器模式实现的。具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</p></blockquote><hr><h2 id="Map接口及常用实现类"><a href="#Map接口及常用实现类" class="headerlink" title="Map接口及常用实现类"></a><font color="red"><strong>Map接口及常用实现类</strong></font></h2><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><blockquote><p>Map没有继承Collection接口，Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个value。Map接口提供3种集合的视图，Map的内容可以被当作一组key集合，一组value集合，或者一组key-value映射。</p><p>主要方法：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span><span class="comment">//比较对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span><span class="comment">//删除一个对象</span></span></span><br><span class="line"><span class="function"><span class="title">put</span><span class="params">(Object key,Object value)</span><span class="comment">//添加key和value</span></span></span><br></pre></td></tr></table></figure><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a><strong>TreeMap</strong></h3><h4 id="TreeMap-和-TreeSet"><a href="#TreeMap-和-TreeSet" class="headerlink" title="TreeMap 和 TreeSet"></a><strong>TreeMap 和 TreeSet</strong></h4><p>TreeSet是借助TreeMap实现的的适配器模式的体现。TreeMap懂了TreeSet也了解了，TreeMap实现了SortedMap接口，会根据key的大小对Map中的元素进行排序。key的大小判断在没有传入比较器Comparator的情况下通过自身的自然顺序比较。TreeMap底层通过红黑树实现</p><p><strong>红黑树</strong>是一颗近似平衡的二叉查找树，任何一个节点的左右子树高度差不会超过二者中较低的那个的一倍，TreeMap的每个节点即为一个键值对，红黑树的特性如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(1)每个节点要么是黑色，要么是红色</span><br><span class="line">(2)根节点必须为黑色</span><br><span class="line">(3)红色节点不能连续，即红色节点的孩子和父亲只能是黑色</span><br><span class="line">(4)任何节点到树的末端的任何路径包含的黑色节点个数相同</span><br><span class="line">(5)每次对红黑树操作后都要使其满足上述条件，调整红黑树的策略主要是：</span><br><span class="line"> - 改变节点颜色；</span><br><span class="line"> - 改变树的结构（左旋操作、右旋操作）</span><br></pre></td></tr></table></figure></p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a><strong>HashMap</strong></h3><h4 id="HashTable和HashMap"><a href="#HashTable和HashMap" class="headerlink" title="HashTable和HashMap"></a>HashTable和HashMap</h4><blockquote><p>第一、继承不同。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span> <span class="keyword">extends</span> <span class="title">Dictionary</span> <span class="keyword">implements</span> <span class="title">Map</span></span></span><br><span class="line"><span class="class">　　<span class="title">public</span> <span class="title">class</span> <span class="title">HashMap</span>  <span class="keyword">extends</span> <span class="title">AbstractMap</span> <span class="keyword">implements</span> <span class="title">Map</span></span></span><br></pre></td></tr></table></figure><blockquote><p>第二、Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。</p><p>第三、Hashtable中，key和value都不允许出现null值。在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。</p><p>第四、两个遍历方式的内部实现上不同。Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。</p><p>第五、哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。</p></blockquote><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a><strong>LinkedHashMap</strong></h3><p>LinkedHashMap实现了Map接口，即允许放入key为null的元素，也允许插入value为null的元素。从名字上可以看出该容器是linked list和HashMap的混合体，也就是说它同时满足HashMap和linked list的某些特性。可将LinkedHashMap看作采用LinkedList增强的HashMap。</p><h4 id="LinkedHashMap-和-LinkedHashSet"><a href="#LinkedHashMap-和-LinkedHashSet" class="headerlink" title="LinkedHashMap 和 LinkedHashSet:"></a><strong>LinkedHashMap 和 LinkedHashSet:</strong></h4><blockquote><p>LinkedHashSet和LinkedHashMap在Java里也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说LinkedHashSet里面有一个LinkedHashMap（适配器模式）。</p><p>LinkedHashMap是HashMap的子类，二者唯一的区别是LinkedHashMap在HashMap的基础上，采用双向链表（doubly-linkedlist）的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同。上图给出了LinkedHashMap的结构图，主体部分跟HashMap完全一样，多了header指向双向链表的头部（是一个哑元），该双向链表的迭代顺序就是entry的插入顺序。</p><p>LinkedHashMap在遍历的时候不同于HashMap需要先遍历整个table，LinkedHashMap只需要遍历header指向的双向链表即可，因此LinkedHashMap的迭代时间只和entry数量相关。其他的包括初始容量、负载因子以及hashCode、equals方法基本和HashMap一致。</p></blockquote><h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a><strong>WeakHashMap</strong></h3><blockquote><p>WeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。</p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a><strong>ConcurrentHashMap</strong></h3></blockquote><p>HashMap不是线程安全的，HashTable是线程安全的，但是其安全性由全局锁保证，因此效率很低。而ConcurrentHashMap 是将锁的范围细化来实现高效并发的。 基本策略是将数据结构分为一个一个 Segment（每一个都是一个并发可读的 hash table， 即分段锁）作为一个并发单元。 为了减少开销， 除了一处 Segment 是在构造器初始化的， 其他都延迟初始化。 并使用 volatile 关键字来保证 Segment 延迟初始化的可见性问题。</p><blockquote><p>jdk1.8对ConcurrentHashMap做了一些改进：</p><p><strong>改进一</strong>：取消segments字段，直接采用transient volatile HashEntry&lt; K,V&gt;[] table保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。</p><p><strong>改进二</strong>：将原先table数组＋单向链表的数据结构，变更为table数组＋单向链表＋红黑树的结构。在冲突链表长度过长的情况，如果还是采用单向链表方式，那么查询某个节点的时间复杂度为O(n)；因此，对于个数超过8(默认值)的列表，jdk1.8中采用了红黑树的结构，那么查询的时间复杂度可以降低到O(logN)，可以改进性能。</p></blockquote><h2 id="容器的遍历"><a href="#容器的遍历" class="headerlink" title="容器的遍历"></a><font color="red"><strong>容器的遍历</strong></font></h2><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a><strong>迭代器模式</strong></h3><p>Collection 实现了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = container.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">　　Object obj = it.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="List遍历"><a href="#List遍历" class="headerlink" title="List遍历"></a><strong>List遍历</strong></h3><p>主要有三种：<br>第一种：迭代器+for<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator iterator = list.iterator();iterator.hasNext();)&#123;                    </span><br><span class="line">    <span class="keyword">int</span> i = (Integer) iterator.next();                   </span><br><span class="line">    System.out.println(i);               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二种：迭代器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    <span class="keyword">int</span> i = (Integer) iterator.next();<span class="comment">//注意next()返回的是Object对象！！</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第三种：增强for<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Object object : list) &#123;</span><br><span class="line">    System.out.println(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第四种：普通for<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;list.size();i++) &#123;  </span><br><span class="line">    <span class="keyword">int</span> j= (Integer) list.get(i);</span><br><span class="line">    System.out.println(j);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Map遍历"><a href="#Map遍历" class="headerlink" title="Map遍历"></a><strong>Map遍历</strong></h3><p><strong>有四种：</strong></p><p>第一种：通过获取所有的key按照key来遍历<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Set&lt;Integer&gt; set = map.keySet(); //得到所有key的集合</span></span><br><span class="line"><span class="keyword">for</span> (Integer in : map.keySet()) &#123;</span><br><span class="line">    String str = map.get(in);<span class="comment">//得到每个key多对用value的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二种：通过Map.entrySet使用iterator遍历key和value<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">     Map.Entry&lt;Integer, String&gt; entry = it.next();</span><br><span class="line">       System.out.println(<span class="string">"key= "</span> + entry.getKey() + <span class="string">" and value= "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意，用迭代器遍历Map时，Map没有iterator()方法，所以需要用entrySet()得到Set对象，再调用iterator()得到迭代器对象。</p></blockquote><p>第三种：通过Map.entrySet遍历key和value，<strong>推荐，尤其是容量大时</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="comment">//Map.entry&lt;Integer,String&gt; 映射项（键-值对）  有几个方法：用上面的名字entry</span></span><br><span class="line">    <span class="comment">//entry.getKey() ;entry.getValue(); entry.setValue();</span></span><br><span class="line">    <span class="comment">//map.entrySet()  返回此映射中包含的映射关系的 Set视图。</span></span><br><span class="line">    System.out.println(<span class="string">"key= "</span> + entry.getKey() + <span class="string">" and value= "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第四种：通过Map.values()遍历所有的value，但不能遍历key<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String v : map.values()) &#123;</span><br><span class="line">    System.out.println(<span class="string">"value= "</span> + v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong> 概述Java的容器类，有时间再补充详细的源码解析。</strong></p><hr><p><strong>参考：</strong><br><a href="https://blog.csdn.net/qq_37465368/article/details/80854672https://blog.csdn.net/qq_37465368/article/details/80854672" target="_blank" rel="noopener">Java常见的容器类及其区别</a><br><a href="https://blog.csdn.net/dandanzmc/article/details/23447827" target="_blank" rel="noopener">Java中的容器</a><br><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">一份涵盖大部分Java程序员所需要掌握的核心知识</a><br><a href="https://blog.csdn.net/starlh35/article/details/79262472" target="_blank" rel="noopener">深入整理java集合容器</a><br><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">Github</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1551345094255&amp;amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;amp;imgtype=0&amp;amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;简要介绍JAVA容器。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Java容器" scheme="https://yoursite.com/tags/Java%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>设计模式(1)-单例模式</title>
    <link href="https://yoursite.com/2019/01/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(1)-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yoursite.com/2019/01/05/设计模式(1)-单例模式/</id>
    <published>2019-01-05T10:48:10.000Z</published>
    <updated>2019-03-22T08:25:51.265Z</updated>
    
    <content type="html"><![CDATA[<p>本文详细介绍<strong>单例模式</strong>的特点和8种实现方式。</p><a id="more"></a><p>常见的设计模式共有23种，本文介绍-<strong>单例模式</strong>。<br><img src="https://s2.ax1x.com/2019/03/22/A37kRI.png" alt="此处输入图片的描述"></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p><strong>单例模式</strong>是一种常用的软件设计模式。通过单例模式可以保证系统中，应用该模式的一个类只有一个实例。其定义是单例对象的类<code>只能允许一个实例</code>存在。</p><p>单例模式<strong>特点</strong>：<br>一是某个类只能有一个实例；<br>二是它必须自行创建这个实例；<br>三是它必须自行向整个系统提供这个实例。</p><p>需要注意的<strong>问题</strong>：<br>一是线程安全；<br>二是资源使用。</p></blockquote><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><blockquote><p>对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID(序号)生成器。如在<code>Windows</code>中就只能打开一个任务管理器。如果不使用机制对窗口对象进行唯一化，将弹出多个窗口，如果这些窗口显示的内容完全一致，则是重复对象，浪费内存资源；如果这些窗口显示的内容不一致，则意味着在某一瞬间系统有多个状态，与实际不符，也会给用户带来误解，不知道哪一个才是真实的状态。因此有时确保系统中某个对象的唯一性即一个类只能有一个实例非常重要。</p><p><strong>适用场景：</strong></p></blockquote><ul><li>需要频繁的进行创建和销毁的对象；</li><li>创建对象时耗时过多或耗费资源过多，但又经常用到的对象；</li><li>工具类对象；</li><li>频繁访问数据库或文件的对象。</li></ul><h1 id="实现单例模式的八种方法"><a href="#实现单例模式的八种方法" class="headerlink" title="实现单例模式的八种方法"></a>实现单例模式的八种方法</h1><h2 id="1-饿汉式-2种"><a href="#1-饿汉式-2种" class="headerlink" title="1.饿汉式(2种)"></a>1.饿汉式(2种)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">饿汉式1：</span></span><br><span class="line"><span class="comment">静态常量：实例在未调用前就创建，且不会再次创建。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton1 instance = <span class="keyword">new</span> Singleton1() ;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">饿汉式2：</span></span><br><span class="line"><span class="comment">静态代码块：实例在未调用前就创建，且不会再次创建。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>缺点</code>：因为没有调用就创建了实例，所以容易造成资源浪费。</p><h2 id="2-懒汉式"><a href="#2-懒汉式" class="headerlink" title="2.懒汉式"></a>2.懒汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在调用时判断实例是否已经创建。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance ;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( instance == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton2() ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>缺点</code>：线程不安全，多线程中可能出现多个实例。</p><h2 id="3-利用synchronized关键字"><a href="#3-利用synchronized关键字" class="headerlink" title="3. 利用synchronized关键字"></a>3. 利用<code>synchronized</code>关键字</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在调用时判断实例是否已经创建,同时方法块加synchronized锁。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton3 instance ;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton3 <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( instance == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton3() ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>缺点</code>：经过synchronized修饰的方法和代码块速度很慢，多次调用时性能很低。</p><h2 id="4-双重校验提高性能（常用）"><a href="#4-双重校验提高性能（常用）" class="headerlink" title="4. 双重校验提高性能（常用）"></a>4. 双重校验提高性能<strong>（常用）</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在调用时判断实例是否已经创建,不存在时再加锁创建对象，避免同时创建多个对象。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton4 instance ;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( instance == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton4.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton4();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>缺点</code>：第一次加载时反应不快，由于java内存模型一些原因偶尔失败。<br>假设两个线程A、B，都是第一次调用该单例方法，线程A先执行<code>instance = new Singleton4()</code>，该构造方法是一个非原子操作，编译后生成多条字节码指令，由于JAVA的指令重排序，可能会先执行 <code>instance</code> 的赋值操作，该操作实际只是在内存中开辟一片存储对象的区域后直接返回内存的引用，之后 <code>instance</code>便不为空了，但是实际的初始化操作却还没有执行，如果就在此时线程B进入，就会看到一个不为空的但是不完整 （没有完成初始化）的<code>instance</code>对象。</p><h2 id="5-volatile关键字，解决双重校验的弊端（常用）"><a href="#5-volatile关键字，解决双重校验的弊端（常用）" class="headerlink" title="5. volatile关键字，解决双重校验的弊端（常用）"></a>5. <code>volatile</code>关键字，解决双重校验的弊端<strong>（常用）</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">加入volatile关键字，禁止指令重排序优化，从而安全的实现单例。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton5 instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( instance == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton5.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton5();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>加入<code>volatile</code>关键字，禁止指令重排序优化，从而安全的实现单例。</p></blockquote><h2 id="6-静态内部类（常用）"><a href="#6-静态内部类（常用）" class="headerlink" title="6. 静态内部类（常用）"></a>6. 静态内部类<strong>（常用）</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">避免了线程不安全，延迟加载，效率高。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLetonHolder</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 静态初始化器，由JVM来保证线程安全</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton6 instance = <span class="keyword">new</span> Singleton6();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> staic Singleton6 <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingleLetonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>相比饿汉式只要<code>Singleton</code>类被装载就会实例化，没有<code>Lazy-Loading</code>的作用；静态内部类方式在<code>Singleton</code>类被装载时并不会立即实例化，而是在需要实例化时，调用<code>get()</code>方法，才会装载<code>SingleLetonHolder</code>类，从而完成<code>Singleton</code>的实例化。</p><h2 id="7-枚举类实现-JDK1-5后"><a href="#7-枚举类实现-JDK1-5后" class="headerlink" title="7. 枚举类实现(JDK1.5后)"></a>7. 枚举类实现(JDK1.5后)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton7&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">otherMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 可以用任何方法。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文详细介绍&lt;strong&gt;单例模式&lt;/strong&gt;的特点和8种实现方式。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="单例模式" scheme="https://yoursite.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>keras模型拼接</title>
    <link href="https://yoursite.com/2018/12/25/keras%E6%A8%A1%E5%9E%8B%E6%8B%BC%E6%8E%A5/"/>
    <id>https://yoursite.com/2018/12/25/keras模型拼接/</id>
    <published>2018-12-25T12:48:20.000Z</published>
    <updated>2019-03-05T07:22:22.896Z</updated>
    
    <content type="html"><![CDATA[<p><strong>在模型测试过程中，如何让两个模型中间层的输入输出拼在一起呢？</strong><br><img src="https://upgrad.com/blog/wp-content/uploads/2018/04/keras0.png" alt="此处输入图片的描述"></p><a id="more"></a><p>首先，加载训练好的模型后，我们可以用下面的方式获取模型的中间层输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = load_model(&quot;model1.h5&quot;)</span><br><span class="line">First_model = Model(inputs=model.input, outputs=model.layers[7].output)#表示获取模型第7层的输出</span><br></pre></td></tr></table></figure></p><p>然后如何把第7层的输出，作为下一个模型中间层的输入呢？用下面的方法是不可以的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model2 = load_model(&quot;model2.h5&quot;)</span><br><span class="line">second_model = Model(inputs=model2.layers[8].input, outputs=model2.layers[-1].output)</span><br></pre></td></tr></table></figure></p><p>这样会得到类似下面的错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RuntimeError: Graph disconnected: cannot obtain value for tensor Tensor(&quot;conv2d_1_input:0&quot;, shape=(?, 144, 144, 3), dtype=float32) at layer &quot;conv2d_1_input&quot;. The following previous layers were accessed without issue: []</span><br></pre></td></tr></table></figure></p><p>解决办法是声明一个新的Input Layer,用下面的方式拼接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">second_input = Input(model.layers[8].input_shape[1:])</span><br><span class="line">second_model = second_input</span><br><span class="line">for layer in model.layers[8:]:</span><br><span class="line">    second_model = layer(second_model)</span><br><span class="line">second_model = Model(inputs=second_input, outputs=second_model)</span><br></pre></td></tr></table></figure></p><p>由此，便完成了模型的拼接！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;在模型测试过程中，如何让两个模型中间层的输入输出拼在一起呢？&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://upgrad.com/blog/wp-content/uploads/2018/04/keras0.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="https://yoursite.com/categories/Machine-Learning/"/>
    
    
      <category term="python" scheme="https://yoursite.com/tags/python/"/>
    
      <category term="keras" scheme="https://yoursite.com/tags/keras/"/>
    
  </entry>
  
  <entry>
    <title>数据库(3)-JDBC</title>
    <link href="https://yoursite.com/2018/12/07/%E6%95%B0%E6%8D%AE%E5%BA%93(3)-JDBC/"/>
    <id>https://yoursite.com/2018/12/07/数据库(3)-JDBC/</id>
    <published>2018-12-07T11:48:20.000Z</published>
    <updated>2019-03-24T08:45:44.875Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/03/14/AAvGd0.jpg" alt="此处输入图片的描述"><br>JAVA数据库连接JDBC、以及DAO模式的使用。</p><a id="more"></a><h2 id="JDBC概述"><a href="#JDBC概述" class="headerlink" title="JDBC概述"></a>JDBC概述</h2><p>Java 数据库连接，<code>（Java Database Connectivity，简称JDBC）</code>是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。JDBC也是Sun Microsystems的商标。它JDBC是面向关系型数据库的。<br><strong>即用于执行SQL语句的JAVA API。</strong></p><h2 id="一、安装和配置"><a href="#一、安装和配置" class="headerlink" title="一、安装和配置"></a>一、安装和配置</h2><p>直接按照教程，话不多说。<br><a href="https://www.jb51.net/article/23876.htm" target="_blank" rel="noopener">MySQL安装图解</a></p><h2 id="二、下载数据库对应的jar包"><a href="#二、下载数据库对应的jar包" class="headerlink" title="二、下载数据库对应的jar包"></a>二、下载数据库对应的jar包</h2><blockquote><p>（1）在<a href="https://dev.mysql.com/downloads/connector/j/" target="_blank" rel="noopener">MySQL官网页面</a>,选择对应系统的文件。如果是<strong>windows</strong>系统，选择<strong>Platform Independent</strong>对应的jar包即可。</p><p>（2）复制<strong>mysql-connector-java-8.0.15.jar</strong>包到你的\jre1.8.0_181\lib\ext文件夹下。</p></blockquote><h2 id="三、JDBC基本操作"><a href="#三、JDBC基本操作" class="headerlink" title="三、JDBC基本操作"></a>三、<strong>JDBC基本操作</strong></h2><h3 id="1-使用的基本步骤"><a href="#1-使用的基本步骤" class="headerlink" title="(1)使用的基本步骤"></a><strong>(1)使用的基本步骤</strong></h3><blockquote><p>a.注册驱动<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DriverManager.registerDriver(<span class="keyword">new</span> com.mysql.jdbc.Driver());</span><br><span class="line"><span class="comment">//上面这种方法相当于注册两次驱动，因此没有必要，最好用下面这种代码：</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"><span class="comment">//上面已经deprecated</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br></pre></td></tr></table></figure></p><p>b.建立连接<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 一个参数，用&amp;隔开</span></span><br><span class="line">DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost/database_name?user=user&amp;password=password"</span>);</span><br><span class="line"><span class="comment">//2. 建立连接 参数一： 协议 + 访问的数据库 ， 参数二： 用户名 ， 参数三： 密码。</span></span><br><span class="line">conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost/database_name"</span>, <span class="string">"user"</span>, <span class="string">"password"</span>);</span><br></pre></td></tr></table></figure></p><p>c.创建statement<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3. 创建statement对象 ，很重要的一个类</span></span><br><span class="line">st = conn.createStatement();</span><br></pre></td></tr></table></figure></p><p>d.执行sql ，得到ResultSet<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4. 执行查询 ， 得到结果集</span></span><br><span class="line">String sql = <span class="string">"select * from table_name"</span>;</span><br><span class="line">rs = st.executeQuery(sql);</span><br></pre></td></tr></table></figure></p><p>e.遍历结果集<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5. 遍历查询每一条记录</span></span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">   <span class="keyword">int</span> id = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">   String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">   <span class="keyword">int</span> age = rs.getInt(<span class="string">"age"</span>);</span><br><span class="line">   System.out.println(<span class="string">"id="</span>+id + <span class="string">"===name="</span>+name+<span class="string">"==age="</span>+age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>f.释放资源<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        rs.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException sqlEx) &#123; &#125;</span><br><span class="line">    rs = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="2-JDBC数据库CURD对应的SQL语句"><a href="#2-JDBC数据库CURD对应的SQL语句" class="headerlink" title="(2)JDBC数据库CURD对应的SQL语句"></a>(2)<strong>JDBC数据库CURD对应的SQL语句</strong></h3><blockquote><p>通过代码示例了解如何通过JDBC对数据库进行增删改查的任务。</p></blockquote><h4 id="A-Insert"><a href="#A-Insert" class="headerlink" title="A. Insert"></a>A. Insert</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获取连接对象</span></span><br><span class="line">conn = JDBCUtil.getConn();</span><br><span class="line"><span class="comment">// 2. 根据连接对象，得到statement对象</span></span><br><span class="line">st = conn.createStatement();</span><br><span class="line"><span class="comment">// 3. 执行添加</span></span><br><span class="line">String sql = <span class="string">"insert into t_stu values(null , 'wufan' , 99)"</span>;</span><br><span class="line"><span class="comment">//返回影响的行数，如果大于0表明操作成功。否则失败</span></span><br><span class="line"><span class="keyword">int</span> result = st.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(result &gt;<span class="number">0</span> )&#123;</span><br><span class="line">System.out.println(<span class="string">"添加成功"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"添加失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="B-Delete"><a href="#B-Delete" class="headerlink" title="B. Delete"></a>B. Delete</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获取连接对象</span></span><br><span class="line">conn = JDBCUtil.getConn();</span><br><span class="line"><span class="comment">// 2. 根据连接对象，得到statement</span></span><br><span class="line">st = conn.createStatement();</span><br><span class="line"><span class="comment">// 3. 执行删除</span></span><br><span class="line">String sql = <span class="string">"delete from t_stu where name='wufan'"</span>;</span><br><span class="line"><span class="comment">//返回影响的行数，如果大于0表明操作成功。否则失败</span></span><br><span class="line"><span class="keyword">int</span> result = st.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(result &gt;<span class="number">0</span> )&#123;</span><br><span class="line">System.out.println(<span class="string">"删除成功"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"删除失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="C-Query"><a href="#C-Query" class="headerlink" title="C. Query"></a>C. Query</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获取连接对象</span></span><br><span class="line">conn = JDBCUtil.getConn();</span><br><span class="line"><span class="comment">// 2. 根据连接对象，得到statement</span></span><br><span class="line">st = conn.createStatement();</span><br><span class="line"><span class="comment">// 3. 执行返回ResultSet.</span></span><br><span class="line">String sql = <span class="string">"select * from t_stu"</span>;</span><br><span class="line">rs = st.executeQuery(sql);</span><br><span class="line"><span class="comment">// 4. 遍历结果集</span></span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line"><span class="keyword">int</span> age = rs.getInt(<span class="string">"age"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(name + <span class="string">"   "</span> + age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="D-Update"><a href="#D-Update" class="headerlink" title="D. Update"></a>D. Update</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获取连接对象</span></span><br><span class="line">conn = JDBCUtil.getConn();</span><br><span class="line"><span class="comment">// 2. 根据连接对象，得到statement</span></span><br><span class="line">st = conn.createStatement();</span><br><span class="line"><span class="comment">// 3. 执行更新</span></span><br><span class="line">String sql = <span class="string">"update t_stu set age = 16 where name ='wufan'"</span>;</span><br><span class="line"><span class="comment">//返回影响的行数，如果大于0表明操作成功。否则失败</span></span><br><span class="line"><span class="keyword">int</span> result = st.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(result &gt;<span class="number">0</span> )&#123;</span><br><span class="line">System.out.println(<span class="string">"删除成功"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"删除失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、使用properties配置文件"><a href="#四、使用properties配置文件" class="headerlink" title="四、使用properties配置文件"></a>四、使用properties配置文件</h2><h3 id="1-关于Properties"><a href="#1-关于Properties" class="headerlink" title="(1)关于Properties"></a>(1)关于Properties</h3><blockquote><p>在JDBC中，Properties()是一种很方便的方法，不需要将url、user、password、driverClass写在代码方法中，而是写入配置文件，并通过调用配置文件实现。</p></blockquote><h3 id="2-使用properties链接数据库"><a href="#2-使用properties链接数据库" class="headerlink" title="(2)使用properties链接数据库"></a>(2)使用properties链接数据库</h3><blockquote><p>1.在src声明一个配置文件XXX.properties，内容如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">driverClass=com.mysql.jdbc.Driver</span><br><span class="line">url=jdbc:mysql://localhost:3306/database?useUnicode=true&amp;characterEncoding=utf8</span><br><span class="line">username=root</span><br><span class="line">password=root</span><br></pre></td></tr></table></figure><blockquote><p>2.在工具类中，使用静态代码块读取属性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String driverClass;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//1. 创建一个属性配置对象</span></span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"jdbc.properties"</span>); <span class="comment">//对应文件位于工程根目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1：使用当前类加载器，读取src底下的资源文件。</span></span><br><span class="line"><span class="comment">//InputStream is = JDBCUtil.class.getClassLoader().getResourceAsStream("jdbc.properties");</span></span><br><span class="line"><span class="comment">//方法2：导入输入流。</span></span><br><span class="line">properties.load(is);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取属性</span></span><br><span class="line">driverClass = properties.getProperty(<span class="string">"driverClass"</span>);</span><br><span class="line">url = properties.getProperty(<span class="string">"url"</span>);</span><br><span class="line">name = properties.getProperty(<span class="string">"name"</span>);</span><br><span class="line">password = properties.getProperty(<span class="string">"password"</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>获取连接：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(driverClass);</span><br><span class="line">            conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>释放资源：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(Connection conn, PreparedStatement pstmt, ResultSet rs)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               rs.close();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (pstmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               pstmt.close();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               conn.close();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>可以发现，这种方式能降低代码维护成本，解决了数据库更换的麻烦。</p></blockquote><h2 id="五、DAO模式"><a href="#五、DAO模式" class="headerlink" title="五、DAO模式"></a>五、DAO模式</h2><blockquote><p><strong>DAO: Data Access Object 数据访问对象</strong></p></blockquote><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>(1).隔离业务逻辑代码和数据访问代码,位于业务逻辑和持久化数据之间，实现对持久化数据的访问。<br>(2).隔离不同数据库的实现。</p><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><p>(1).DAO接口<br>(2).DAO实现类<br>(3).实体类<br>(4).数据库连接和关闭工具类</p><h3 id="直接上代码"><a href="#直接上代码" class="headerlink" title="直接上代码"></a>直接上代码</h3><p>(1).DAO接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DAO</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findeAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(2).DAO实现类(实体类略去)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: wufan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UerDao</span> <span class="keyword">implements</span> <span class="title">DAO</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findeAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement st = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 获取连接对象</span></span><br><span class="line">            conn = JDBCUtil.getConnection();</span><br><span class="line">            <span class="comment">//2. 创建statement对象</span></span><br><span class="line">            st = conn.createStatement();</span><br><span class="line">            String sql = <span class="string">"select * from user"</span>;</span><br><span class="line">            rs = st.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                String phone = rs.getString(<span class="string">"phone"</span>);</span><br><span class="line">                <span class="keyword">int</span> id = rs.getInt(<span class="string">"uid"</span>);</span><br><span class="line">                System.out.print(id+<span class="string">"\t"</span>+phone);</span><br><span class="line">                System.out.println(<span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtil.release(conn, st, rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UerDao ud = <span class="keyword">new</span> UerDao();</span><br><span class="line">        ud.findeAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(4).数据库连接和关闭工具类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: wufan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driverClass;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            <span class="comment">//InputStream is = JDBCUtil.class.getClassLoader().getResourceAsStream("JDBC.properties");</span></span><br><span class="line">            InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"P:\\Java\\Database\\src\\JDBC.properties"</span>); <span class="comment">//对应文件位于工程根目录</span></span><br><span class="line">            properties.load(is);</span><br><span class="line"></span><br><span class="line">            driverClass = properties.getProperty(<span class="string">"driverClass"</span>);</span><br><span class="line">            url = properties.getProperty(<span class="string">"url"</span>);</span><br><span class="line">            username = properties.getProperty(<span class="string">"username"</span>);</span><br><span class="line">            password = properties.getProperty(<span class="string">"password"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(driverClass);</span><br><span class="line">            conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(Connection conn, Statement pstmt, ResultSet rs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pstmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pstmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="六、PrepareStatement"><a href="#六、PrepareStatement" class="headerlink" title="六、PrepareStatement"></a>六、PrepareStatement</h2><blockquote><p>在需要传入参数的SQL语句中，替换<code>Statement</code>对象。</p><p>相比较以前的<code>Statemen</code>， 预先处理给定的sql语句，对其执行语法检查。 在sql语句里面使用<code>?</code>占位符来替代后续要传递进来的变量。后面进来的变量值，将会被看成是字符串，不会产生任何的关键字。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"insert into table_name values(? , ? , ?)"</span>;</span><br><span class="line">PrepareStatement ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">//给占位符赋值</span></span><br><span class="line"><span class="comment">//注意从左到右数过来，1 代表第一个问号， 永远从1开始。</span></span><br><span class="line">ps.setInt(<span class="number">1</span>,id);</span><br><span class="line">ps.setString(<span class="number">2</span>, userName);</span><br><span class="line">ps.setString(<span class="number">3</span>, phone);</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="PreparedStatement-和-Statement比较"><a href="#PreparedStatement-和-Statement比较" class="headerlink" title="PreparedStatement 和 Statement比较"></a>PreparedStatement 和 Statement比较</h3><blockquote><p>A.<code>PreparedStatement</code> 尽最大可能提高性能<br><code>sql</code> 语句被数据库的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。<br><code>PreparedStatement</code> 会先初始化SQL，先把这个SQL提交到数据库中进行预处理，并缓存下来，多次使用可提高效率。如果仅仅执行了一次的话，和普通的对象差别不大，体现不出它预编译的优越性。<br><code>Statement</code>不会初始化，没有预处理，每次都是从0开始执行SQL。</p><p>B.极大地提高了安全性，防止SQL注入式攻击<br>在使用参数化查询的情况下，数据库系统不会将参数的内容视为 SQL 指令的一部分来处理，而是在数据库完成 SQL 指令的编译后，才套用参数运行，因此就算参数中含有破坏性的指令，也不会被数据库所运行。</p><p>C.代码的可读性和可维护性更强</p></blockquote><h2 id="七、遇到的错误"><a href="#七、遇到的错误" class="headerlink" title="七、遇到的错误"></a>七、遇到的错误</h2><blockquote><p>(1)time zone错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SQLException: The server time zone value &apos;ÖÐ¹ú±ê×¼Ê±¼ä&apos; is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.</span><br><span class="line">SQLState: 01S00</span><br><span class="line">VendorError: 0</span><br></pre></td></tr></table></figure></p></blockquote><p>这是由于数据库和系统时区差异所造成的，简单的方法是再url后面加上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverTimezone=GMT</span><br></pre></td></tr></table></figure></p><p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost/database_name?&quot;+&quot;user=root&amp;password=root&quot;+&quot;&amp;serverTimezone=GMT&quot;);</span><br></pre></td></tr></table></figure></p><blockquote><p>(2) java.io.FileNotFoundException: JDBC.properties (系统找不到指定的文件。)<br>解决办法1：使用类加载<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream is = JDBCUtil.class.getClassLoader().getResourceAsStream(<span class="string">"JDBC.properties"</span>);</span><br></pre></td></tr></table></figure></p></blockquote><p>办法2：改用全路径<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"P:\\Java\\Database\\src\\JDBC.properties"</span>);</span><br></pre></td></tr></table></figure></p><hr><p><strong>参考链接：</strong><br>1.<a href="https://blog.csdn.net/qq_36923376/article/details/83657127" target="_blank" rel="noopener">mysql-8.0.13使用jdbc与java连接教程</a><br>2.<a href="https://www.cnblogs.com/wuyuegb2312/p/3872607.html" target="_blank" rel="noopener">通过JDBC进行简单的增删改查（以MySQL为例）</a><br>3.《高性能MySQL》</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/03/14/AAvGd0.jpg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;JAVA数据库连接JDBC、以及DAO模式的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Database" scheme="https://yoursite.com/categories/Database/"/>
    
    
      <category term="数据库" scheme="https://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://yoursite.com/tags/MySQL/"/>
    
      <category term="JDBC" scheme="https://yoursite.com/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>Java的艺术-Java技术栈</title>
    <link href="https://yoursite.com/2018/12/05/Java%E7%9A%84%E8%89%BA%E6%9C%AF-Java%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    <id>https://yoursite.com/2018/12/05/Java的艺术-Java技术栈/</id>
    <published>2018-12-05T13:48:20.000Z</published>
    <updated>2019-03-21T16:02:36.796Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551345094255&amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;imgtype=0&amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png" alt="此处输入图片的描述"><br>当学Java迷茫的时候，不妨看看，激励一下自己！<br><a id="more"></a></p><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a><font color="red">基础篇</font></h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p><strong>→ 什么是面向对象</strong><br>面向对象、面向过程<br>面向对象的三大基本特征和五大基本原则<br><strong>→ 平台无关性</strong><br>Java 如何实现的平台无关<br>JVM 还支持哪些语言（Kotlin、Groovy、JRuby、Jython、Scala）<br><strong>→ 值传递</strong><br>值传递、引用传递<br>为什么说 Java 中只有值传递<br><strong>→ 封装、继承、多态</strong><br>什么是多态、方法重写与重载<br>Java 的继承与实现<br>构造函数与默认构造函数<br>类变量、成员变量和局部变量<br>成员变量和方法作用域</p><h3 id="Java-基础知识"><a href="#Java-基础知识" class="headerlink" title="Java 基础知识"></a>Java 基础知识</h3><p><strong>→ 基本数据类型</strong><br>8 种基本数据类型：整型、浮点型、布尔型、字符型<br>整型中 byte、short、int、long 的取值范围<br>什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？<br><strong>→ 自动拆装箱</strong><br>什么是包装类型、什么是基本类型、什么是自动拆装箱<br>Integer 的缓存机制<br><strong>→ String</strong><br>字符串的不可变性<br>JDK 6 和 JDK 7 中 substring 的原理及区别、<br>replaceFirst、replaceAll、replace 区别、<br>String 对“+”的重载、字符串拼接的几种方式和区别<br>String.valueOf 和 Integer.toString 的区别、<br>switch 对 String 的支持<br>字符串池、常量池（运行时常量池、Class 常量池）、intern<br><strong>→ 熟悉 Java 中各种关键字</strong><br>transient、instanceof、final、static、volatile、synchronized、const 原理及用法<br><strong>→ 集合类</strong><br>常用集合类的使用、ArrayList 和 LinkedList 和 Vector 的区别 、SynchronizedList 和 Vector 的区别、HashMap、HashTable、ConcurrentHashMap 区别、<br>Set 和 List 区别？Set 如何保证元素不重复？<br>Java 8 中 stream 相关用法、apache 集合处理工具类的使用、不同版本的 JDK 中 HashMap 的实现的区别以及原因<br>Collection 和 Collections 区别<br>Arrays.asList 获得的 List 使用时需要注意什么<br>Enumeration 和 Iterator 区别<br>fail-fast 和 fail-safe<br>CopyOnWriteArrayList、ConcurrentSkipListMap<br><strong>→ 枚举</strong><br>枚举的用法、枚举的实现、枚举与单例、Enum 类<br>Java 枚举如何比较<br>switch 对枚举的支持<br>枚举的序列化如何实现<br>枚举的线程安全性问题<br><strong>→ IO</strong><br>字符流、字节流、输入流、输出流、<br>同步、异步、阻塞、非阻塞、Linux 5 种 IO 模型<br>BIO、NIO 和 AIO 的区别、三种 IO 的用法与原理、netty<br><strong>→ 反射</strong><br>反射与工厂模式、反射有什么用<br>Class 类、java.lang.reflect.<em><br><strong>→ 动态代理</strong><br>静态代理、动态代理<br>动态代理和反射的关系<br>动态代理的几种实现方式<br>AOP<br><em>*→ 序列化</em></em><br>什么是序列化与反序列化、为什么序列化、序列化底层原理、序列化与单例模式、protobuf、为什么说序列化并不安全</p><p><strong>→ 注解</strong><br>元注解、自定义注解、Java 中常用注解使用、注解与反射的结合<br>Spring 常用注解<br><strong>→ JMS</strong><br>什么是 Java 消息服务、JMS 消息传送模型<br><strong>→ JMX</strong><br>java.lang.management.<em>、 javax.management.</em><br><strong>→ 泛型</strong><br>泛型与继承、类型擦除、泛型中 KTVE? object 等的含义、泛型各种用法<br>限定通配符和非限定通配符、上下界限定符 extends 和 super<br>List<object> 和原始类型 List 之间的区别?<br>List&lt;?&gt; 和 List<object> 之间的区别是什么?<br><strong>→ 单元测试</strong><br>junit、mock、mockito、内存数据库（h2）<br><strong>→ 正则表达式</strong><br>java.lang.util.regex.<em><br><strong>→ 常用的 Java 工具库</strong><br>commons.lang、commons.</em>…、 guava-libraries、 netty<br><strong>→ API &amp; SPI</strong><br>API、API 和 SPI 的关系和区别<br>如何定义 SPI、SPI 的实现原理<br><strong>→ 异常</strong><br>异常类型、正确处理异常、自定义异常<br>Error 和 Exception<br>异常链、try-with-resources<br>finally 和 return 的执行顺序<br><strong>→ 时间处理</strong><br>时区、冬令时和夏令时、时间戳、Java 中时间 API<br>格林威治时间、CET,UTC,GMT,CST 几种常见时间的含义和关系<br>SimpleDateFormat 的线程安全性问题<br>Java 8 中的时间处理<br>如何在东八区的计算机上获取美国时间<br><strong>→ 编码方式</strong><br>Unicode、有了 Unicode 为啥还需要 UTF-8<br>GBK、GB2312、GB18030 之间的区别<br>UTF8、UTF16、UTF32 区别<br>URL 编解码、Big Endian 和 Little Endian<br>如何解决乱码问题<br><strong>→ 语法糖</strong><br>Java 中语法糖原理、解语法糖<br>语法糖：switch 支持 String 与枚举、泛型、自动装箱与拆箱、方法变长参数、枚举、内部类、条件编译、 断言、数值字面量、for-each、try-with-resource、Lambda 表达式</object></object></p><h3 id="阅读源代码"><a href="#阅读源代码" class="headerlink" title="阅读源代码"></a>阅读源代码</h3><p>String、Integer、Long、Enum、<br>BigDecimal、ThreadLocal、ClassLoader &amp; URLClassLoader、<br>ArrayList &amp; LinkedList、<br>HashMap &amp; LinkedHashMap &amp; TreeMap &amp; CouncurrentHashMap、HashSet &amp; LinkedHashSet &amp; TreeSet</p><h3 id="Java-并发编程"><a href="#Java-并发编程" class="headerlink" title="Java 并发编程"></a>Java 并发编程</h3><p><strong>→ 并发与并行</strong><br>什么是并发、什么是并行<br>并发与并行的区别<br><strong>→ 什么是线程，与进程的区别</strong><br>线程的实现、线程的状态、优先级、线程调度、创建线程的多种方式、守护线程<br>线程与进程的区别<br><strong>→ 线程池</strong><br>自己设计线程池、submit() 和 execute()、线程池原理<br>为什么不允许使用 Executors 创建线程池<br><strong>→ 线程安全</strong><br>死锁、死锁如何排查、线程安全和内存模型的关系<br><strong>→ 锁</strong><br>CAS、乐观锁与悲观锁、数据库相关锁机制、分布式锁、偏向锁、轻量级锁、重量级锁、monitor、<br>锁优化、锁消除、锁粗化、自旋锁、可重入锁、阻塞锁、死锁<br><strong>→ 死锁</strong><br>什么是死锁<br>死锁如何解决<br><strong>→ synchronized</strong><br>synchronized 是如何实现的？<br>synchronized 和 lock 之间关系、不使用 synchronized 如何实现一个线程安全的单例<br>synchronized 和原子性、可见性和有序性之间的关系<br><strong>→ volatile</strong><br>happens-before、内存屏障、编译器指令重排和 CPU 指令重<br>volatile 的实现原理<br>volatile 和原子性、可见性和有序性之间的关系<br>有了 symchronized 为什么还需要 volatile<br><strong>→ sleep 和 wait</strong><br><strong>→ wait 和 notify</strong><br><strong>→ notify 和 notifyAll</strong><br><strong>→ ThreadLocal</strong><br><strong>→ 写一个死锁的程序</strong><br><strong>→ 写代码来解决生产者消费者问题</strong><br><strong>→ 并方包</strong><br>Thread、Runnable、Callable、ReentrantLock、ReentrantReadWriteLock、Atomic*、Semaphore、CountDownLatch、ConcurrentHashMap、Executors</p><h2 id="底层篇"><a href="#底层篇" class="headerlink" title="底层篇"></a><font color="red">底层篇</font></h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p><strong>→ JVM 内存结构</strong><br>class 文件格式、运行时数据区：堆、栈、方法区、直接内存、运行时常量池、<br>堆和栈区别<br>Java 中的对象一定在堆上分配吗？</p><p><strong>→ Java 内存模型</strong><br>计算机内存模型、缓存一致性、MESI 协议<br>可见性、原子性、顺序性、happens-before、<br>内存屏障、synchronized、volatile、final、锁<br><strong>→ 垃圾回收</strong><br>GC 算法：标记清除、引用计数、复制、标记压缩、分代回收、增量式回收<br>GC 参数、对象存活的判定、垃圾收集器（CMS、G1、ZGC、Epsilon）<br><strong>→ JVM 参数及调优</strong><br>-Xmx、-Xmn、-Xms、Xss、-XX:SurvivorRatio、<br>-XX:PermSize、-XX:MaxPermSize、-XX:MaxTenuringThreshold<br><strong>→ Java 对象模型</strong><br>oop-klass、对象头<br><strong>→ HotSpot</strong><br>即时编译器、编译优化<br><strong>→ 虚拟机性能监控与故障处理工具</strong><br>jps, jstack, jmap, jstat, jconsole, jinfo, jhat, javap, btrace, TProfiler<br>Arthas</p><h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>classLoader、类加载过程、双亲委派（破坏双亲委派）、模块化（jboss modules、osgi、jigsaw）</p><h3 id="编译与反编译"><a href="#编译与反编译" class="headerlink" title="编译与反编译"></a>编译与反编译</h3><p>什么是编译（前端编译、后端编译）、什么是反编译<br>JIT、JIT 优化（逃逸分析、栈上分配、标量替换、锁优化）<br>编译工具：javac<br>反编译工具：javap 、jad 、CRF</p><h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a><font color="red">进阶篇</font></h2><h3 id="Java-底层知识"><a href="#Java-底层知识" class="headerlink" title="Java 底层知识"></a>Java 底层知识</h3><p><strong>→ 字节码、class 文件格式</strong><br><strong>→ CPU 缓存，L1，L2，L3 和伪共享</strong><br><strong>→ 尾递归</strong><br><strong>→ 位运算</strong><br>用位运算实现加、减、乘、除、取余</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>设计模式的六大原则：<br>开闭原则（Open Close Principle）、里氏代换原则（Liskov Substitution Principle）、依赖倒转原则（Dependence Inversion Principle）<br>接口隔离原则（Interface Segregation Principle）、迪米特法则（最少知道原则）（Demeter Principle）、合成复用原则（Composite Reuse Principle）<br><strong>→ 了解 23 种设计模式</strong><br>创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。<br>结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。<br>行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter 模式）、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。<br><strong>→ 会使用常用设计模式</strong><br>单例的七种写法：懒汉——线程不安全、懒汉——线程安全、饿汉、饿汉——变种、静态内部类、枚举、双重校验锁<br>工厂模式、适配器模式、策略模式、模板方法模式、观察者模式、外观模式、代理模式等必会<br><strong>→ 不用 synchronized 和 lock，实现线程安全的单例模式</strong><br><strong>→ 实现 AOP</strong><br><strong>→ 实现 IOC</strong><br><strong>→ nio 和 reactor 设计模式</strong></p><h3 id="网络编程知识"><a href="#网络编程知识" class="headerlink" title="网络编程知识"></a>网络编程知识</h3><p><strong>→ tcp、udp、http、https 等常用协议</strong><br>三次握手与四次关闭、流量控制和拥塞控制、OSI 七层模型、tcp 粘包与拆包<br><strong>→ http/1.0 http/1.1 http/2 之前的区别</strong><br>http 中 get 和 post 区别<br>常见的 web 请求返回的状态码<br>404、302、301、500分别代表什么<br><strong>→ http/3</strong><br><strong>→ Java RMI，Socket，HttpClient</strong><br><strong>→ cookie 与 session</strong><br>cookie 被禁用，如何实现 session<br><strong>→ 用 Java 写一个简单的静态文件的 HTTP 服务器</strong><br><strong>→ 了解 nginx 和 apache 服务器的特性并搭建一个对应的服务器</strong><br><strong>→ 用 Java 实现 FTP、SMTP 协议</strong><br><strong>→ 进程间通讯的方式</strong><br><strong>→ 什么是 CDN？如果实现？</strong><br><strong>→ DNS</strong><br>什么是 DNS 、记录类型: A 记录、CNAME 记录、AAAA 记录等<br>域名解析、根域名服务器<br>DNS 污染、DNS 劫持、公共 DNS：114 DNS、Google DNS、OpenDNS<br><strong>→ 反向代理</strong><br>正向代理、反向代理<br>反向代理服务器</p><h3 id="框架知识"><a href="#框架知识" class="headerlink" title="框架知识"></a>框架知识</h3><p><strong>→ Servlet</strong><br>生命周期<br>线程安全问题<br>filter 和 listener<br>web.xml 中常用配置及作用<br><strong>→ Hibernate</strong><br>什么是 OR Mapping<br>Hibernate 的懒加载<br>Hibernate 的缓存机制<br>Hibernate / Ibatis / MyBatis 之间的区别<br><strong>→ Spring</strong><br>Bean 的初始化<br>AOP 原理<br>实现 Spring 的IOC<br>Spring 四种依赖注入方式<br><strong>→ Spring MVC</strong><br>什么是 MVC<br>Spring mvc 与 Struts mvc 的区别<br><strong>→ Spring Boot</strong><br>Spring Boot 2.0、起步依赖、自动配置、<br>Spring Boot 的 starter 原理，自己实现一个 starter<br><strong>→ Spring Security</strong><br><strong>→ Spring Cloud</strong><br>服务发现与注册：Eureka、Zookeeper、Consul<br>负载均衡：Feign、Spring Cloud Loadbalance<br>服务配置：Spring Cloud Config<br>服务限流与熔断：Hystrix<br>服务链路追踪：Dapper<br>服务网关、安全、消息</p><h3 id="应用服务器知识"><a href="#应用服务器知识" class="headerlink" title="应用服务器知识"></a>应用服务器知识</h3><p><strong>→ JBoss<br>→ tomcat<br>→ jetty<br>→ Weblogic</strong></p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p><strong>→ git &amp; svn</strong><br><strong>→ maven &amp; gradle</strong><br><strong>→ Intellij IDEA</strong><br>常用插件：Maven Helper 、FindBugs-IDEA、阿里巴巴代码规约检测、GsonFormat<br>Lombok plugin、.ignore、Mybatis plugin</p><h2 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a><font color="red">高级篇</font></h2><h3 id="新技术"><a href="#新技术" class="headerlink" title="新技术"></a>新技术</h3><p><strong>→ Java 8</strong><br>lambda 表达式、Stream API、时间 API<br><strong>→ Java 9</strong><br>Jigsaw、Jshell、Reactive Streams<br><strong>→ Java 10</strong><br>局部变量类型推断、G1 的并行 Full GC、ThreadLocal 握手机制<br><strong>→ Java 11</strong><br>ZGC、Epsilon、增强 var<br><strong>→ Spring 5</strong><br>响应式编程<br><strong>→ Spring Boot 2.0</strong><br><strong>→ HTTP/2</strong><br><strong>→ HTTP/3</strong>    </p><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>使用单例、使用 Future 模式、使用线程池<br>选择就绪、减少上下文切换、减少锁粒度、数据压缩、结果缓存</p><h3 id="线上问题分析"><a href="#线上问题分析" class="headerlink" title="线上问题分析"></a>线上问题分析</h3><p><strong>→ dump 获取</strong><br>线程 Dump、内存 Dump、gc 情况<br><strong>→ dump 分析</strong><br>分析死锁、分析内存泄露<br><strong>→ dump 分析及获取工具</strong><br>jstack、jstat、jmap、jhat、Arthas<br><strong>→ 自己编写各种 outofmemory，stackoverflow 程序</strong><br>HeapOutOfMemory、 Young OutOfMemory、<br>MethodArea OutOfMemory、ConstantPool OutOfMemory、<br>DirectMemory OutOfMemory、Stack OutOfMemory Stack OverFlow<br><strong>→ Arthas</strong><br>jvm 相关、class/classloader 相关、monitor/watch/trace 相关、<br>options、管道、后台异步任务<br>文档：<a href="https://alibaba.github.io/arthas/advanced-use.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/advanced-use.html</a><br><strong>→ 常见问题解决思路</strong><br>内存溢出、线程死锁、类加载冲突<br><strong>→ 使用工具尝试解决以下问题，并写下总结</strong><br>当一个 Java 程序响应很慢时如何查找问题<br>当一个 Java 程序频繁 FullGC 时如何解决问题<br>如何查看垃圾回收日志<br>当一个 Java 应用发生 OutOfMemory 时该如何解决<br>如何判断是否出现死锁<br>如何判断是否存在内存泄露<br>使用 Arthas 快速排查 Spring Boot 应用404/401问题<br>使用 Arthas 排查线上应用日志打满问题<br>利用 Arthas 排查 Spring Boot 应用 NoSuchMethodError</p><h3 id="编译原理知识"><a href="#编译原理知识" class="headerlink" title="编译原理知识"></a>编译原理知识</h3><p><strong>→ 编译与反编译</strong><br><strong>→ Java 代码的编译与反编译</strong><br><strong>→ Java 的反编译工具</strong><br>javap 、jad 、CRF<br><strong>→ 即时编译器</strong><br><strong>→ 编译过程</strong><br>词法分析，语法分析（LL 算法，递归下降算法，LR 算法）<br>语义分析，运行时环境，中间代码，代码生成，代码优化</p><h3 id="操作系统知识"><a href="#操作系统知识" class="headerlink" title="操作系统知识"></a>操作系统知识</h3><p><strong>→ Linux 的常用命令<br>→ 进程间通信<br>→ 进程同步<br>生产者消费者问题、哲学家就餐问题、读者写者问题<br>→ 缓冲区溢出<br>→ 分段和分页<br>→ 虚拟内存与主存<br>→ 虚拟内存管理<br>→ 换页算法</strong></p><h3 id="数据库知识"><a href="#数据库知识" class="headerlink" title="数据库知识"></a>数据库知识</h3><p><strong>→ MySQL 执行引擎<br>→ MySQL 执行计划</strong><br>如何查看执行计划，如何根据执行计划进行 SQL 优化<br><strong>→ 索引</strong><br>Hash 索引、B 树索引（B+树、和B树、R树）<br>普通索引、唯一索引<br>覆盖索引、最左前缀原则、索引下推<br><strong>→ SQL 优化</strong><br><strong>→ 数据库事务和隔离级别</strong><br>事务的隔离级别、事务能不能实现锁的功能<br><strong>→ 数据库锁</strong><br>行锁、表锁、使用数据库锁实现乐观锁、<br><strong>→ 连接</strong><br>内连接，左连接，右连接<br><strong>→ 数据库主备搭建</strong><br><strong>→ binlog<br>→ redolog<br>→ 内存数据库</strong><br>h2<br><strong>→ 分库分表<br>→ 读写分离<br>→ 常用的 NoSql 数据库</strong><br>redis、memcached<br><strong>→ 分别使用数据库锁、NoSql 实现分布式锁<br>→ 性能调优<br>→ 数据库连接池</strong></p><h3 id="数据结构与算法知识"><a href="#数据结构与算法知识" class="headerlink" title="数据结构与算法知识"></a>数据结构与算法知识</h3><p><strong>→ 简单的数据结构</strong><br>栈、队列、链表、数组、哈希表、<br>栈和队列的相同和不同之处<br>栈通常采用的两种存储结构<br><strong>→ 树</strong><br>二叉树、字典树、平衡树、排序树、<br>B 树、B+ 树、R 树、多路树、红黑树<br><strong>→ 堆</strong><br>大根堆、小根堆<br><strong>→ 图</strong><br>有向图、无向图、拓扑<br><strong>→ 排序算法</strong><br>稳定的排序：冒泡排序、插入排序、鸡尾酒排序、桶排序、计数排序、归并排序、原地归并排序、二叉排序树排序、鸽巢排序、基数排序、侏儒排序、图书馆排序、块排序<br>不稳定的排序：选择排序、希尔排序、Clover 排序算法、梳排序、堆排序、平滑排序、快速排序、内省排序、耐心排序<br>各种排序算法和时间复杂度<br><strong>→ 两个栈实现队列，和两个队列实现栈<br>→ 深度优先和广度优先搜索<br>→ 全排列、贪心算法、KMP 算法、hash 算法<br>→ 海量数据处理</strong><br>分治，hash 映射，堆排序，双层桶划分，Bloom Filter，bitmap，数据库索引，mapreduce 等。</p><h3 id="大数据知识"><a href="#大数据知识" class="headerlink" title="大数据知识"></a>大数据知识</h3><p><strong>→ Zookeeper</strong><br>基本概念、常见用法<br><strong>→ Solr，Lucene，ElasticSearch</strong><br>在 linux 上部署 solr，solrcloud，新增、删除、查询索引<br><strong>→ Storm，流式计算，了解 Spark，S4</strong><br>在 linux 上部署 storm，用 zookeeper 做协调，运行 storm hello world，local 和 remote 模式运行调试 storm topology。<br><strong>→ Hadoop，离线计算</strong><br>HDFS、MapReduce<br><strong>→ 分布式日志收集 flume，kafka，logstash</strong><br><strong>→ 数据挖掘，mahout</strong></p><h3 id="网络安全知识"><a href="#网络安全知识" class="headerlink" title="网络安全知识"></a>网络安全知识</h3><p><strong>→ XSS</strong><br>XSS 的防御<br><strong>→ CSRF</strong><br><strong>→ 注入攻击</strong><br>SQL 注入、XML 注入、CRLF 注入<br><strong>→ 文件上传漏洞<br>→ 加密与解密</strong><br>对称加密、非对称加密、哈希算法、加盐哈希算法<br>MD5，SHA1、DES、AES、RSA、DSA<br>彩虹表<br><strong>→ DDOS攻击</strong><br>DOS 攻击、DDOS 攻击<br>memcached 为什么可以导致 DDos 攻击、什么是反射型 DDoS<br>如何通过 Hash 碰撞进行 DOS 攻击<br><strong>→ SSL、TLS，HTTPS<br>→ 用 openssl 签一个证书部署到 apache 或 nginx</strong></p><h2 id="架构篇"><a href="#架构篇" class="headerlink" title="架构篇"></a><font color="red">架构篇</font></h2><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>数据一致性、服务治理、服务降级<br><strong>→ 分布式事务</strong><br>2PC、3PC、CAP、BASE、 可靠消息最终一致性、最大努力通知、TCC<br><strong>→ Dubbo</strong><br>服务注册、服务发现，服务治理<br><a href="http://dubbo.apache.org/zh-cn/" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/</a><br><strong>→ 分布式数据库</strong><br>怎样打造一个分布式数据库、什么时候需要分布式数据库、<br>mycat、otter、HBase<br><strong>→ 分布式文件系统</strong><br>mfs、fastdfs<br><strong>→ 分布式缓存</strong><br>缓存一致性、缓存命中率、缓存冗余<br><strong>→ 限流降级</strong><br>Hystrix、Sentinal<br><strong>→ 算法</strong><br>共识算法、Raft 协议、Paxos 算法与 Raft 算法、<br>拜占庭问题与算法、2PC、3PC</p><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>SOA、康威定律<br><strong>→ ServiceMesh</strong><br>sidecar<br><strong>→ Docker &amp; Kubernets<br>→ Spring Boot<br>→ Spring Cloud</strong></p><h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><p><strong>→ 分库分表<br>→ CDN 技术<br>→ 消息队列</strong><br>ActiveMQ</p><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p><strong>→ 监控什么</strong><br>CPU、内存、磁盘 I/O、网络 I/O 等<br><strong>→ 监控手段</strong><br>进程监控、语义监控、机器资源监控、数据波动<br><strong>→ 监控数据采集</strong><br>日志、埋点<br><strong>→ Dapper</strong></p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>tomcat 负载均衡、Nginx 负载均衡<br>四层负载均衡、七层负载均衡</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS 原理、DNS 的设计</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>数据一致性</p><h2 id="扩展篇"><a href="#扩展篇" class="headerlink" title="扩展篇"></a><font color="red">扩展篇</font></h2><h3 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h3><p>IaaS、SaaS、PaaS、虚拟化技术、openstack、Serverlsess</p><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><p>Solr、Lucene、Nutch、Elasticsearch</p><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><p>Shiro</p><h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><p>哈希算法、Merkle 树、公钥密码算法、共识算法、<br>Raft 协议、Paxos 算法与 Raft 算法、拜占庭问题与算法、消息认证码与数字签名<br><strong>→ 比特币</strong><br>挖矿、共识机制、闪电网络、侧链、热点问题、分叉<br><strong>→ 以太坊<br>→ 超级账本</strong></p><h3 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h3><p>数学基础、机器学习、人工神经网络、深度学习、应用场景。<br><strong>→ 常用框架</strong><br>TensorFlow、DeepLearning4J</p><h3 id="loT"><a href="#loT" class="headerlink" title="loT"></a>loT</h3><h3 id="量子计算"><a href="#量子计算" class="headerlink" title="量子计算"></a>量子计算</h3><h3 id="AR-amp-VR"><a href="#AR-amp-VR" class="headerlink" title="AR &amp; VR"></a>AR &amp; VR</h3><h3 id="其他语言"><a href="#其他语言" class="headerlink" title="其他语言"></a>其他语言</h3><p>Groovy、Python、Go、NodeJs、Swift、Rust</p><h2 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a><font color="red">推荐书籍</font></h2><p>《深入理解 Java 虚拟机》<br>《Effective Java》<br>《深入分析 Java Web 技术内幕》<br>《大型网站技术架构》<br>《代码整洁之道》<br>《架构整洁之道》<br>《Head First 设计模式》<br>《maven 实战》<br>《区块链原理、设计与应用》<br>《Java 并发编程实战》<br>《鸟哥的 Linux 私房菜》<br>《从Paxos 到 Zookeeper》<br>《架构即未来》</p><p><strong><a href="https://mp.weixin.qq.com/s/zYJTLOpCkYuMR1HMCJOt-A" target="_blank" rel="noopener">转载自公众号：Hollis</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1551345094255&amp;amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;amp;imgtype=0&amp;amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;当学Java迷茫的时候，不妨看看，激励一下自己！&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://yoursite.com/categories/Java/"/>
    
    
      <category term="技术栈" scheme="https://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>Java的艺术-类和接口的多继承</title>
    <link href="https://yoursite.com/2018/12/05/Java%E7%9A%84%E8%89%BA%E6%9C%AF-%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF/"/>
    <id>https://yoursite.com/2018/12/05/Java的艺术-类和接口的多继承/</id>
    <published>2018-12-05T10:48:20.000Z</published>
    <updated>2019-03-21T16:05:08.759Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551345094255&amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;imgtype=0&amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png" alt="此处输入图片的描述"><br>Java也有多继承？来看看JDK8的这个新特性！<br><a id="more"></a></p><h2 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a><font color="red"><strong>接口（Interface）</strong></font></h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>(JDK8以前)</strong>接口中可以含有 变量和方法。但是要注意，接口中的变量会被隐式地指定为<strong>public static final</strong>变量（并且只能是public static final变量，用private修饰会报编译错误），而方法会被隐式地指定为<strong>public abstract</strong>方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误）</p><p>并且<strong>接口中所有的方法不能有具体的实现</strong>，也就是说，<font color="red"><strong>接口中的方法必须都是抽象方法</strong></font>。从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。</p></blockquote><h3 id="Java8-新特性"><a href="#Java8-新特性" class="headerlink" title="Java8 新特性"></a>Java8 新特性</h3><blockquote><p><font color="red"><strong>但是，自从Java 8发布后，接口中也可以自定义方法了（default method）</strong></font>。这样如果为很多继承了同一个接口的类增加功能，不必对这些类重新设计。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface Test &#123;</span><br><span class="line">    //default关键字不能省略，否则提示Interface abstract methods cannot have body</span><br><span class="line">    default String test(String str)&#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">    //默认为public,abstract的</span><br><span class="line">    int test2();</span><br><span class="line">    //default关键字不能与abstact同时修饰接口方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同时，接口方法也可以被<strong>static</strong>修饰。</p><p>但是这也给Java带来了新问题——<font color="red"><strong>Java多继承的冲突</strong></font>。</p></blockquote><h3 id="接口中被default与static修饰的方法"><a href="#接口中被default与static修饰的方法" class="headerlink" title="接口中被default与static修饰的方法"></a>接口中被default与static修饰的方法</h3><ul><li><p>非default、static方法不能有实现，否则编译错误：Abstract methods do not specify a body</p></li><li><p>default、static方法必须有具体的实现，否则编译错误：This method requires a body instead of a semicolon</p></li><li><p>可以拥有多个default方法</p></li><li><p>可以拥有多个static方法</p></li><li><p>使用接口中类型时，仅仅需要实现抽象方法，default、static方法不需要强制自己新实现</p></li></ul><h2 id="Java多继承"><a href="#Java多继承" class="headerlink" title="Java多继承"></a><font color="red"><strong>Java多继承</strong></font></h2><h3 id="接口多继承冲突"><a href="#接口多继承冲突" class="headerlink" title="接口多继承冲突"></a>接口多继承冲突</h3><blockquote><p>比如有三个接口，Interface Test1,Interface Test2,Interface Test3。其中，Interface Test3继承自Test1和Test2。</p><p>如果Test1和Test2有相同签名的默认(default)方法，并且Test3没有override，则编译会出错。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Test1 &#123;</span><br><span class="line">     default String test(String str)&#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Test2 &#123;</span><br><span class="line">     default String test(String str)&#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface Test3 extends Test1,Test2 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multiextends.Test3 inherits unrelated defaults for test(String) from types multiextends.Test1 and multiextends.Test2</span><br></pre></td></tr></table></figure></p><p>需要在子接口中覆盖这个方法，让子类知道默认调用哪个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Test3 extends Test1,Test2 &#123;</span><br><span class="line">     default String test(String str)&#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意判断是否签名相同是根据传入的参数，而不是返回的参数。此时接口会根据传入的参数选择不同的default方法执行。</strong><br>比如下面的会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Test1 &#123;</span><br><span class="line"></span><br><span class="line">     default int test(String str)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Test2 &#123;</span><br><span class="line">//传入相同的String，返回不同的类型</span><br><span class="line">     default String test(String str)&#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//编译通过，不需要覆盖</span><br><span class="line">interface Test3 extends Test1,Test2 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是下面的编译通过：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Test1 &#123;</span><br><span class="line">     default String test(int a)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Test2 &#123;</span><br><span class="line">//传入不同类型的参数，返回相同的类型</span><br><span class="line">     default String test(String str)&#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//报错，需要覆盖</span><br><span class="line">//interface Test3 extends Test1,Test2 &#123;</span><br><span class="line">//&#125;</span><br></pre></td></tr></table></figure></p><h3 id="超类多继承冲突"><a href="#超类多继承冲突" class="headerlink" title="超类多继承冲突"></a>超类多继承冲突</h3><blockquote><p>如果比如有两个接口，Interface Test1,Interface Test2，一个超类Class Test3，一个子类Class Test4其中，Class Test4实现Interface Test1和Interface Test2，继承Class Test3。</p><p>如果方法有冲突会怎么样？<br>直接看代码：（注意注释中对静态方法和静态属性的 ）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">interface Test1 &#123;</span><br><span class="line">     default String test(int a)&#123;</span><br><span class="line">        return &quot;test&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Test2 &#123;</span><br><span class="line">//传入不同类型的参数，返回相同的类型</span><br><span class="line">     default String test(String str)&#123;</span><br><span class="line">        return &quot;test2&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Test3&#123;</span><br><span class="line">//如果public换成static会报错</span><br><span class="line">//但是如果只和一个Interface冲突，则可以用static修饰。</span><br><span class="line">//因为静态方法和属性可以被继承，但是不能被重写，而是被&quot;隐藏&quot;，直接通过父类名称调用。</span><br><span class="line">    public String test(String str)&#123;</span><br><span class="line">        return &quot;test3&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Test4 extends Test3 implements Test1,Test2&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test4 test = new Test4();</span><br><span class="line">        System.out.println(test.test(&quot;str&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//执行结果</span><br><span class="line">//test3</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><font color="red"><strong>总结</strong></font></h2><blockquote><p><strong>接口冲突：</strong>如果一个类同时实现了具有相同方法签名的接口，则该类必须覆盖该抽象方法。</p><p><strong>超类冲突</strong>：超类和接口提供相同方法签名的方法，此时子类要是不覆盖，则默认调用超类方法。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1551345094255&amp;amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;amp;imgtype=0&amp;amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;Java也有多继承？来看看JDK8的这个新特性！&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>搭建博客时候问题小记</title>
    <link href="https://yoursite.com/2018/12/01/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%97%B6%E5%80%99%E9%97%AE%E9%A2%98%E5%B0%8F%E8%AE%B0/"/>
    <id>https://yoursite.com/2018/12/01/搭建博客时候问题小记/</id>
    <published>2018-12-01T06:48:20.000Z</published>
    <updated>2019-03-22T02:02:56.181Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong>汇总搭建博客遇见的几个问题（持续更新。。。）<br><a id="more"></a></p><h2 id="nothing-added-to-commit-but-untracked-files-present"><a href="#nothing-added-to-commit-but-untracked-files-present" class="headerlink" title="nothing added to commit but untracked files present"></a>nothing added to commit but untracked files present</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;first commit&quot;</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">        .gitignore</span><br><span class="line">        _config.yml</span><br><span class="line">        git</span><br><span class="line">        git.pub</span><br><span class="line">        package-lock.json</span><br><span class="line">        package.json</span><br><span class="line">        scaffolds/</span><br><span class="line">        source/</span><br><span class="line">        themes/</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present</span><br></pre></td></tr></table></figure><p>这个错误原因有两个：</p><ol><li>已经存在的项目？</li><li>没有把需要提交的文件加载进来，所以需要用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add （文件名）</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="fatal-remote-origin-already-exists"><a href="#fatal-remote-origin-already-exists" class="headerlink" title="fatal: remote origin already exists."></a>fatal: remote origin already exists.</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: remote origin already exists.</span><br></pre></td></tr></table></figure><p>用到的解决办法：</p><ol><li><p>删除远程仓库，再添加远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$git remote rm origin</span><br><span class="line"></span><br><span class="line">$git remote add origin git@github.com:wufans/wufans.github.io.git</span><br></pre></td></tr></table></figure></li><li><p>修改git的config文件的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$vi .git/config</span><br></pre></td></tr></table></figure></li></ol><p>删除[remote “origin”]</p><hr><h2 id="github-rejected"><a href="#github-rejected" class="headerlink" title="github rejected"></a>github rejected</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">To github.com:wufans/wufans.github.io.git</span><br><span class="line"> ! [rejected]        master -&gt; master (non-fast-forward)</span><br><span class="line"> &apos;git@github.com:wufans/wufans.github.io.git&apos;</span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: &apos;git pull ...&apos;) before pushing again.</span><br></pre></td></tr></table></figure><p>这个方法就是因为本地仓库和github上面仓库的内容有冲突导致的<br>我用的解决办法是删除了原来的repository，重新建立了一个仓库，问题解决。</p><hr><h2 id="创建流量统计功能的方法"><a href="#创建流量统计功能的方法" class="headerlink" title="创建流量统计功能的方法"></a>创建流量统计功能的方法</h2><p><a href="https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="noopener">参考博客</a></p><hr><h2 id="附加功能的添加"><a href="#附加功能的添加" class="headerlink" title="附加功能的添加"></a>附加功能的添加</h2><p><a href="https://blog.csdn.net/linshuhe1/article/details/52424573" target="_blank" rel="noopener">参考博客</a></p><hr><h2 id="解决公式显示不正常的问题"><a href="#解决公式显示不正常的问题" class="headerlink" title="解决公式显示不正常的问题"></a>解决公式显示不正常的问题</h2><p><a href="https://blog.csdn.net/emptyset110/article/details/50123231" target="_blank" rel="noopener">参考博客</a></p><hr><h2 id="hexo设置侧边栏头像"><a href="#hexo设置侧边栏头像" class="headerlink" title="hexo设置侧边栏头像"></a>hexo设置侧边栏头像</h2><p>编辑站点的 _config.yml，新增字段 avatar， 值设置成头像的链接地址。</p><p>其中，头像的链接地址可以是：</p><p>完整的互联网 URL，例如：<a href="https://avatars1.githubusercontent.com/u/32269?v=3&amp;s=460" target="_blank" rel="noopener">https://avatars1.githubusercontent.com/u/32269?v=3&amp;s=460</a></p><p>站点内的地址，例如：</p><p>/uploads/avatar.jpg 需要将你的头像图片放置在 站点的 source/uploads/（可能需要新建uploads目录）<br>/images/avatar.jpg 需要将你的头像图片放置在 主题的 source/images/ 目录下。</p><hr><h2 id="hexo部署失败，不能连接github的解决"><a href="#hexo部署失败，不能连接github的解决" class="headerlink" title="hexo部署失败，不能连接github的解决"></a>hexo部署失败，不能连接github的解决</h2><p>一直在解决这个问题，修改了本地文件的几个配置之后，突然发现生成的博客不能直接push到github上了，显示错误<br><img src="https://s1.ax1x.com/2018/12/27/F2IkYd.jpg" alt="此处输入图片的描述"><br>但是用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure></p><p>部署到本地的时候是没有问题的。<br>然后用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@gihub.com</span><br></pre></td></tr></table></figure></p><p>测试连接也出现了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh_exchange_identification: read:Connection reset by peer</span><br></pre></td></tr></table></figure></p><p>和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection reset by 192.30.253.112 port 22</span><br></pre></td></tr></table></figure></p><p>这样的错误<br>尝试了以下解决办法：</p><ol><li>因为前几次修改了hosts文件解决github不能加载CSS的问题，让电脑解析github的域名时用的是自定义的IP，所以可能有这个原因，因此在hosts里面注释掉了修改的部分，然后刷新DNS缓存<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /flushdns</span><br><span class="line">#这里还遇到了ipconfig和ping不是一个命令的错误，需要配置环境变量path</span><br><span class="line">#%SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem</span><br></pre></td></tr></table></figure></li></ol><p>最后发现没用。</p><ol><li>删除了github上面的ssh配置，重新配置了github服务器端与本地的ssh秘钥，然后再使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@gihub.com</span><br></pre></td></tr></table></figure></li></ol><p>结果能连上了，但是再用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p><p>之后，又报了刚才的错误，而且再测试与github上面的连接居然也出错了~</p><ol><li>俗话说，重启治百病，于是重启了一下————是的，没用</li><li>用网上的解决办法，可能是网络防火墙设置的原因，用手机给电脑开热点再测试连接，结果也没用<br>最后打算第二天重新部署博客了，然后奇迹发生了，起床之后再测试链接，work~</li></ol><hr><h2 id="Github不能访问、不能正常加载CSS的解决"><a href="#Github不能访问、不能正常加载CSS的解决" class="headerlink" title="Github不能访问、不能正常加载CSS的解决"></a>Github不能访问、不能正常加载CSS的解决</h2><p>修改了windows的hosts文件之后，经常会出现github访问异常，页面的CSS样式无法加载等的情况。<br><strong>解决办法</strong><br>给hosts文件增加github的CDN fastly.net,跳过域名解析，直接通过IP访问github。<br>在hosts文件下增加一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">185.31.17.184 github.global.ssl.fastly.net</span><br></pre></td></tr></table></figure></p><font color="red">**问题**</font><p>使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p><p>部署博客时，出现下列错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fatal: TaskCanceledException encountered.</span><br><span class="line">   ▒▒ȡ▒▒һ▒▒▒▒▒▒</span><br><span class="line">bash: /dev/tty: No such device or address</span><br><span class="line">error: failed to execute prompt script (exit code 1)</span><br><span class="line">fatal: could not read Username for &apos;https://github.com&apos;: No error</span><br><span class="line">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="line">Error: fatal: TaskCanceledException encountered.</span><br><span class="line">   ��ȡ��һ������</span><br><span class="line">bash: /dev/tty: No such device or address</span><br><span class="line">error: failed to execute prompt script (exit code 1)</span><br><span class="line">fatal: could not read Username for &apos;https://github.com&apos;: No error</span><br><span class="line"></span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (D:\blog\GIT\hexo\node_modules\hexo-util\lib\spawn.js:37:17)</span><br><span class="line">    at emitTwo (events.js:125:13)</span><br><span class="line">    at ChildProcess.emit (events.js:213:7)</span><br><span class="line">    at ChildProcess.cp.emit (D:\blog\GIT\hexo\node_modules\cross-spawn\lib\enoent.js:40:29)</span><br><span class="line">    at maybeClose (internal/child_process.js:927:16)</span><br><span class="line">    at Process.ChildProcess._handle.onexit (internal/child_process.js:211:5)</span><br></pre></td></tr></table></figure></p><font color="red">**解决**</font><p>如果开启了本地预览，先关闭<br>然后用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure></p><p>清空缓存，再重新生成静态文件并部署，问题解决~</p><p><font color="red">另外</font><br>用了上面的方法之后还出现了这个问题的话，<big><font color="red">重启</font></big>一下电脑~~</p><h2 id="添加数学公式支持"><a href="#添加数学公式支持" class="headerlink" title="添加数学公式支持"></a>添加数学公式支持</h2><p><a href="https://ranmaosong.github.io/2017/11/29/hexo-support-mathjax/" target="_blank" rel="noopener">参考链接</a></p><h2 id="添加版权声明"><a href="#添加版权声明" class="headerlink" title="添加版权声明"></a>添加版权声明</h2><p>添加版权声明</p><p>在Github上，Next主题的issues上有设置 Creative Commons 协议，这个就是设置版权声明，但是配置了以后图标比较小，没有文字说明（就是没逼格），而且还会出现在它不该出现的地方。</p><h3 id="新建-passage-end-tag-swig-文件"><a href="#新建-passage-end-tag-swig-文件" class="headerlink" title="新建 passage-end-tag.swig 文件"></a>新建 passage-end-tag.swig 文件</h3><p>在路径\themes\next\layout_macro中添加passage-end-tag.swig文件，其内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.passage_end_tag.enabled %&#125;</span><br><span class="line">&lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;</span><br><span class="line">------ 本文结束 ------&lt;/div&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;div style=&quot;border: 1px solid black&quot;&gt;</span><br><span class="line">&lt;div style=&quot;margin-left:10px&quot;&gt;</span><br><span class="line">&lt;span style=&quot;font-weight:blod&quot;&gt;版权声明&lt;/span&gt;</span><br><span class="line">&lt;img src=&quot;http://creativecommons.org/images/deed/logo_deed.gif&quot;&gt;&lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;Fan Wu&apos;s Blog&lt;/a&gt; by &lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;Fan Wu&lt;/a&gt; is licensed under a &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; style=&quot;color:#258FC6&quot;&gt;Creative Commons BY-NC-ND 4.0 International License&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">由&lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;Fan Wu&lt;/a&gt;创作并维护的&lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;Fan Wu&apos;s Blog&lt;/a&gt;博客采用&lt;a href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; style=&quot;color:#258FC6&quot;&gt;创作共用保留署名-非商业-禁止演绎4.0国际许可证&lt;/a&gt;。&lt;br/&gt;</span><br><span class="line">本文首发于&lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;Fan Wu&apos;s Blog&lt;/a&gt; 博客（ &lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;http://wufan.site/&lt;/a&gt; ），版权所有，侵权必究。&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>如果觉得上面的样式不好看，也可以引用下面的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.passage_end_tag.enabled %&#125;</span><br><span class="line">&lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;</span><br><span class="line">-------------本文结束&lt;i class=&quot;fa fa-heart&quot;&gt;&lt;/i&gt;感谢阅读-------------&lt;/div&gt;</span><br><span class="line">&lt;ul class=&quot;post-copyright&quot;&gt;</span><br><span class="line">  &lt;li class=&quot;post-copyright-author&quot;&gt;</span><br><span class="line">      &lt;strong&gt;本文作者:&lt;/strong&gt;&#123;&#123; theme.author &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">  &lt;li class=&quot;post-copyright-link&quot;&gt;</span><br><span class="line">    &lt;strong&gt;本文链接:&lt;/strong&gt;</span><br><span class="line">    &lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.path &#125;&#125;&lt;/a&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">  &lt;li class=&quot;post-copyright-license&quot;&gt;</span><br><span class="line">    &lt;strong&gt;许可协议:&lt;/strong&gt;</span><br><span class="line">    除特殊声明外，本站博文均采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-sa/3.0/cn/&quot; rel=&quot;external nofollow&quot; target=&quot;_blank&quot;&gt;CC BY-NC-SA 4.0 CN&lt;/a&gt; 许可协议，转载请注明出处！</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><h3 id="修改-post-swig-文件"><a href="#修改-post-swig-文件" class="headerlink" title="修改 post.swig 文件"></a>修改 post.swig 文件</h3><p>在\themes\next\layout_macro\post.swig中，post-body之后，post-footer之前添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% if not is_index %&#125;</span><br><span class="line">    &#123;% include &apos;passage-end-tag.swig&apos; %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h3 id="在主题配置文件中添加字段"><a href="#在主题配置文件中添加字段" class="headerlink" title="在主题配置文件中添加字段"></a>在主题配置文件中添加字段</h3><p>在主题配置文件”_config.yml”中添加以下字段开启此功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#文章末尾添加“本文结束”标记</span><br><span class="line">passage_end_tag:</span><br><span class="line">  enabled: true</span><br></pre></td></tr></table></figure><p>完成以上设置之后，在每篇文章之后都会添加“版权声明”标记。</p><h2 id="添加动画效果"><a href="#添加动画效果" class="headerlink" title="添加动画效果"></a>添加动画效果</h2><p>背景动画基于canvas，添加到博客上也比较简单，在\themes\next\layout_layout.swig的&lt;/body&gt;上面添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.canvas_nest %&#125;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>在\themes\next_config.yml中添加以下字段开启此功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># background settings</span><br><span class="line"># add canvas-nest effect</span><br><span class="line"># see detail from https://github.com/hustcc/canvas-nest.js</span><br><span class="line">canvas_nest: true</span><br></pre></td></tr></table></figure></p><p>添加完了，发现博客背景是白色，会遮住动画，只留下两边一点点的位置看到动画效果，这时候可以去设置一下背景颜色，在\themes\next\source\css_schemes\Pisces_layout.styl中，把.content-wrap中的background修改为none。</p><p>这时候如果用手机打开，也能看到动画效果，但是带来的体验不好，显得页面比较乱，这是可以把.content-wrap的+mobile()中的background修改为white，这样手机端的体验就好很多，却又不影响电脑端的炫酷动画。</p><h2 id="解决博客浏览统计功能突然失效的方法（hexo-theme-next-busuanzi-count）"><a href="#解决博客浏览统计功能突然失效的方法（hexo-theme-next-busuanzi-count）" class="headerlink" title="解决博客浏览统计功能突然失效的方法（hexo-theme-next-busuanzi_count）"></a>解决博客浏览统计功能突然失效的方法（hexo-theme-next-busuanzi_count）</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>我这里是使用的hexo-theme-next主题，主题版本为：3.8.0(更新于10-31日)</p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>由于定位到是不蒜子统计功能突然有问题了，所以前往不蒜子官网进行查看，发现官网有一段很重要的提示：<br><strong>“因七牛强制过期『dn-lbstatics.qbox.me』域名，与客服沟通无果，只能更换域名到『busuanzi.ibruce.info』！”</strong><br>所以定位到问题，原来是不蒜子使用的七牛的域名被强制过期。<br>需要把 dn-lbstatics.qbox.me 域名更换为 busuanzi.ibruce.info</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>hexo-theme-next主题中使用了dn-lbstatics.qbox.me域名的文件位置为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">themes\next\layout\_third-party\analytics\busuanzi-counter.swig</span><br></pre></td></tr></table></figure><p>修改busuanzi-counter.swig</p><p>找到如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>重新预览，即可看到不蒜子统计功能已经生效<br><a href="https://blog.csdn.net/qijian2003122/article/details/82987577" target="_blank" rel="noopener">原文</a></p><h2 id="恢复你的博客，只需要三步"><a href="#恢复你的博客，只需要三步" class="headerlink" title="恢复你的博客，只需要三步"></a>恢复你的博客，只需要三步</h2><p><strong>如果你重装了系统或者更换了新电脑/新平台，怎么才能快速恢复原来的博客呢？</strong><br>如果你保留了原来博客文件夹下所有文件，那么恢复博客只需要三步：</p><h3 id="安装必备组件"><a href="#安装必备组件" class="headerlink" title="安装必备组件"></a>安装必备组件</h3><p>包括：安装Git，安装Node.js</p><h3 id="Github配对"><a href="#Github配对" class="headerlink" title="Github配对"></a>Github配对</h3><p>打开git bash，在用户主目录下运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure></p><p>把其中的邮件地址换成自己的邮件地址，然后一路回车,在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥<br>登陆GitHub，打开「Settings」-&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容），最后点击「Add SSH Key」<br>测试是否配对成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>打开git bash客户端，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure></p><p>，开始安装hexo<br>安装成功后，进入你原来的博客目录，就可以用hexo命令进行博客生成和部署啦~</p><h2 id="给博客自定义域名开启Https"><a href="#给博客自定义域名开启Https" class="headerlink" title="给博客自定义域名开启Https"></a>给博客自定义域名开启Https</h2><p><strong>HTTPS</strong>（全称：Hyper Text Transfer Protocol over Secure Socket Layer 或 Hypertext Transfer Protocol Secure，超文本传输安全协议），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。<br>GitHub官方在5月1号宣布，GitHub Pages的自定义域名获得对HTTPS的支持。但是因为自己的域名是自定义的，购于阿里云，因此不能直接在Setting中设置Enforce HTTPS:<br><img src="https://s1.ax1x.com/2018/12/26/F2rlvj.png" alt="此处输入图片的描述"><br>而Github pages不支持SSL证书上传，因此，开启HTTPS需要借助CloudFlare的CDN代理。即用户到CDN服务器的连接为https，而CDN服务器到GithubPage服务器的连接为http，就是在CDN服务器那里加上反向代理。<br><strong>步骤如下：</strong></p><ol><li>首先注册并登陆CloudFlare,在域名购买的地方修改name sever，修改DNS解析地址。（启用动态DNS加速）<br><img src="https://s1.ax1x.com/2018/12/26/F2r3Ks.png" alt="此处输入图片的描述"></li><li>与域名绑定并激活成功后，设置CloudFlare 的 DNS：<br><img src="https://s1.ax1x.com/2018/12/26/F2rdGF.png" alt="此处输入图片的描述"></li><li>设置CloudFlare 的 Crypto：<br><img src="https://s1.ax1x.com/2018/12/26/F2rDM9.png" alt="此处输入图片的描述"></li><li>设置路由规则Page Rules：<br><img src="https://s1.ax1x.com/2018/12/26/F2rsq1.png" alt="此处输入图片的描述"><br>至此，等待一段时间，就可以用https协议访问你的自定义域名<br>为了让博客完全开启Https，还需要修改文章内容中用http协议的链接，比如图片，这样，就能看到浏览器域名旁边的小绿锁啦！<br><img src="https://s1.ax1x.com/2018/12/27/F255Q0.png" alt="此处输入图片的描述"><br>同时，修改了DNS解析服务器后，网站响应速度也更快了！一举两得！</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;汇总搭建博客遇见的几个问题（持续更新。。。）&lt;br&gt;
    
    </summary>
    
      <category term="Guidances" scheme="https://yoursite.com/categories/Guidances/"/>
    
    
      <category term="hexo" scheme="https://yoursite.com/tags/hexo/"/>
    
      <category term="blog" scheme="https://yoursite.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Java的艺术-注解</title>
    <link href="https://yoursite.com/2018/11/28/Java%E7%9A%84%E8%89%BA%E6%9C%AF-%E6%B3%A8%E8%A7%A3%E7%B1%BB%E5%9E%8B(Annotation)/"/>
    <id>https://yoursite.com/2018/11/28/Java的艺术-注解类型(Annotation)/</id>
    <published>2018-11-28T03:08:02.000Z</published>
    <updated>2019-03-26T12:25:11.553Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551345094255&amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;imgtype=0&amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png" alt="此处输入图片的描述"><br>使用注解来进行开发，可以免去写XML配置。那么注解到底是什么呢？</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a><font color="red"><strong>概念</strong></font></h2><p><strong>注解（Annotation）</strong></p><blockquote><p>也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。<br>这些标记和注释可以在编译、类加载、运行时被读取，并执行响应的处理。<br><strong>通俗地讲，注解相当于给类、属性或者方法贴上一个标签。</strong></p></blockquote><p><strong>注解的元注解</strong></p><blockquote><p>元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。<br>元注解有五种：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>、<span class="meta">@Documented</span>、<span class="meta">@Target</span>、<span class="meta">@Inherited</span>、<span class="meta">@Repeatable</span></span><br></pre></td></tr></table></figure></p></blockquote><h2 id="注解的基本用法"><a href="#注解的基本用法" class="headerlink" title="注解的基本用法"></a><font color="red"><strong>注解的基本用法</strong></font></h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>注解通过@interface 关键字定义。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个名为AnnotationTest的注解。</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationTest&#123;&#125;</span><br></pre></td></tr></table></figure></p><h3 id="注解的属性"><a href="#注解的属性" class="headerlink" title="注解的属性"></a>注解的属性</h3><p>注解的属性类似于类的成员变量。并且注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“<strong>无形参的方法</strong>”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。<br>可以通过<font color="red"><strong>default</strong></font>关键字给出默认值。<br>举例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationTest&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "Hello World"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在使用的时候，赋值的方式是在注解的括号内以 <font color="red"><strong>value=””</strong></font>形式，多个属性之间用<font color="red"><strong>“,”</strong></font>隔开。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AnnotationTest</span>(id=<span class="number">0</span>,message=<span class="string">"God"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为属性message有默认值，也可以不赋值</span></span><br><span class="line"><span class="meta">@AnnotationTest</span>(id=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当所有属性都有默认值，括号内为空</span></span><br></pre></td></tr></table></figure></p><p>甚至当注解没有属性时，可以不用括号：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Check &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有属性的注解，不用括号</span></span><br><span class="line"><span class="meta">@Check</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h3><blockquote><p>注解中所有方法（也就是属性）没有方法体，且只允许public和abstract修饰。缺省默认为public，且注解方法不允许有throws子句。</p><p>注解中方法的返回值只能为：基本数据类型，String，Class，美剧类型，注解和他们的一维数组。</p><p>注解的继承只能作用在类上，方法上的注解不会被继承，Interface中的所有注解不会被继承。</p></blockquote><h2 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a><font color="red"><strong>常见注解</strong></font></h2><h3 id="五种元注解"><a href="#五种元注解" class="headerlink" title="五种元注解"></a>五种元注解</h3><p>前面我们提到，Java中有五种元注解。</p><ul><li><p><strong>@Retention</strong></p><blockquote><p>解释说明一个注解的存活时间。取值如下：</p></blockquote><ul><li><strong>RetentionPolicy.SOURCE</strong>        注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。</li><li><strong>RetentionPolicy.CLASS</strong> 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。</li><li><strong>RetentionPolicy.RUNTIME</strong> 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationTest &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>@Documented</strong></p></li></ul><blockquote><p>能够将注解中的元素包含到 Javadoc 中去。</p></blockquote><ul><li><p><strong>@Target</strong></p><blockquote><p>限定注解运用的场景。取值如下：</p></blockquote><ul><li><strong>ElementType.ANNOTATION_TYPE</strong> 可以给一个注解进行注解</li><li><strong>ElementType.CONSTRUCTOR</strong> 可以给构造方法进行注解</li><li><strong>ElementType.FIELD</strong> 可以给属性进行注解</li><li><strong>ElementType.LOCAL_VARIABLE</strong> 可以给局部变量进行注解</li><li><strong>ElementType.METHOD</strong> 可以给方法进行注解</li><li><strong>ElementType.PACKAGE</strong> 可以给一个包进行注解</li><li><strong>ElementType.PARAMETER</strong> 可以给一个方法内的参数进行注解</li><li><strong>ElementType.TYPE</strong> 可以给一个类型进行注解，比如类、接口、枚举</li></ul></li><li><p><strong>@Inherited</strong></p><blockquote><p>如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> Test &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为Test注解被@Inherited注解，所以继承了注解了Test的A类后的B类，也拥有Test这个注解。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>@Repeatable</strong></p><blockquote><p>Repeatable 是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> Persons &#123;</span><br><span class="line">Person[]  value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repeatable</span>(Persons.class)</span><br><span class="line"><span class="meta">@interface</span> Person&#123;</span><br><span class="line">String role <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"artist"</span>)</span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"coder"</span>)</span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"PM"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>@Repeatable 注解了 Person。而 @Repeatable 后面括号中的类相当于一个容器注解。</p><p>什么是<strong>容器注解</strong>呢？就是用来存放其它注解的地方。它本身也是一个注解。</p><p>我们再看看代码中的相关容器注解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> Persons &#123;</span><br><span class="line">Person[]  value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>按照规定，它里面必须要有一个 value 的属性，属性类型是一个被 @Repeatable 注解过的注解数组，注意它是数组。</p><p>可以这样理解。Persons 是一张总的标签，上面贴满了 Person 这种同类型但内容不一样的标签。把 Persons 给一个 SuperMan 贴上，相当于同时给他贴了程序员、产品经理、画家的标签。</p><h3 id="Java预置注解"><a href="#Java预置注解" class="headerlink" title="Java预置注解"></a>Java预置注解</h3><p>Java本身提供了现成的注解。</p><ul><li><p><strong>@Deprecated</strong></p><blockquote><p>用来标记过时的元素。</p></blockquote></li><li><p><strong>@Override</strong></p><blockquote><p>提示子类要复写父类中被@Override 修饰的方法</p></blockquote></li><li><p><strong>@SuppressWarnings</strong></p><blockquote><p>阻止警告。调用被 @Deprecated 注解的方法后，编译器会警告提醒，而有时候开发者会忽略这种警告，他们可以在调用的地方通过 @SuppressWarnings 达到目的。</p></blockquote></li><li><p><strong>@SafeVarargs</strong></p><blockquote><p>参数安全类型注解。它的目的是提醒开发者不要用参数做一些不安全的操作,它的存在会阻止编译器产生 unchecked 这样的警告。它是在 Java 1.7 的版本中加入的。</p></blockquote></li><li><p><strong>@FunctionalInterface</strong></p><blockquote><p>函数式接口注解，这个是 Java 1.8 版本引入的新特性。线程开发中常用的 Runnable 就是一个典型的函数式接口。函数式接口可以很容易转换为 Lambda 表达式。</p></blockquote></li></ul><h2 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a><font color="red"><strong>注解的作用</strong></font></h2><blockquote><p><strong>编译检查</strong> 编译器可以利用注解来探测错误和警告信息；通过代码里标识的元数据让编译器能够实现基本的编译检查【Override】</p><p><strong>编写文档</strong> 软件工具可以用来利用注解信息来生成代码、Html文档或者做其它相应处理。通过代码里标识的元数据生成文档【生成文档doc文档】</p><p><strong>代码分析</strong> 某些注解可以在程序运行的时候接受代码的提取；通过代码里标识的元数据对代码进行分析【使用反射】</p></blockquote><p>总之，当开发者使用了Annotation 修饰了类、方法、Field 等成员之后，这些 Annotation 不会自己生效，必须由开发者提供相应的代码来提取并处理 Annotation 信息。这些处理提取和处理 Annotation 的代码统称为 APT（Annotation Processing Tool)。<br><strong>而注解主要就是给编译器或者APT用的。</strong></p><p>注解也就是代码添加元数据，描述信息。</p><p>相比使用单独的XML来描述这些元数据，使用注解要简单些，和代码在一起也更好维护。相比使用继承（如TesCase）或者方法前缀的约定（如testXXX是测试方法）要灵活些。</p><p></p><p>一些插件机制就是通过注解提供插件的元数据，在加载类后扫描所以带该注解的类就可以找到插件，减少了配置的麻烦。</p><p></p><h2 id="注解的解析-反射"><a href="#注解的解析-反射" class="headerlink" title="注解的解析-反射"></a><font color="red"><strong>注解的解析-反射</strong></font></h2><p>注解的提取（解析）需要借助于 Java 的反射技术，反射比较慢，所以注解使用时也需要谨慎计较时间成本。</p><h3 id="类的注解的解析"><a href="#类的注解的解析" class="headerlink" title="类的注解的解析"></a>类的注解的解析</h3><blockquote><p>首先通过Class对象的isAnnotationPresent()方法判断他是否应用了某个注解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnnotationPresent</span><span class="params">(Class&lt;? extends Annotation&gt; annotationClass)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>然后通过getAnnotation()方法获取Annotation对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;A extends Annotation&gt; <span class="function">A <span class="title">getAnnotation</span><span class="params">(Class&lt;A&gt; annotationClass)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>或者getAnnotations()方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Annotation[] getAnnotations() &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>如果获取到的 Annotation 如果不为 null，则就可以调用它们的属性方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AnnotationTest</span>()</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> hasAnnotation = Test.class.isAnnotationPresent(TestAnnotation.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( hasAnnotation ) &#123;</span><br><span class="line">TestAnnotation testAnnotation = Test.class.getAnnotation(TestAnnotation.class);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"id:"</span>+testAnnotation.id());</span><br><span class="line">System.out.println(<span class="string">"message:"</span>+testAnnotation.message());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>也可以使用forName()方法加载类，使用isAnnotation(Annotation.class)判定对象是否存在注解，并使用getAnnotation(Description.class)得到带有@Description注解的类。</p><h3 id="方法的注解的解析"><a href="#方法的注解的解析" class="headerlink" title="方法的注解的解析"></a>方法的注解的解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@AnnotationTest</span>()</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_method</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        Test my_test = <span class="keyword">new</span> Test();</span><br><span class="line">        Class test_class = Test.class;</span><br><span class="line">        Method method = test_class.getDeclaredMethod(<span class="string">"test_method"</span>,String.class);</span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(AnnotationTest.class)) &#123;</span><br><span class="line">            <span class="comment">//执行方法</span></span><br><span class="line">            method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            method.invoke(my_test, <span class="string">"hello"</span>);</span><br><span class="line">            <span class="comment">//解析注解元素</span></span><br><span class="line">            AnnotationTest a = method.getAnnotation(AnnotationTest.class);</span><br><span class="line">            System.out.println(a.test());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的属性的注解的解析"><a href="#类的属性的注解的解析" class="headerlink" title="类的属性的注解的解析"></a>类的属性的注解的解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@AnnotationTest</span>()</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_method</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        Test my_test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="comment">//利用反射，通过class对象的getDeclaredField(String str)获得元素Field对象</span></span><br><span class="line">        Field test_field = Test.class.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">        <span class="comment">//判断元素是否是注解的对象</span></span><br><span class="line">        <span class="keyword">if</span>(test_field.isAnnotationPresent(AnnotationTest.class))&#123;</span><br><span class="line">            <span class="comment">//修改权限（同一个类内部其实没有必要，肯定有访问权限。）</span></span><br><span class="line">            test_field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//利用Field对象的getXXX()获取实例的值。</span></span><br><span class="line">            System.out.println(test_field.getInt(my_test));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><blockquote><p>一定要用@Retention元注解表示出注解的存活时间，不然在动态执行时可能判定某个类并没有受到注解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationTest &#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">default</span> 2019</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><hr><p><a href="https://www.cnblogs.com/Qian123/p/5256084.html" target="_blank" rel="noopener">参考1</a><br><a href="https://blog.csdn.net/briblue/article/details/73824058" target="_blank" rel="noopener">参考2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1551345094255&amp;amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;amp;imgtype=0&amp;amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;使用注解来进行开发，可以免去写XML配置。那么注解到底是什么呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java的艺术-浅谈反射机制</title>
    <link href="https://yoursite.com/2018/11/25/Java%E7%9A%84%E8%89%BA%E6%9C%AF-%E6%B5%85%E6%9E%90%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>https://yoursite.com/2018/11/25/Java的艺术-浅析反射机制/</id>
    <published>2018-11-25T13:08:02.000Z</published>
    <updated>2019-03-21T16:05:07.434Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551345094255&amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;imgtype=0&amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png" alt="此处输入图片的描述"><br>在运行时发现和使用类的信息 - <strong>Java反射</strong>。</p><a id="more"></a><h2 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h2><p>通俗的解释是：JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p><h2 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h2><p>动态语言，是指程序在运行时可以改变其结构：新的函数可以被引进，已有的函数可以被删除等在结构上的变化。</p><h2 id="反射的作用"><a href="#反射的作用" class="headerlink" title="反射的作用"></a>反射的作用</h2><p><a href="https://zhuanlan.zhihu.com/p/32259566" target="_blank" rel="noopener">参考</a><br>假设我们有很多食材需要处理，猪肉，牛肉，羊肉；每一样食材对应一个类，这个类里面有处理食材的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pork</span></span>&#123;     <span class="comment">//猪肉</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"cook pork"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Beef</span></span>&#123;     <span class="comment">//牛肉</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"cook beef"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mutton</span></span>&#123;    <span class="comment">//羊肉</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"cook mutton"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当我们在程序中需要根据食材的不同来实例化对应类的对象，再调用对应的方法要怎么做呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       String food=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(food.equals(<span class="string">"Pork"</span>))&#123;</span><br><span class="line">                Pork pork=<span class="keyword">new</span> Pork();</span><br><span class="line">                pork.cook();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(food.equals(<span class="string">"Beef"</span>))&#123;</span><br><span class="line">Beef beef=<span class="keyword">new</span> Beef();</span><br><span class="line">beef.cook();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(food.equals(<span class="string">"Mutton"</span>))&#123;</span><br><span class="line">Mutton mutton=<span class="keyword">new</span> Mutton();</span><br><span class="line">mutton.cook();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上的做法是很容易想到的，很直观，但是当我们的食材有几十种甚至上百种时，我们要怎么写上百个if else 来判断食材，再实例化对应的类，调用对应的方法。</p><p>有没有更简单的方法？答案是肯定的，我们可以利用反射机制来完成这一工作，在程序运行时根据类名实例化对应的对象，并调用对应的方法</p><p>步骤如下：</p><p>1、首先我们需要用到接口:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFood</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、所有的食材类实现这一接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pork</span> <span class="keyword">implements</span> <span class="title">IFood</span></span>&#123;     <span class="comment">//猪肉</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"cook pork"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Beef</span> <span class="keyword">implements</span> <span class="title">IFood</span></span>&#123;     <span class="comment">//牛肉</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"cook beef"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mutton</span> <span class="keyword">implements</span> <span class="title">IFood</span></span>&#123;    <span class="comment">//羊肉</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"cook mutton"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3、接下来我们看看怎么使程序更为简单<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">         String food=<span class="string">"Pork"</span>;                 <span class="comment">//字符串food代表食物的类</span></span><br><span class="line">         Class c=Class.forName(food);        <span class="comment">//根据字符串food来载入类对象</span></span><br><span class="line">         Object object=c.newInstance();      <span class="comment">//生成对象</span></span><br><span class="line">         IFood Ifood=(IFood)object;          <span class="comment">//强制转型</span></span><br><span class="line">         Ifood.cook();                       <span class="comment">//调用方法</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如此一来我们不需要写冗杂的if else 嵌套了</p><p>只需要利用 Class.forName()方法根据字符串来实例化对应的类，并调用其方法即可。</p><p>当我们需要处理其他的食材的时候只需要添加对应的类即可，而主程序中可以不改变一行代码。</p><h2 id="反射的应用"><a href="#反射的应用" class="headerlink" title="反射的应用"></a>反射的应用</h2><h3 id="Class对象的获取"><a href="#Class对象的获取" class="headerlink" title="Class对象的获取"></a>Class对象的获取</h3><p>加载完类之后, 在堆内存中会产生一个Class类型的对象(一个类只有一个Class对象), 这个对象包含了完整的类的结构信息,而且这个Class对象就像一面镜子,透过这个镜子看到类的结构,所以被称之为:<strong>反射。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line">--java.lang.Class&lt;T&gt;</span><br></pre></td></tr></table></figure></p><p>获取Class对象的方法一般有三种方法：</p><blockquote><p>调用<strong>对象</strong>的getClass()方法;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"test"</span>);</span><br><span class="line">Class&lt;?&gt; class1 = sb.getClass();</span><br></pre></td></tr></table></figure></p><p><strong>类名</strong>的.class(最安全/性能最好)属性，或者TYPE属性(继承自Object类);<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; class1 = <span class="keyword">int</span>.class;</span><br><span class="line">Class&lt;?&gt; class2 = Integer.class;</span><br><span class="line">Class&lt;?&gt; class3 = Integer.TYPE;</span><br></pre></td></tr></table></figure></p><p>运用<strong>Class.forName(String className)</strong>动态加载类,className需要是类的全限定名(最常用)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; class1 = Class.forName(<span class="string">"Integer"</span>);</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="创建实例化对象"><a href="#创建实例化对象" class="headerlink" title="创建实例化对象"></a>创建实例化对象</h3><p>得到了对应java.lang.Class对象，有两种方法通过反射生成对象：[<strong>都需要抛出异常</strong>]</p><blockquote><p>使用Class对象的newInstance()方法来创建该Class对象对应类的实例(这种方式要求该Class对象的对应类有默认构造器)；<strong>相当于无参构造</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; class1 = String.class;</span><br><span class="line">Object str = c.newInstance();</span><br></pre></td></tr></table></figure></p><p>先使用Class对象获取指定的Constructor对象, 再调用Constructor对象的newInstance()方法来创建该Class对象对应类的实例(通过这种方式可以选择指定的构造器来创建实例).<strong>适用于无参和有参的构造方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span></span></span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取String所对应的Class对象</span></span><br><span class="line">Class&lt;?&gt; c = String.class;</span><br><span class="line"><span class="comment">//获取String类带一个String参数的构造器</span></span><br><span class="line">Constructor constructor = c.getConstructor(String.class);</span><br><span class="line"><span class="comment">//根据构造器创建实例</span></span><br><span class="line">Object obj = constructor.newInstance(<span class="string">"test"</span>);</span><br></pre></td></tr></table></figure><p>另外可以用getConstructors()方法返回Constructor对象的一个数组。这些对象反映此 Class 对象所表示的类的所有公共构造方法。如果该类没有公共构造方法，或者该类是一个数组类，或者该类反映一个基本类型或 void，则返回一个长度为 0 的数组。 注意，此方法返回 Constructor<t> 对象的数组（即取自此类构造方法的数组）时，此方法的返回类型是 Constructor&lt;?&gt;[]，不是预期的 Constructor<t>[]。此少量信息的返回类型是必需的，因为从此方法返回之后，该数组可能被修改以保存不同类的 Constructor 对象，而这将违反 Constructor<t>[] 的类型保证。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = String.class;<span class="comment">//获取Class对象</span></span><br><span class="line">Constructor&lt;?&gt; cons[] = c.getConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor&lt;?&gt; constructor : cons) &#123;</span><br><span class="line">    System.out.println(constructor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></t></t></p><p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">byte</span>[],<span class="keyword">int</span>,<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">byte</span>[],java.nio.charset.Charset)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">byte</span>[],java.lang.String) <span class="keyword">throws</span> java.io.UnsupportedEncodingException</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">byte</span>[],<span class="keyword">int</span>,<span class="keyword">int</span>,java.nio.charset.Charset)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">byte</span>[],<span class="keyword">int</span>,<span class="keyword">int</span>,java.lang.String) <span class="keyword">throws</span> java.io.UnsupportedEncodingException</span><br><span class="line"><span class="keyword">public</span> java.lang.String(java.lang.StringBuilder)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(java.lang.StringBuffer)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">byte</span>[])</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">int</span>[],<span class="keyword">int</span>,<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> java.lang.String()</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">char</span>[])</span><br><span class="line"><span class="keyword">public</span> java.lang.String(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">char</span>[],<span class="keyword">int</span>,<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">byte</span>[],<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">byte</span>[],<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure></p><p>此外，还可以用getDeclaredConstructors()方法获取所有的构造方法。</p><blockquote><p><strong>getConstructor()和getDeclaredConstructor()区别:</strong></p><p>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)<br>这个方法会返回制定参数类型的所有构造器，包括public的和非public的，当然也包括private的。<br>getDeclaredConstructors()的返回结果就没有参数类型的过滤了。</p><p>getConstructor(Class&lt;?&gt;… parameterTypes)<br>这个方法返回的是getDeclaredConstructor()方法返回结果的子集，只返回制定参数类型访问权限是public的构造器。<br>getConstructors()的返回结果同样也没有参数类型的过滤。</p><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><p>获取某个Class对象的方法集合，主要有以下几种方法：</p><p>getDeclaredMethods方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure></p><p>getMethods方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method[] getMethods() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure></p><p>getMethod 方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为<font color="red"><strong>方法的参数对应Class的对象</strong></font>。<br>注意：如果不带方法参数对应的class对象，则无法根据方法名获取对应的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></span><br></pre></td></tr></table></figure></p></blockquote><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><blockquote><p>当我们从类中获取了一个方法后，我们就可以用 invoke() 方法来调用这个方法。invoke 方法的原型为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span> <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException</span></span><br></pre></td></tr></table></figure></p></blockquote><p><strong>invoke回调流程示例：</strong></p><ul><li><p>由Class对象动态构造对应类型对象；</p></li><li><p>利用Class对象的getMethod()、getMethods()、getDeclaredMethod()、getDeclaredMethods()等方法构造method对象；</p></li><li><p>类型对象，使其执行对应形参的方法（也就是需要传入一个<strong>动态执行方法的对象</strong>，以及<strong>对应方法的形参</strong>）。</p></li></ul><p>举例：(利用反射调用String对象的toString()方法)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class test = String.class;</span><br><span class="line">Object ob = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">Method me = test.getDeclaredMethod(<span class="string">"toString"</span>);</span><br><span class="line">System.out.println(me.invoke(ob,<span class="keyword">null</span>));</span><br></pre></td></tr></table></figure></p><p><strong>invoke()的缺点:</strong></p><ul><li><p>invoke的参数和返回值必需时Object类型的，这意味着必须进行多次的类型转换（特别是基本数据类型），而这将导致编译器错过检查代码的机会，有类型安全的风险，只有到了测试阶段才会发现这些错误，此时找到并改正他们将会更加困难。</p></li><li><p>使用反射获得方法指针的代码要比仅仅直接调用方法明显慢一些。</p></li><li><p>因此仅在必要时才使用Method对象，而最好使用<strong>接口和内部类</strong>，不建议Java开发者使用Method对象的回调功能，使用接口进行回调不仅会使代码的运行速度更快，还更易于维护。</p></li></ul><h3 id="访问成员变量"><a href="#访问成员变量" class="headerlink" title="访问成员变量"></a>访问成员变量</h3><p>通过Class对象的的getField()方法可以获取该类所包含的全部或指定的成员变量Field,Filed提供了如下两组方法来读取和设置成员变量值：<br><strong>getFiled：</strong>访问公有的成员变量<br><strong>getDeclaredField：</strong>所有已声明的成员变量，但不能得到其父类的成员变量</p><blockquote><p>getXxx(Object obj): 获取obj对象的该成员变量的值, 此处的Xxx对应8中基本类型,如果该成员变量的类型是引用类型, 则取消get后面的Xxx;<br>setXxx(Object obj, Xxx val): 将obj对象的该成员变量值设置成val值.此处的Xxx对应8种基本类型, 如果该成员类型是引用类型, 则取消set后面的Xxx;</p></blockquote><p><font color="red">注: getDeclaredXxx方法可以获取所有的成员变量,无论private/public</font>;</p><h2 id="反射与Spring框架设计"><a href="#反射与Spring框架设计" class="headerlink" title="反射与Spring框架设计"></a>反射与Spring框架设计</h2><p>反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射，运行时动态加载需要加载的对象。</p><p>Spring内部采用了很多反射机制。<br>很多web框架的前端，实现URI请求映射到Action方法，也可以简单的通过反射来做。<br>这部分内容后面再单独补充。</p><h2 id="反射存在的问题"><a href="#反射存在的问题" class="headerlink" title="反射存在的问题"></a><a href="https://www.sczyh30.com/posts/Java/java-reflection-1/" target="_blank" rel="noopener">反射存在的问题</a></h2><ol><li>由于反射会<strong>额外消耗一定的系统资源</strong>，因此如果不需要动态地创建一个对象，那么就不需要用反射。</li><li>另外，反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致<strong>安全问题</strong>。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1551345094255&amp;amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;amp;imgtype=0&amp;amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;在运行时发现和使用类的信息 - &lt;strong&gt;Java反射&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>算法之美-二叉树的遍历</title>
    <link href="https://yoursite.com/2018/10/21/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <id>https://yoursite.com/2018/10/21/算法之美-二叉树的遍历/</id>
    <published>2018-10-21T08:01:01.000Z</published>
    <updated>2019-03-21T16:10:23.711Z</updated>
    
    <content type="html"><![CDATA[<p>前序？后序？层序？递归？一问看尽二叉树应该怎么遍历。<br><a id="more"></a></p><h2 id="二叉树的定义："><a href="#二叉树的定义：" class="headerlink" title="二叉树的定义："></a>二叉树的定义：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: WuFan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/3/6 22:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> offer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> BinaryTreeNode left;</span><br><span class="line">    <span class="keyword">private</span> BinaryTreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode</span><span class="params">(<span class="keyword">int</span> data, BinaryTreeNode left, BinaryTreeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(BinaryTreeNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(BinaryTreeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的遍历："><a href="#二叉树的遍历：" class="headerlink" title="二叉树的遍历："></a>二叉树的遍历：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: WuFan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/3/6 22:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> offer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前序遍历递归的方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>!=root)&#123;</span><br><span class="line">            System.out.print(root.getData()+<span class="string">"\t"</span>);</span><br><span class="line">            preOrder(root.getLeft());</span><br><span class="line">            preOrder(root.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历非递归的方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderNonRecursive</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">        Stack&lt;BinaryTreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;BinaryTreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.print(root.getData()+<span class="string">"\t"</span>);</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root=root.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty()) <span class="keyword">break</span>;</span><br><span class="line">            root=stack.pop();</span><br><span class="line">            root=root.getRight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历采用递归的方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>!=root)&#123;</span><br><span class="line">            inOrder(root.getLeft());</span><br><span class="line">            System.out.print(root.getData()+<span class="string">"\t"</span>);</span><br><span class="line">            inOrder(root.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历采用非递归的方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderNonRecursive</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">        Stack&lt;BinaryTreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;BinaryTreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root=root.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty())<span class="keyword">break</span>;</span><br><span class="line">            root=stack.pop();</span><br><span class="line">            System.out.print(root.getData()+<span class="string">"\t"</span>);</span><br><span class="line">            root=root.getRight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历采用递归的方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            postOrder(root.getLeft());</span><br><span class="line">            postOrder(root.getRight());</span><br><span class="line">            System.out.print(root.getData()+<span class="string">"\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历采用非递归的方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderNonRecursive</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">        Stack&lt;BinaryTreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;BinaryTreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root=root.getLeft();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span>==stack.lastElement().getRight())&#123;</span><br><span class="line">                    root=stack.pop();</span><br><span class="line">                    System.out.print(root.getData()+<span class="string">"\t"</span>);</span><br><span class="line">                    <span class="keyword">while</span>(root==stack.lastElement().getRight())&#123;</span><br><span class="line">                        System.out.print(stack.lastElement().getData()+<span class="string">"\t"</span>);</span><br><span class="line">                        root=stack.pop();</span><br><span class="line">                        <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(!stack.isEmpty())</span><br><span class="line">                    root=stack.lastElement().getRight();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    root=<span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//层序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">        BinaryTreeNode temp;</span><br><span class="line">        Queue&lt;BinaryTreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;BinaryTreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            temp=queue.poll();</span><br><span class="line">            System.out.print(temp.getData()+<span class="string">"\t"</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span>!=temp.getLeft())</span><br><span class="line">                queue.offer(temp.getLeft());</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span>!=temp.getRight())&#123;</span><br><span class="line">                queue.offer(temp.getRight());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinaryTreeNode node10=<span class="keyword">new</span> BinaryTreeNode(<span class="number">10</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        BinaryTreeNode node8=<span class="keyword">new</span> BinaryTreeNode(<span class="number">8</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        BinaryTreeNode node9=<span class="keyword">new</span> BinaryTreeNode(<span class="number">9</span>,<span class="keyword">null</span>,node10);</span><br><span class="line">        BinaryTreeNode node4=<span class="keyword">new</span> BinaryTreeNode(<span class="number">4</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        BinaryTreeNode node5=<span class="keyword">new</span> BinaryTreeNode(<span class="number">5</span>,node8,node9);</span><br><span class="line">        BinaryTreeNode node6=<span class="keyword">new</span> BinaryTreeNode(<span class="number">6</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        BinaryTreeNode node7=<span class="keyword">new</span> BinaryTreeNode(<span class="number">7</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        BinaryTreeNode node2=<span class="keyword">new</span> BinaryTreeNode(<span class="number">2</span>,node4,node5);</span><br><span class="line">        BinaryTreeNode node3=<span class="keyword">new</span> BinaryTreeNode(<span class="number">3</span>,node6,node7);</span><br><span class="line">        BinaryTreeNode node1=<span class="keyword">new</span> BinaryTreeNode(<span class="number">1</span>,node2,node3);</span><br><span class="line"></span><br><span class="line">        BinaryTree tree=<span class="keyword">new</span> BinaryTree();</span><br><span class="line">        <span class="comment">//采用递归的方式进行遍历</span></span><br><span class="line">        System.out.println(<span class="string">"-----前序遍历------"</span>);</span><br><span class="line">        tree.preOrder(node1);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//采用非递归的方式遍历</span></span><br><span class="line">        tree.preOrderNonRecursive(node1);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//采用递归的方式进行遍历</span></span><br><span class="line">        System.out.println(<span class="string">"-----中序遍历------"</span>);</span><br><span class="line">        tree.inOrder(node1);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//采用非递归的方式遍历</span></span><br><span class="line">        tree.inOrderNonRecursive(node1);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//采用递归的方式进行遍历</span></span><br><span class="line">        System.out.println(<span class="string">"-----后序遍历------"</span>);</span><br><span class="line">        tree.postOrder(node1);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//采用非递归的方式遍历</span></span><br><span class="line">        tree.postOrderNonRecursive(node1);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//采用递归的方式进行遍历</span></span><br><span class="line">        System.out.println(<span class="string">"-----层序遍历------"</span>);</span><br><span class="line">        tree.levelOrder(node1);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前序？后序？层序？递归？一问看尽二叉树应该怎么遍历。&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="https://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="algorithms" scheme="https://yoursite.com/tags/algorithms/"/>
    
      <category term="Java算法" scheme="https://yoursite.com/tags/Java%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java并发(2)-线程池</title>
    <link href="https://yoursite.com/2018/10/09/Java%E5%B9%B6%E5%8F%91(2)-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://yoursite.com/2018/10/09/Java并发(2)-线程池/</id>
    <published>2018-10-09T10:48:20.000Z</published>
    <updated>2019-04-07T07:12:39.650Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551345094255&amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;imgtype=0&amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png" alt="此处输入图片的描述"><br>本文介绍Java中线程池的相关概念和部分源码解析。<br><a id="more"></a></p><h2 id="一、为什么需要线程池？"><a href="#一、为什么需要线程池？" class="headerlink" title="一、为什么需要线程池？"></a>一、为什么需要线程池？</h2><blockquote><p>因为服务器需要接受并处理请求，通常会给每一个请求分配一个线程来处理，假设每次请求都创建一个线程，如果并发的请求数量非常多，但每个线程执行的时间很短，这样就会频繁的创建和销毁线程，如此一来会大大降低系统的效率。可能出现服务器在为每个请求创建新线程和销毁线程上花费的时间和消耗的系统资源要比处理实际的用户请求的时间和资源更多。</p><p>线程池具有以下优点：</p></blockquote><ul><li><strong>线程复用，降低资源消耗</strong>：重用线程池中的线程,减少因对象创建,销毁所带来的性能开销;</li><li><strong>控制并发数量，提高响应速度</strong>：能有效的控制线程的最大并发数,提高系统资源利用率,同时避免过多的资源竞争,避免堵塞;</li><li><strong>提高线程的可管理性</strong>：能够对线程进行简单的管理并提供定时执行、间隔执行、单线程、并发数控制等功能,使线程的使用简单、高效。</li></ul><h2 id="二、线程池原理"><a href="#二、线程池原理" class="headerlink" title="二、线程池原理"></a>二、线程池原理</h2><h3 id="线程池的特点"><a href="#线程池的特点" class="headerlink" title="线程池的特点"></a>线程池的特点</h3><blockquote><p>（1）线程复用：实现线程复用的原理应该就是要保持线程处于存活状态（就绪，运行或阻塞）</p><p>（2）控制并发数量：（核心线程和最大线程数控制）</p><p>（3）管理线程（设置线程的状态）</p></blockquote><h3 id="当往线程池中添加任务时"><a href="#当往线程池中添加任务时" class="headerlink" title="当往线程池中添加任务时"></a>当往线程池中添加任务时</h3><blockquote><p>(1)线程数量未达到corePoolSize，则新建一个线程(核心线程)执行任务;</p><p>(2)线程数量达到了corePoolSize，则将任务移入队列等待空闲线程将其取出去执行（通过getTask()方法从阻塞队列中获取等待的任务，如果队列中没有任务，getTask方法会被阻塞并挂起，不会占用cpu资源，整个getTask操作在自旋下完成）</p><p>(4)队列已满，新建线程(非核心线程)执行任务</p><p>(5)队列已满，总线程数又达到了maximumPoolSize，就会执行任务拒绝策略。</p></blockquote><h3 id="线程池状态：一共五种"><a href="#线程池状态：一共五种" class="headerlink" title="线程池状态：一共五种"></a>线程池状态：一共五种</h3><blockquote><p>RUNNING ：能接受新提交的任务，并且也能处理阻塞队列中的任务；</p><p>SHUTDOWN：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 RUNNING 状态时，调用shutdown()方法会使线程池进入到该状态。（finalize()方法在执行过程中也会调用shutdown()方法进入该状态）；</p><p>STOP：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态；</p><p>TIDYING：如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态。</p><p>TERMINATED：在terminated() 方法执行完后进入该状态，默认terminated()方法中什么也没有做。<br>进入TERMINATED的条件如下：</p><ul><li>线程池不是RUNNING状态；</li><li>线程池状态不是TIDYING状态或TERMINATED状态；</li><li>如果线程池状态是SHUTDOWN并且workerQueue为空；</li><li>workerCount为0；</li><li>设置TIDYING状态成功。</li></ul></blockquote><h2 id="三、Executor框架接口"><a href="#三、Executor框架接口" class="headerlink" title="三、Executor框架接口"></a>三、Executor框架接口</h2><p>  <img src="https://user-gold-cdn.xitu.io/2017/4/22/8f025e56062328e4ac36e3c988e30d27?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="此处输入图片的描述"></p><p><code>JUC(Java.util.concurrent)</code>中一共有三个Executor接口：</p><blockquote><p><code>Executor</code>：一个运行新任务的简单接口；</p><p><code>ExecutorService</code>：扩展了<code>Executor</code>接口。添加了一些用来管理执行器生命周期和任务生命周期的方法；</p><p><code>ScheduledExecutorService</code>：扩展了<code>ExecutorService</code>。支持Future和定期执行任务。</p></blockquote><h3 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a>Executor接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用execute方法替代创建或者启动线程的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread();</span><br><span class="line">executor.execute(t);</span><br></pre></td></tr></table></figure></p><h3 id="ExecutorService接口"><a href="#ExecutorService接口" class="headerlink" title="ExecutorService接口"></a>ExecutorService接口</h3><p>ExecutorService接口继承自Executor接口，提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成 <code>Future</code>的方法。增加了<code>shutDown()</code>，<code>shutDownNow()</code>，<code>invokeAll()</code>，<code>invokeAny()</code>和<code>submit()</code>等方法。如果需要支持即时关闭，也就是shutDownNow()方法，则任务需要正确处理中断。</p><h3 id="ScheduledExecutorService接口"><a href="#ScheduledExecutorService接口" class="headerlink" title="ScheduledExecutorService接口"></a>ScheduledExecutorService接口</h3><p>ScheduledExecutorService扩展ExecutorService接口并增加了<code>schedule</code>方法。调用schedule方法可以在指定的延时后执行一个<code>Runnable</code>或者<code>Callable</code>任务。ScheduledExecutorService接口还定义了按照指定时间间隔定期执行任务的<code>scheduleAtFixedRate()</code>方法和<code>scheduleWithFixedDelay()</code>方法。</p><h2 id="四、ThreadPoolExecutor类"><a href="#四、ThreadPoolExecutor类" class="headerlink" title="四、ThreadPoolExecutor类"></a>四、<strong>ThreadPoolExecutor类</strong></h2><p><code>ThreadPoolExecutor</code>继承自<code>AbstractExecutorService</code>，实现了<code>ExecutorService</code>接口。</p><h3 id="重要字段"><a href="#重要字段" class="headerlink" title="重要字段"></a>重要字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><blockquote><p><code>ctl</code>是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它包含两部分的信息: 线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，使用了Integer类型来保存，高3位保存<code>runState</code>，低29位保存<code>workerCount</code>。<code>COUNT_BITS</code> 就是29，<code>CAPACITY</code>就是1左移29位减1（29个1），这个常量表示<code>workerCount</code>的上限值，大约是5亿。</p></blockquote><h3 id="ThreadPoolExecutor构造方法"><a href="#ThreadPoolExecutor构造方法" class="headerlink" title="ThreadPoolExecutor构造方法"></a>ThreadPoolExecutor构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>构造方法的各个字段意义如下：</strong></p><blockquote><p><code>corePoolSize</code>：核心线程数（最小存活的工作线程数量）</p><p><code>maxPoolSize</code>：最大线程数</p><p><code>keepAliveTime</code>：线程存活时间（在corePoreSize&lt;maxPoolSize情况下有用,线程的空闲时间超过了keepAliveTime就会销毁）</p><p><code>timeUnit</code>：存活时间的时间单位</p><p><code>workQueue</code>：阻塞队列，用来保存等待被执行的任务（①<strong>synchronousQueue</strong>：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务；②<strong>LinkedBlockingQueue</strong>：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；③<strong>ArrayBlockingQueue</strong>：基于数组的先进先出队列，此队列创建时必须指定大小）</p><p><code>threadFactory</code>：线程工厂，主要用来创建线程；</p><p><code>handler</code>：表示当拒绝处理任务时的策略（线程池提供了4种策略，都实现了<code>RejectedExecutionHandler</code>接口:<br><strong>AbortPolicy</strong>：直接抛出异常，这是默认策略；<br><strong>CallerRunsPolicy</strong>：用调用者所在的线程来执行任务；<br><strong>DiscardOldestPolicy</strong>：丢弃阻塞队列中靠最前的任务，并执行当前任务；<br><strong>DiscardPolicy</strong>：直接丢弃任务；）</p></blockquote><h3 id="重要的方法"><a href="#重要的方法" class="headerlink" title="重要的方法"></a>重要的方法</h3><blockquote><p><code>execute()</code><br>Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。<br><strong>适合不关注返回值的场景。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        pool.execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>submit()</code><br>在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor中并没有对其进行重写，这个方法也是用来向线程池提交任务的，实际上它还是调用的execute()方法，只不过它利用了Future来获取任务执行结果。<br><strong>适用于需要关注返回值的场景.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">　　...</span><br><span class="line">　　&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">　　&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">　　Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">　　...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>shutdown()</code><br>不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务。</p><p><code>shutdownNow()</code><br>立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务。</p></blockquote><h3 id="判断线程池线程是否执行完"><a href="#判断线程池线程是否执行完" class="headerlink" title="判断线程池线程是否执行完"></a>判断线程池线程是否执行完</h3><blockquote><p><code>isTerminated()</code><br>调用<code>ExecutorService.shutdown()</code>方法的时候，线程池不再接收任何新任务，但此时线程池并不会立刻退出，直到添加到线程池中的任务都已经处理完成，才会退出。在调用<code>shutdown</code>方法后我们可以在一个死循环里面用<code>isTerminated()</code>方法判断是否线程池中的所有线程已经执行完毕，如果子线程都结束了，我们就可以做关闭流等后续操作了。</p><p><code>使用闭锁(CountDownLatch)</code><br>CountDownLatch是一种灵活的闭锁实现，它可以使一个或多个线程等待一组事件发生。闭锁状态包括一个计数器，该计数器被初始化为一个正数，表示需要等待的事件数量。countDown方法递减计数器，表示有一个事件已经发生了，而await方法等待计数器达到零，即表示需要等待的事情都已经发生。</p><p><code>使用信号量机制</code></p></blockquote><h2 id="五、常见的四种线程池的用法"><a href="#五、常见的四种线程池的用法" class="headerlink" title="五、常见的四种线程池的用法"></a>五、常见的四种线程池的用法</h2><blockquote><p>Java通过Executors类提供四种线程池</p></blockquote><h3 id="1-CachedThreadPool-可缓存线程池"><a href="#1-CachedThreadPool-可缓存线程池" class="headerlink" title="1. CachedThreadPool()-可缓存线程池"></a>1. CachedThreadPool()-可缓存线程池</h3><p><code>newCachedThreadPool</code>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>,</span><br><span class="line">    Integer.MAX_VALUE,</span><br><span class="line">    <span class="number">60L</span>,</span><br><span class="line">    TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种线程池内部没有核心线程，线程的数量是有没限制的。</p><p>在创建任务时，若有空闲的线程时则复用空闲的线程，若没有则新建线程。没有工作的线程（闲置状态）在超过了60S还不做事，就会销毁。</p></blockquote><p><strong>适用：执行很多短期异步的小程序或者负载较轻的服务器。</strong></p><h3 id="2-FixedThreadPool-定长线程池"><a href="#2-FixedThreadPool-定长线程池" class="headerlink" title="2. FixedThreadPool()-定长线程池"></a>2. FixedThreadPool()-定长线程池</h3><p><code>newFixedThreadPool</code>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">    nThreads,</span><br><span class="line">    nThreads,</span><br><span class="line">    <span class="number">0L</span>,</span><br><span class="line">    TimeUnit.MILLISECONDS,</span><br><span class="line">    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());     </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>该线程池的最大线程数等于核心线程数，所以在默认情况下，该线程池的线程不会因为闲置状态超时而被销毁。</p><p>如果当前线程数小于核心线程数，并且也有闲置线程的时候提交了任务，这时也不会去复用之前的闲置线程，会创建新的线程去执行任务。如果当前执行任务数大于了核心线程数，大于的部分就会进入队列等待。等着有闲置的线程来执行这个任务。</p></blockquote><p><strong>适用：执行长期的任务，性能好很多。</strong></p><h3 id="3-SingleThreadPool-单线程池"><a href="#3-SingleThreadPool-单线程池" class="headerlink" title="3. SingleThreadPool()-单线程池"></a>3. SingleThreadPool()-单线程池</h3><p><code>newSingleThreadExecutor</code>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService(</span><br><span class="line">      <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">      <span class="number">1</span>,</span><br><span class="line">      <span class="number">1</span>,</span><br><span class="line">      <span class="number">0L</span>,                    </span><br><span class="line">      TimeUnit.MILLISECONDS,</span><br><span class="line">      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有且仅有一个工作线程执行任务</p><p>所有任务按照指定顺序执行，即遵循队列的入队出队规则。</p></blockquote><p><strong>适用：一个任务一个任务执行的场景。</strong></p><h3 id="4-ScheduledThreadPool-调度线程池"><a href="#4-ScheduledThreadPool-调度线程池" class="headerlink" title="4. ScheduledThreadPool()-调度线程池"></a>4. ScheduledThreadPool()-调度线程池</h3><p><code>newScheduledThreadPool</code>创建一个定长线程池，支持定时及周期性任务执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;            </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中<code>ScheduledThreadPoolExecutor()</code>的构造方法为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize,</span><br><span class="line">        Integer.MAX_VALUE,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        NANOSECONDS,</span><br><span class="line">        <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样是用到了父类<code>ThreadPoolExecutor</code>的构造方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize,</span><br><span class="line">    maximumPoolSize,</span><br><span class="line">    keepAliveTime,</span><br><span class="line">    unit,</span><br><span class="line">    workQueue,</span><br><span class="line">    Executors.defaultThreadFactory(),</span><br><span class="line">    defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><code>DEFAULT_KEEPALIVE_MILLIS</code>就是默认10L，这里就是10秒。这个线程池有点像是<code>CachedThreadPool</code>和<code>FixedThreadPool</code> 结合了一下。</p><p>不仅设置了核心线程数，最大线程数也是Integer.MAX_VALUE。</p><p>这个线程池是上述4个中唯一一个有延迟执行和周期执行任务的线程池。</p></blockquote><p><strong>适用：周期性执行任务的场景（定期的同步数据）</strong></p><hr><p><strong>参考链接</strong>：<br><a href="https://juejin.im/entry/58fada5d570c350058d3aaad" target="_blank" rel="noopener">深入理解 Java 线程池：ThreadPoolExecutor</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1551345094255&amp;amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;amp;imgtype=0&amp;amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;本文介绍Java中线程池的相关概念和部分源码解析。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Java源码" scheme="https://yoursite.com/tags/Java%E6%BA%90%E7%A0%81/"/>
    
      <category term="Java并发" scheme="https://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java的艺术-数据类型详解</title>
    <link href="https://yoursite.com/2018/10/07/Java%E7%9A%84%E8%89%BA%E6%9C%AF-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://yoursite.com/2018/10/07/Java的艺术-数据类型/</id>
    <published>2018-10-07T06:48:20.000Z</published>
    <updated>2019-03-21T16:05:03.383Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551345094255&amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;imgtype=0&amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png" alt="此处输入图片的描述"></p><p><strong>一文道尽Java数据类型怎么用。</strong><br><a id="more"></a></p><h2 id="一、什么是数据类型"><a href="#一、什么是数据类型" class="headerlink" title="一、什么是数据类型"></a><font color="red">一、什么是数据类型</font></h2><p>　　数据类型在计算机语言里面，是对内存位置的一个抽象表达方式，可以理解为针对内存的一种抽象的表达方式。<br>　　Java是强类型语言，所以Java对于数据类型的规范会相对严格。数据类型是语言的抽象原子概念，可以说是语言中最基本的单元定义，在Java里面，本质上讲将数据类型分为两种：基本类型和引用数据类型。</p><blockquote><p>基本类型：简单数据类型是不能简化的、内置的数据类型、由编程语言本身定义，它表示了真实的数字、字符和整数。</p><p>引用数据类型：Java语言本身不支持C++中的结构（struct）或联合（union）数据类型，它的复合数据类型一般都是通过类或接口进行构造，类提供了捆绑数据和方法的方式，同时可以针对程序外部进行信息隐藏。</p></blockquote><p>　　不同数据类型的变量在内存中分配的字节数不同，同时存储方式也是不同的。所以Java给变量赋值前需要先确定变量的类型，确定了变量的类型，即确定了数据需分配内存空间的大小，数据在内存的存储方式。</p><h2 id="二、Java基本类型和对应的包装类型"><a href="#二、Java基本类型和对应的包装类型" class="headerlink" title="二、Java基本类型和对应的包装类型"></a><font color="red">二、Java基本类型和对应的包装类型</font></h2><p>为了方便对基本类型进行操作，Java为每个基本类型提供了对应的包装类型（引用类型）。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><strong>byte</strong>：Java中最小的数据类型，在内存中占8位(bit)，即1个字节，取值范围-128~127，默认值0</p><p><strong>short</strong>：短整型，在内存中占16位，即2个字节，取值范围-32768~32717，默认值0</p><p><strong>int</strong>：整型，用于存储整数，在内在中占32位，即4个字节，取值范围-2147483648~2147483647，默认值0</p><p><strong>long</strong>：长整型，在内存中占64位，即8个字节-2^63~2^63-1，默认值0L</p><p><strong>float</strong>：浮点型，在内存中占32位，即4个字节，用于存储带小数点的数字（与double的区别在于float类型有效小数点只有6~7位），默认值0</p><p><strong>double</strong>：双精度浮点型，用于存储带有小数点的数字，在内存中占64位，即8个字节，默认值0</p><p><strong>char</strong>：字符型，用于存储单个字符，占16位，即2个字节，取值范围0~65535，默认值为空</p><p><strong>boolean</strong>：布尔类型，占<a href="https://www.jianshu.com/p/2f663dc820d0" target="_blank" rel="noopener">1位，1个字节或者四个字节(存在不同解释角度)</a>，用于判断真或假（仅有两个值，即true、false），默认值false。</p><p>Java中基本类型的存储是固定字节的，具体大小与对应的包装类型如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">基本类型</th><th style="text-align:center">存储位数</th><th style="text-align:center">包装类型</th></tr></thead><tbody><tr><td style="text-align:center">boolean</td><td style="text-align:center"><a href="https://www.jianshu.com/p/2f663dc820d0" target="_blank" rel="noopener">1,8,32</a></td><td style="text-align:center">Boolean</td></tr><tr><td style="text-align:center">byte</td><td style="text-align:center">8</td><td style="text-align:center">Byte</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">16</td><td style="text-align:center">Character</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">16</td><td style="text-align:center">Short</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">32</td><td style="text-align:center">Integer</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">64</td><td style="text-align:center">Long</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">32</td><td style="text-align:center">Float</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">64</td><td style="text-align:center">Double</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">BigInteger</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">BigDecimal</td></tr></tbody></table></div><h3 id="封装类型特征"><a href="#封装类型特征" class="headerlink" title="封装类型特征"></a>封装类型特征</h3><blockquote><p>每个基本类型都有一个包装类，这些包装类包含在<strong>java.lang</strong>包中。继承关系如下：</p></blockquote><ul><li>Object<ul><li>Boolean</li><li>Number<ul><li>Byte</li><li>Short</li><li>Integer</li><li>Long</li><li>Float</li><li>Double</li><li>BigInteger</li><li>BigDecimal</li></ul></li><li>Character</li></ul></li></ul><blockquote><p><strong>BigInteger、BigDecimal</strong>没有相对应的基本类型，主要应用于高精度的运算，<strong>BigInteger</strong> 支持任意精度的整数，<strong>BigDecimal</strong>支持任意精度带小数点的运算。</p><p>当整数类型的数据使用字面量赋值的时候，默认值为int类型，就是直接使用0或者其他数字的时候，<strong>默认值的类型为int类型</strong>，所以当使用 long a = 0这种赋值方式的时候，JVM内部存在数据转换。</p><p>浮点类型的数据使用字面量赋值的时候，<strong>默认值为double类型</strong>，就是当小数字面量出现的时候，JVM会使用double类型的数据类型。</p><p>从JDK 5.0开始，Java包含<strong>自动拆箱装箱</strong>的特性.调用valueOf()方法。</p></blockquote><h3 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h3><p>基本类型对应的缓冲池如下：</p><ul><li>-boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul><h2 id="三、在内存中的存储方式"><a href="#三、在内存中的存储方式" class="headerlink" title="三、在内存中的存储方式"></a><font color="red">三、在内存中的存储方式</font></h2><blockquote><p><strong>基本数据类型：</strong>所有的简单数据类型不存在“引用”的概念，基本数据类型都是直接存储在内存中的堆、栈上；</p><p><strong>引用类型：</strong>引用类型继承于Object类（也是引用类型）都是按照Java里面存储对象的内存模型来进行数据存储的，使用Java内存堆和内存栈来进行这种类型的数据存储，简单地讲，“引用”是存储在有序的内存栈上的，而对象本身的值存储在内存堆上的；</p></blockquote><h3 id="关于基本数据类型存放的位置"><a href="#关于基本数据类型存放的位置" class="headerlink" title="关于基本数据类型存放的位置"></a><strong>关于基本数据类型存放的位置</strong></h3><p>取决于基本类型声明的位置：</p><blockquote><p><strong>在方法中声明的变量</strong>，即该变量是局部变量，每当程序调用方法时，系统都会为该方法建立一个方法栈，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，其对应在该方法中声明的变量随着栈的销毁而结束，这就局部变量只能在方法中有效的原因。方法中声明的变量可以是基本类型的变量，也可以是引用类型的变量。<br>（1）当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在方法栈中<br>（2）当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在方法的栈中，该变量所指向的对象是放在堆类存中的。</p><p><strong>在类中声明的变量</strong>是成员变量，也叫全局变量，放在堆中的（因为全局变量不会随着某个方法执行结束而销毁）。同样在类中声明的变量即可是基本类型的变量 也可是引用类型的变量。<br>（1）当声明的是基本类型的变量其变量名及其值放在堆内存中的<br>（2）引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中</p></blockquote><h3 id="基本类型和封装类型异同"><a href="#基本类型和封装类型异同" class="headerlink" title="基本类型和封装类型异同"></a>基本类型和封装类型异同</h3><blockquote><p>基本类型不是对象</p><p>声明方式不同：包装类型需要用new。</p><p>存储方式和存储位置不同</p><p>初始值不同：boolean初始为false,int为0，而Boolean和Integer都为null。</p><p>使用方式和场景不同：基本类型数据存储相对简单，运算效率比较高。使用包装类型会牺牲一些转换效率，但可以避免持久化数据时产生的一些异常。同时，集合的元素必须是对象类型，满足了java一切皆是对象的思想。</p><p>销毁效率不同：基本类型定义的变量创建和销毁很快，而类定义的变量还需要JVM去销毁。</p></blockquote><h2 id="四、类型转换"><a href="#四、类型转换" class="headerlink" title="四、类型转换"></a><font color="red"><strong>四、类型转换</strong></font></h2><h3 id="基本类型之自动类型转换"><a href="#基本类型之自动类型转换" class="headerlink" title="基本类型之自动类型转换"></a>基本类型之自动类型转换</h3><p>注意，只能低精度转向高精度。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> char1 = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> char2 = <span class="string">'b'</span>;</span><br><span class="line"><span class="keyword">int</span> int1 = char1 + <span class="number">1</span>;<span class="comment">//这里即自动类型转换。</span></span><br><span class="line"><span class="keyword">int</span> int2 = char1 +char2;<span class="comment">//这里也完成了自动类型转换。</span></span><br><span class="line"><span class="comment">//char2 = int1;//出错</span></span><br></pre></td></tr></table></figure></p><h3 id="基本类型之强制类型转换"><a href="#基本类型之强制类型转换" class="headerlink" title="基本类型之强制类型转换"></a>基本类型之强制类型转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> char1 = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> char2 = <span class="string">'b'</span>;</span><br><span class="line"><span class="keyword">int</span> int1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> char3 =(<span class="keyword">char</span>)int1;</span><br><span class="line"><span class="keyword">char</span> char4 = (<span class="keyword">char</span>)(char1 + char2);<span class="comment">//这里也完成了强制类型转换。</span></span><br></pre></td></tr></table></figure><h3 id="基本类型→包装类型"><a href="#基本类型→包装类型" class="headerlink" title="基本类型→包装类型"></a>基本类型→包装类型</h3><p>这主要是包括构造方法和装箱操作。<br>还有valauOf()方法。</p><h4 id="（1）拆箱与装箱"><a href="#（1）拆箱与装箱" class="headerlink" title="（1）拆箱与装箱"></a>（1）拆箱与装箱</h4><p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">8</span>;</span><br><span class="line">System.out.println(a == b);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>注意区分拆箱和装箱，以及对象比较：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> int1 = <span class="number">9</span>;</span><br><span class="line">Integer a = <span class="number">9</span>;</span><br><span class="line">Integer c = <span class="keyword">new</span> Integer(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(int1 == c);<span class="comment">//true，比较值</span></span><br><span class="line">System.out.println(a == int1);<span class="comment">//true，比较值</span></span><br><span class="line">System.out.println(a == c);<span class="comment">//false，比较引用</span></span><br></pre></td></tr></table></figure></p><h4 id="（2）构造方法"><a href="#（2）构造方法" class="headerlink" title="（2）构造方法"></a>（2）构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//char</span></span><br><span class="line">Character(<span class="keyword">char</span> value)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//boolean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Boolean</span><span class="params">(<span class="keyword">boolean</span> value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Boolean</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function"><span class="comment">//注意，这个构造方法是输入的字符串是忽略大小写，相见源码：</span></span></span><br><span class="line"><span class="function"><span class="title">return</span> <span class="params">((s != <span class="keyword">null</span>)</span> &amp;&amp; s.<span class="title">equalsIgnoreCase</span><span class="params">(<span class="string">"true"</span>)</span>)</span>;</span><br></pre></td></tr></table></figure><p>其余的Byte、Int、Double、Long、Short都包含两个构造方法，一个传入本身的基本类型，一个传入一个String类型。</p><p>注意，Float包含三个构造函数，除了上述两个，还可以传入double基本类型的值，源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Float</span><span class="params">(<span class="keyword">double</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = (<span class="keyword">float</span>)value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="（3）valueOf-使用上等价于构造方法"><a href="#（3）valueOf-使用上等价于构造方法" class="headerlink" title="（3）valueOf():使用上等价于构造方法"></a>（3）<strong>valueOf()</strong>:使用上等价于构造方法</h4><p><strong>valueOf()</strong>方法等价于构造方法，能用构造方法得到的包装对象也可以用同样的方法通过<strong>valueOf()</strong>得到。<br>valueOf() 方法的实现是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。<br>编译器会在自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</p><h4 id="（4）String-→基本类型的其他方法"><a href="#（4）String-→基本类型的其他方法" class="headerlink" title="（4）String →基本类型的其他方法"></a>（4）String →基本类型的其他方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer to String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s)</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parseInt(s,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s, <span class="keyword">int</span> radix)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> NumberFormatException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * WARNING: This method may be invoked early during VM initialization</span></span><br><span class="line"><span class="comment">         * before IntegerCache is initialized. Care must be taken to not use</span></span><br><span class="line"><span class="comment">         * the valueOf method.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (radix &lt; Character.MIN_RADIX) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"radix "</span> + radix +</span><br><span class="line">                                            <span class="string">" less than Character.MIN_RADIX"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (radix &gt; Character.MAX_RADIX) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"radix "</span> + radix +</span><br><span class="line">                                            <span class="string">" greater than Character.MAX_RADIX"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> negative = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, len = s.length();</span><br><span class="line">        <span class="keyword">int</span> limit = -Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> multmin;</span><br><span class="line">        <span class="keyword">int</span> digit;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> firstChar = s.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (firstChar &lt; <span class="string">'0'</span>) &#123; <span class="comment">// Possible leading "+" or "-"</span></span><br><span class="line">                <span class="keyword">if</span> (firstChar == <span class="string">'-'</span>) &#123;</span><br><span class="line">                    negative = <span class="keyword">true</span>;</span><br><span class="line">                    limit = Integer.MIN_VALUE;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstChar != <span class="string">'+'</span>)</span><br><span class="line">                    <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="comment">// Cannot have lone "+" or "-"</span></span><br><span class="line">                    <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            multmin = limit / radix;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">                <span class="comment">// Accumulating negatively avoids surprises near MAX_VALUE</span></span><br><span class="line">                digit = Character.digit(s.charAt(i++),radix);</span><br><span class="line">                <span class="keyword">if</span> (digit &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (result &lt; multmin) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">                &#125;</span><br><span class="line">                result *= radix;</span><br><span class="line">                <span class="keyword">if</span> (result &lt; limit + digit) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">                &#125;</span><br><span class="line">                result -= digit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> negative ? result : -result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其他类包括了<strong>parseByte(),parseDouble()</strong>等。</p><h3 id="包装类型→基本类型"><a href="#包装类型→基本类型" class="headerlink" title="包装类型→基本类型"></a>包装类型→基本类型</h3><h4 id="（1）包装类型到对应基本类型"><a href="#（1）包装类型到对应基本类型" class="headerlink" title="（1）包装类型到对应基本类型"></a>（1）包装类型到对应基本类型</h4><p>根据继承关系，继承自java.lang.Number的包装类型都包含了Number类的如下公共无参方法，源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">longValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">floatValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">doubleValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">byteValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">byte</span>)intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">shortValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">short</span>)intValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>类似的，对于Charcter类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>对于Boolean类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">booleanValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="（2）包装类型→String类型"><a href="#（2）包装类型→String类型" class="headerlink" title="（2）包装类型→String类型"></a>（2）包装类型→String类型</h4><blockquote><p>除此外，所有的包装类型都可以用<strong>toString()</strong>方法得到字符串类型的对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Character</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[] = &#123;value&#125;;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(buf);<span class="comment">//实际上调用String类的valueOf()方法。</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Boolean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value ? <span class="string">"true"</span> : <span class="string">"false"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Float</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Float.toString(value);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FloatingDecimal.toJavaFormatString(f);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Double</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString(value);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FloatingDecimal.toJavaFormatString(d);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString(value);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//注意看这里，java是如何把int类型的数转换成String的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == Integer.MIN_VALUE)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"-2147483648"</span>;</span><br><span class="line">        <span class="keyword">int</span> size = (i &lt; <span class="number">0</span>) ? stringSize(-i) + <span class="number">1</span> : stringSize(i);<span class="comment">//得到i的字符数</span></span><br><span class="line">        <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[size];<span class="comment">//buf存储字符</span></span><br><span class="line">        getChars(i, size, buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> index, <span class="keyword">char</span>[] buf)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q, r;</span><br><span class="line">        <span class="keyword">int</span> charPos = index;</span><br><span class="line">        <span class="keyword">char</span> sign = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sign = <span class="string">'-'</span>;</span><br><span class="line">            i = -i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate two digits per iteration</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">65536</span>) &#123;</span><br><span class="line">            q = i / <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// really: r = i - (q * 100);</span></span><br><span class="line">            r = i - ((q &lt;&lt; <span class="number">6</span>) + (q &lt;&lt; <span class="number">5</span>) + (q &lt;&lt; <span class="number">2</span>));</span><br><span class="line">            i = q;</span><br><span class="line">            buf [--charPos] = DigitOnes[r];</span><br><span class="line">            buf [--charPos] = DigitTens[r];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fall thru to fast mode for smaller numbers</span></span><br><span class="line">        <span class="comment">// assert(i &lt;= 65536, i);</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            q = (i * <span class="number">52429</span>) &gt;&gt;&gt; (<span class="number">16</span>+<span class="number">3</span>);</span><br><span class="line">            r = i - ((q &lt;&lt; <span class="number">3</span>) + (q &lt;&lt; <span class="number">1</span>));  <span class="comment">// r = i-(q*10) ...</span></span><br><span class="line">            buf [--charPos] = digits [r];</span><br><span class="line">            i = q;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sign != <span class="number">0</span>) &#123;</span><br><span class="line">            buf [--charPos] = sign;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Long，与Integer类似的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString(value);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">long</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == Long.MIN_VALUE)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"-9223372036854775808"</span>;</span><br><span class="line">        <span class="keyword">int</span> size = (i &lt; <span class="number">0</span>) ? stringSize(-i) + <span class="number">1</span> : stringSize(i);</span><br><span class="line">        <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[size];</span><br><span class="line">        getChars(i, size, buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Short</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.toString((<span class="keyword">int</span>)value);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//所以也调用了Integer的这个静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == Integer.MIN_VALUE)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"-2147483648"</span>;</span><br><span class="line">        <span class="keyword">int</span> size = (i &lt; <span class="number">0</span>) ? stringSize(-i) + <span class="number">1</span> : stringSize(i);<span class="comment">//得到i的字符数</span></span><br><span class="line">        <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[size];<span class="comment">//buf存储字符</span></span><br><span class="line">        getChars(i, size, buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Byte</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.toString((<span class="keyword">int</span>)value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>常见的类型转换，以Integer为例：</p><h4 id="int-→-String"><a href="#int-→-String" class="headerlink" title="int → String"></a>int → String</h4><blockquote><p>(1)int后直接+””<br>(2)s = String.valueOf(i);<br>(3)Integer.toString(i);</p><h4 id="String→int"><a href="#String→int" class="headerlink" title="String→int"></a>String→int</h4><p>(1) i = Integer.parseInt(s);<br>(2) i = Integer.valueOf(s).intValue();<br>(3) i = new Integer(s).intValue();</p><h2 id="五、枚举类型"><a href="#五、枚举类型" class="headerlink" title="五、枚举类型"></a>五、枚举类型</h2><p>Java 5.0版本之后引入的除泛型之外的另外一个强大特性：枚举(Enums)。性能远高于静态类。解决一些固定常量集合的问题上枚举成为唯一首选和推荐的一种方式。<br><a href="https://blog.csdn.net/zyhlwzy/article/details/79045066" target="_blank" rel="noopener">枚举类解析</a></p><p>enum 不能使用 extends 关键字继承其他类，因为 enum 已经继承了 java.lang.Enum（java是单一继承）。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1551345094255&amp;amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;amp;imgtype=0&amp;amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一文道尽Java数据类型怎么用。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Java源码" scheme="https://yoursite.com/tags/Java%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Java并发(1)-多线程初探</title>
    <link href="https://yoursite.com/2018/10/05/Java%E5%B9%B6%E5%8F%91(1)-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E6%8E%A2/"/>
    <id>https://yoursite.com/2018/10/05/Java并发(1)-多线程初探/</id>
    <published>2018-10-05T06:48:20.000Z</published>
    <updated>2019-04-02T14:06:09.267Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551345094255&amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;imgtype=0&amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png" alt="此处输入图片的描述"><br>本文介绍Java中线程、进程、多线程的概念，详细介绍多线程的不同实现方式，从源码分析Callable()接口和Runnable()接口和FutureTask类。<br><a id="more"></a></p><h2 id="一、进程与线程"><a href="#一、进程与线程" class="headerlink" title="一、进程与线程"></a><font color="red">一、进程与线程</font></h2><p><strong>进程（Thread）：</strong>进程指正在运行的程序。当一个程序进入内存运行，即变成一个进程，进程是处于运行过程中的程序，并且具有一定独立功能，包括由操作系统分配的内存空间。<br><strong>线程(Process)：</strong>线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为<strong>多线程程序</strong>。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。<br><strong>线程池(Thread Pool):</strong>基本思想是一种对象池的思想，开辟一块内存空间，里面存放了众多(未死亡)的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省系统资源。<br><strong>并行（Parallen）与并发(Concurrent)：</strong><br>并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。<br>并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。<br><strong>并发不一定是并行的，并行一定是并发的。</strong></p><blockquote><p>如果某个系统支持两个或者多个动作（Action）同时存在，那么这个系统就是一个并发系统。如果某个系统支持两个或者多个动作同时执行，那么这个系统就是一个并行系统。并发系统与并行系统这两个定义之间的关键差异在于“存在”这个词。<br>在并发程序中可以同时拥有两个或者多个线程。这意味着，如果程序在单核处理器上运行，那么这两个线程将交替地换入或者换出内存。这些线程是同时“存在”的——每个线程都处于执行过程中的某个状态。如果程序能够并行执行，那么就一定是运行在多核处理器上。此时，程序中的每个线程都将分配到一个独立的处理器核上，因此可以同时运行。<br>“并行”概念是“并发”概念的一个子集。也就是说，你可以编写一个拥有多个线程或者进程的并发程序，但如果没有多核处理器来执行这个程序，那么就不能以并行方式来运行代码。因此，凡是在求解单个问题时涉及多个执行流程的编程模式或者执行行为，都属于并发编程的范畴。</p></blockquote><p><strong>其他概念：</strong></p><ul><li>线程同步（synchronized）</li><li>线程间通信</li><li>线程死锁</li><li>线程控制：挂起、停止和恢复</li></ul><blockquote><p>问题：Java程序运行至少启动几个线程？<br>至少启动两个线程，每当使用 Java 命令执行一个类时，实际上都会启动一个 JVM，每一个JVM实际上就是在操作系统中启动一个线程，Java 本身具备了垃圾的收集机制。所以在 Java 运行时至少会启动两个线程，一个是 main 线程，另外一个是垃圾收集线程。</p></blockquote><h2 id="二、线程的生命周期"><a href="#二、线程的生命周期" class="headerlink" title="二、线程的生命周期"></a><a href="http://www.runoob.com/java/java-multithreading.html" target="_blank" rel="noopener"><font color="red">二、线程的生命周期</font></a></h2><p><strong>新建状态:</strong><br>使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。</p><p><strong>就绪状态:</strong><br>当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</p><p><strong>运行状态:</strong><br>如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p><p><strong>阻塞状态:</strong><br>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：</p><p>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</p><p>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</p><p>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。</p><p><strong>死亡状态:</strong><br>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。<br><img src="https://upload-images.jianshu.io/upload_images/1689841-383f7101e6588094.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt="此处输入图片的描述"></p><p>线程在Running的过程中可能会遇到阻塞(Blocked)情况：</p><ul><li>调用join()和sleep()方法，sleep()时间结束或被打断，join()中断,IO完成都会回到Runnable状态，等待JVM的调度。</li><li>调用wait()，使该线程处于等待池(wait blocked pool),直到notify()/notifyAll()，线程被唤醒被放到锁定池(lock blocked pool )，释放同步锁使线程回到可运行状态（Runnable）</li><li>对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。<br>此外，在runnable状态的线程是处于被调度的线程，此时的调度顺序是不一定的。Thread类中的yield方法可以让一个running状态的线程转入runnable。</li></ul><h2 id="二、线程的优先级"><a href="#二、线程的优先级" class="headerlink" title="二、线程的优先级"></a><font color="red">二、线程的优先级</font></h2><p>每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。</p><p>Java 线程的优先级是一个整数，其取值范围是 <strong>1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）</strong>。</p><p>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</p><p>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。</p><h2 id="四、线程的实现"><a href="#四、线程的实现" class="headerlink" title="四、线程的实现"></a><font color="red">四、线程的实现</font></h2><p>Java提供了三种创建线程的方法：</p><h3 id="1-实现Runnable接口"><a href="#1-实现Runnable接口" class="headerlink" title="(1)实现Runnable接口"></a>(1)实现Runnable接口</h3><ul><li>声明实现 Runnable 接口的类。该类然后实现 run 方法。然后创建Runnable的子类对象，传入到某个线程的构造方法中，开启线程。</li><li>将线程的任务从线程的子类中分离出来，进行了单独的封装。按照面向对象的思想将任务的封装成对象。</li><li>避免了java单继承的局限性。<br><strong>步骤：</strong></li></ul><p>1、定义类实现Runnable接口。<br>2、覆盖接口中的run方法。。<br>3、创建Thread类的对象<br>4、将Runnable接口的子类对象作为参数传递给Thread类的构造函数。<br>5、调用Thread类的start方法开启线程。</p><p><strong>示例：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyThread2</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.num = num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i + num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-继承Thread类本身"><a href="#2-继承Thread类本身" class="headerlink" title="(2)继承Thread类本身"></a>(2)继承Thread类本身</h3><p>Thread是程序中的执行线程。Java 虚拟机允许应用程序并发地运行多个执行线程。<br>继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。<br>该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。<br><strong>步骤：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.定义一个类继承Thread。</span><br><span class="line">2.重写run方法。</span><br><span class="line">3.创建子类对象，就是创建线程对象。</span><br><span class="line">4.调用start方法，开启线程并让线程执行，同时还会告诉jvm去调用run方法</span><br></pre></td></tr></table></figure></p><p><strong>示例：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">":"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建线程实例</span></span><br><span class="line">MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line"><span class="comment">//修改线程名字</span></span><br><span class="line">mt.setName(<span class="string">"thread1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">mt.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程实例</span></span><br><span class="line">MyThread mt2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">mt2.setName(<span class="string">"thread2"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">mt2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-通过Callable和FutureTask创建线程"><a href="#3-通过Callable和FutureTask创建线程" class="headerlink" title="(3)通过Callable和FutureTask创建线程"></a>(3)通过Callable和FutureTask创建线程</h3><p><strong>步骤：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。</span><br><span class="line">2. 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。</span><br><span class="line">3. 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</span><br><span class="line">4. 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。</span><br></pre></td></tr></table></figure></p><p><strong>示例：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableThreadTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        CallableThreadTest ctt = <span class="keyword">new</span> CallableThreadTest();  <span class="comment">//创建Callable实现类的实例</span></span><br><span class="line">        FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(ctt);  <span class="comment">//用FutureTask类包装Callble对象，FutureTask对象封装了Callable对象call方法的返回值，因为它实现了Future()接口。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" 的循环变量i的值"</span>+i);  </span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">20</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">new</span> Thread(ft,<span class="string">"有返回值的线程"</span>).start();  <span class="comment">//使用FutureTask对象作为Thread对象的target创建并启动新线程</span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">try</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            System.out.println(<span class="string">"子线程的返回值："</span>+ft.get());  <span class="comment">//使用FutureTask的get方法来获得子线程结束后的返回值。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)  </span><br><span class="line">        &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e)  </span><br><span class="line">        &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception  <span class="comment">//线程执行体，有返回值</span></span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> i;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="三种方式对比"><a href="#三种方式对比" class="headerlink" title="三种方式对比"></a>三种方式对比</h3><ol><li><p>采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</p></li><li><p>使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</p></li><li><p>相比于Callable接口，另外两种方式的run()方法没有返回值，而Callable接口的call()方法有返回值，并且可用FutureTask对象捕获。</p></li><li><p>call() 方法可以抛出异常，run()方法不可以的。</p></li></ol><h3 id="Thread的run-和start-方法的区别"><a href="#Thread的run-和start-方法的区别" class="headerlink" title="Thread的run()和start()方法的区别"></a>Thread的run()和start()方法的区别</h3><p>start()：该方法是在当前线程中启动一个新的线程，而新启动的线程会调用run()方法，同时该方法不能重复调用；<br>run()  ：该方法和普通的方法一样，可以重复执行，不会创建新的线程。</p><h2 id="五、终止线程"><a href="#五、终止线程" class="headerlink" title="五、终止线程"></a>五、终止线程</h2><p>1、当run方法执行完毕，自动终止；</p><p>2、使用stop方法，不过这个方法不推荐使用，会有意料不到的后果；</p><p>3、使用interrupt方法</p><h2 id="六、源码解析"><a href="#六、源码解析" class="headerlink" title="六、源码解析"></a>六、<strong>源码解析</strong></h2><h3 id="Runnable-和-Callable-接口的源码"><a href="#Runnable-和-Callable-接口的源码" class="headerlink" title="Runnable 和 Callable 接口的源码"></a>Runnable 和 Callable 接口的源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码看返回值的差别：</p><blockquote><p>1）Callable 接口下的方法是 call()，Runnable 接口的方法是 run()。</p><p>2）Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值的。</p><p>3）call() 方法可以抛出异常，run()方法不可以的。</p><p>4）运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</p></blockquote><h3 id="FutureTask类源码"><a href="#FutureTask类源码" class="headerlink" title="FutureTask类源码"></a>FutureTask类源码</h3><p>比较FutureTask的源码，从声明来看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FutureTask 实现了 Runnable 和 Future，所以兼顾两者优点，既可以在 Thread 中使用，又可以在 ExecutorService 中使用。</p><p>其中，Future接口的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">//尝试取消线程任务</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">  <span class="comment">//如果在任务正常完成前将其取消，则返回 true。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//如果任务已完成，则返回 true。 可能由于正常终止、异常或取消而完成，在所有这些情况中，此方法都将返回 true。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//如有必要，等待计算完成，然后获取其结果。</span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">  <span class="comment">//如有必要，最多等待为使计算完成所给定的时间之后，获取其结果（如果结果可用）。</span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>FutureTask 实现了 <code>Runnable</code> 和 <code>Future</code>，所以兼顾两者优点，既可以在 Thread 中使用，又可以在 <code>ExecutorService</code> 中使用。</p></blockquote><pre><code>ExecutorService是Java提供的线程池。需要使用线程的时候，可以通过ExecutorService获得线程。它可以有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞，同时提供定时执行、定期执行、单线程、并发数控制等功能，比TimerTask更好。</code></pre><blockquote><p>FutureTask 是<strong>为了弥补 Thread 的不足</strong>而设计的，它可以让程序员准确地知道线程什么时候执行完成并获得到线程执行完成后返回的结果。</p><p>FutureTask 是一种可以取消的异步的计算任务，它的计算是通过 Callable 实现的，它等价于可以携带结果的 Runnable，并且有三个状态：等待、运行和完成。完成包括所有计算以任意的方式结束，包括正常结束、取消和异常。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1551345094255&amp;amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;amp;imgtype=0&amp;amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;本文介绍Java中线程、进程、多线程的概念，详细介绍多线程的不同实现方式，从源码分析Callable()接口和Runnable()接口和FutureTask类。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Java源码" scheme="https://yoursite.com/tags/Java%E6%BA%90%E7%A0%81/"/>
    
      <category term="Java并发" scheme="https://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
