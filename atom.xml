<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fan Wu&#39;s Blog</title>
  
  <subtitle>Nothing is impossible!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yoursite.com/"/>
  <updated>2018-12-26T15:41:44.820Z</updated>
  <id>https://yoursite.com/</id>
  
  <author>
    <name>Fan Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>keras模型拼接</title>
    <link href="https://yoursite.com/2018/12/25/keras%E6%A8%A1%E5%9E%8B%E6%8B%BC%E6%8E%A5/"/>
    <id>https://yoursite.com/2018/12/25/keras模型拼接/</id>
    <published>2018-12-25T12:48:20.000Z</published>
    <updated>2018-12-26T15:41:44.820Z</updated>
    
    <content type="html"><![CDATA[<p><strong>在模型测试过程中，如何让两个模型中间层的输入输出拼在一起呢？</strong><br><img src="https://upgrad.com/blog/wp-content/uploads/2018/04/keras0.png" alt="此处输入图片的描述"></p><a id="more"></a><p>首先，加载训练好的模型后，我们可以用下面的方式获取模型的中间层输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = load_model(&quot;model1.h5&quot;)</span><br><span class="line">First_model = Model(inputs=model.input, outputs=model.layers[7].output)#表示获取模型第7层的输出</span><br></pre></td></tr></table></figure></p><p>然后如何把第7层的输出，作为下一个模型中间层的输入呢？用下面的方法是不可以的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model2 = load_model(&quot;model2.h5&quot;)</span><br><span class="line">second_model = Model(inputs=model2.layers[8].input, outputs=model2.layers[-1].output)</span><br></pre></td></tr></table></figure></p><p>这样会得到类似下面的错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RuntimeError: Graph disconnected: cannot obtain value for tensor Tensor(&quot;conv2d_1_input:0&quot;, shape=(?, 144, 144, 3), dtype=float32) at layer &quot;conv2d_1_input&quot;. The following previous layers were accessed without issue: []</span><br></pre></td></tr></table></figure></p><p>解决办法是声明一个新的Input Layer,用下面的方式拼接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">second_input = Input(model.layers[8].input_shape[1:])</span><br><span class="line">second_model = second_input</span><br><span class="line">for layer in model.layers[8:]:</span><br><span class="line">    second_model = layer(second_model)</span><br><span class="line">second_model = Model(inputs=second_input, outputs=second_model)</span><br></pre></td></tr></table></figure></p><p>由此，便完成了模型的拼接！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;在模型测试过程中，如何让两个模型中间层的输入输出拼在一起呢？&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://upgrad.com/blog/wp-content/uploads/2018/04/keras0.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="https://yoursite.com/categories/Machine-Learning/"/>
    
    
      <category term="Machine Learning" scheme="https://yoursite.com/tags/Machine-Learning/"/>
    
      <category term="python" scheme="https://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>搭建博客时候问题小记</title>
    <link href="https://yoursite.com/2018/12/01/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%97%B6%E5%80%99%E9%97%AE%E9%A2%98%E5%B0%8F%E8%AE%B0/"/>
    <id>https://yoursite.com/2018/12/01/搭建博客时候问题小记/</id>
    <published>2018-12-01T06:48:20.000Z</published>
    <updated>2018-12-27T02:07:33.120Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong>汇总搭建博客遇见的几个问题<br><a id="more"></a></p><h2 id="nothing-added-to-commit-but-untracked-files-present"><a href="#nothing-added-to-commit-but-untracked-files-present" class="headerlink" title="nothing added to commit but untracked files present"></a>nothing added to commit but untracked files present</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;first commit&quot;</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">        .gitignore</span><br><span class="line">        _config.yml</span><br><span class="line">        git</span><br><span class="line">        git.pub</span><br><span class="line">        package-lock.json</span><br><span class="line">        package.json</span><br><span class="line">        scaffolds/</span><br><span class="line">        source/</span><br><span class="line">        themes/</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present</span><br></pre></td></tr></table></figure><p>这个错误原因有两个：</p><ol><li>已经存在的项目？</li><li>没有把需要提交的文件加载进来，所以需要用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add （文件名）</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="fatal-remote-origin-already-exists"><a href="#fatal-remote-origin-already-exists" class="headerlink" title="fatal: remote origin already exists."></a>fatal: remote origin already exists.</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: remote origin already exists.</span><br></pre></td></tr></table></figure><p>用到的解决办法：</p><ol><li><p>删除远程仓库，再添加远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$git remote rm origin</span><br><span class="line"></span><br><span class="line">$git remote add origin git@github.com:wufans/wufans.github.io.git</span><br></pre></td></tr></table></figure></li><li><p>修改git的config文件的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$vi .git/config</span><br></pre></td></tr></table></figure></li></ol><p>删除[remote “origin”]</p><hr><h2 id="github-rejected"><a href="#github-rejected" class="headerlink" title="github rejected"></a>github rejected</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">To github.com:wufans/wufans.github.io.git</span><br><span class="line"> ! [rejected]        master -&gt; master (non-fast-forward)</span><br><span class="line"> &apos;git@github.com:wufans/wufans.github.io.git&apos;</span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: &apos;git pull ...&apos;) before pushing again.</span><br></pre></td></tr></table></figure><p>这个方法就是因为本地仓库和github上面仓库的内容有冲突导致的<br>我用的解决办法是删除了原来的repository，重新建立了一个仓库，问题解决。</p><hr><h2 id="创建流量统计功能的方法"><a href="#创建流量统计功能的方法" class="headerlink" title="创建流量统计功能的方法"></a>创建流量统计功能的方法</h2><p><a href="https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="noopener">参考博客</a></p><hr><h2 id="附加功能的添加"><a href="#附加功能的添加" class="headerlink" title="附加功能的添加"></a>附加功能的添加</h2><p><a href="https://blog.csdn.net/linshuhe1/article/details/52424573" target="_blank" rel="noopener">参考博客</a></p><hr><h2 id="解决公式显示不正常的问题"><a href="#解决公式显示不正常的问题" class="headerlink" title="解决公式显示不正常的问题"></a>解决公式显示不正常的问题</h2><p><a href="https://blog.csdn.net/emptyset110/article/details/50123231" target="_blank" rel="noopener">参考博客</a></p><hr><h2 id="hexo设置侧边栏头像"><a href="#hexo设置侧边栏头像" class="headerlink" title="hexo设置侧边栏头像"></a>hexo设置侧边栏头像</h2><p>编辑站点的 _config.yml，新增字段 avatar， 值设置成头像的链接地址。</p><p>其中，头像的链接地址可以是：</p><p>完整的互联网 URL，例如：<a href="https://avatars1.githubusercontent.com/u/32269?v=3&amp;s=460" target="_blank" rel="noopener">https://avatars1.githubusercontent.com/u/32269?v=3&amp;s=460</a></p><p>站点内的地址，例如：</p><p>/uploads/avatar.jpg 需要将你的头像图片放置在 站点的 source/uploads/（可能需要新建uploads目录）<br>/images/avatar.jpg 需要将你的头像图片放置在 主题的 source/images/ 目录下。</p><hr><h2 id="hexo部署失败，不能连接github的解决"><a href="#hexo部署失败，不能连接github的解决" class="headerlink" title="hexo部署失败，不能连接github的解决"></a>hexo部署失败，不能连接github的解决</h2><p>一直在解决这个问题，修改了本地文件的几个配置之后，突然发现生成的博客不能直接push到github上了，显示错误<br><img src="https://s1.ax1x.com/2018/12/27/F2IkYd.jpg" alt="此处输入图片的描述"><br>但是用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure></p><p>部署到本地的时候是没有问题的。<br>然后用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@gihub.com</span><br></pre></td></tr></table></figure></p><p>测试连接也出现了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh_exchange_identification: read:Connection reset by peer</span><br></pre></td></tr></table></figure></p><p>和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection reset by 192.30.253.112 port 22</span><br></pre></td></tr></table></figure></p><p>这样的错误<br>尝试了以下解决办法：</p><ol><li>因为前几次修改了hosts文件解决github不能加载CSS的问题，让电脑解析github的域名时用的是自定义的IP，所以可能有这个原因，因此在hosts里面注释掉了修改的部分，然后刷新DNS缓存<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /flushdns</span><br><span class="line">#这里还遇到了ipconfig和ping不是一个命令的错误，需要配置环境变量path</span><br><span class="line">#%SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem</span><br></pre></td></tr></table></figure></li></ol><p>最后发现没用。</p><ol><li>删除了github上面的ssh配置，重新配置了github服务器端与本地的ssh秘钥，然后再使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@gihub.com</span><br></pre></td></tr></table></figure></li></ol><p>结果能连上了，但是再用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p><p>之后，又报了刚才的错误，而且再测试与github上面的连接居然也出错了~</p><ol><li>俗话说，重启治百病，于是重启了一下————是的，没用</li><li>用网上的解决办法，可能是网络防火墙设置的原因，用手机给电脑开热点再测试连接，结果也没用<br>最后打算第二天重新部署博客了，然后奇迹发生了，起床之后再测试链接，work~</li></ol><hr><h2 id="Github不能访问、不能正常加载CSS的解决"><a href="#Github不能访问、不能正常加载CSS的解决" class="headerlink" title="Github不能访问、不能正常加载CSS的解决"></a>Github不能访问、不能正常加载CSS的解决</h2><p>修改了windows的hosts文件之后，经常会出现github访问异常，页面的CSS样式无法加载等的情况。<br><strong>解决办法</strong><br>给hosts文件增加github的CDN fastly.net,跳过域名解析，直接通过IP访问github。<br>在hosts文件下增加一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">185.31.17.184 github.global.ssl.fastly.net</span><br></pre></td></tr></table></figure></p><font color="red"><strong>问题</strong></font><p>使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p><p>部署博客时，出现下列错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fatal: TaskCanceledException encountered.</span><br><span class="line">   ▒▒ȡ▒▒һ▒▒▒▒▒▒</span><br><span class="line">bash: /dev/tty: No such device or address</span><br><span class="line">error: failed to execute prompt script (exit code 1)</span><br><span class="line">fatal: could not read Username for &apos;https://github.com&apos;: No error</span><br><span class="line">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="line">Error: fatal: TaskCanceledException encountered.</span><br><span class="line">   ��ȡ��һ������</span><br><span class="line">bash: /dev/tty: No such device or address</span><br><span class="line">error: failed to execute prompt script (exit code 1)</span><br><span class="line">fatal: could not read Username for &apos;https://github.com&apos;: No error</span><br><span class="line"></span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (D:\blog\GIT\hexo\node_modules\hexo-util\lib\spawn.js:37:17)</span><br><span class="line">    at emitTwo (events.js:125:13)</span><br><span class="line">    at ChildProcess.emit (events.js:213:7)</span><br><span class="line">    at ChildProcess.cp.emit (D:\blog\GIT\hexo\node_modules\cross-spawn\lib\enoent.js:40:29)</span><br><span class="line">    at maybeClose (internal/child_process.js:927:16)</span><br><span class="line">    at Process.ChildProcess._handle.onexit (internal/child_process.js:211:5)</span><br></pre></td></tr></table></figure></p><font color="red"><strong>解决</strong></font><p>如果开启了本地预览，先关闭<br>然后用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure></p><p>清空缓存，再重新生成静态文件并部署，问题解决~</p><h2 id="另外"><a href="#另外" class="headerlink" title="另外"></a><font color="red">另外</font></h2><p>用了上面的方法之后还出现了这个问题的话，<big><font color="red">重启</font></big>一下电脑~~</p><h2 id="添加版权声明"><a href="#添加版权声明" class="headerlink" title="添加版权声明"></a>添加版权声明</h2><p>添加版权声明</p><p>在Github上，Next主题的issues上有设置 Creative Commons 协议，这个就是设置版权声明，但是配置了以后图标比较小，没有文字说明（就是没逼格），而且还会出现在它不该出现的地方。</p><h3 id="新建-passage-end-tag-swig-文件"><a href="#新建-passage-end-tag-swig-文件" class="headerlink" title="新建 passage-end-tag.swig 文件"></a>新建 passage-end-tag.swig 文件</h3><p>在路径\themes\next\layout_macro中添加passage-end-tag.swig文件，其内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.passage_end_tag.enabled %&#125;</span><br><span class="line">&lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;</span><br><span class="line">------ 本文结束 ------&lt;/div&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;div style=&quot;border: 1px solid black&quot;&gt;</span><br><span class="line">&lt;div style=&quot;margin-left:10px&quot;&gt;</span><br><span class="line">&lt;span style=&quot;font-weight:blod&quot;&gt;版权声明&lt;/span&gt;</span><br><span class="line">&lt;img src=&quot;http://creativecommons.org/images/deed/logo_deed.gif&quot;&gt;&lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;Fan Wu&apos;s Blog&lt;/a&gt; by &lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;Fan Wu&lt;/a&gt; is licensed under a &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; style=&quot;color:#258FC6&quot;&gt;Creative Commons BY-NC-ND 4.0 International License&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">由&lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;Fan Wu&lt;/a&gt;创作并维护的&lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;Fan Wu&apos;s Blog&lt;/a&gt;博客采用&lt;a href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; style=&quot;color:#258FC6&quot;&gt;创作共用保留署名-非商业-禁止演绎4.0国际许可证&lt;/a&gt;。&lt;br/&gt;</span><br><span class="line">本文首发于&lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;Fan Wu&apos;s Blog&lt;/a&gt; 博客（ &lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;http://wufan.site/&lt;/a&gt; ），版权所有，侵权必究。&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>如果觉得上面的样式不好看，也可以引用下面的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.passage_end_tag.enabled %&#125;</span><br><span class="line">&lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;</span><br><span class="line">-------------本文结束&lt;i class=&quot;fa fa-heart&quot;&gt;&lt;/i&gt;感谢阅读-------------&lt;/div&gt;</span><br><span class="line">&lt;ul class=&quot;post-copyright&quot;&gt;</span><br><span class="line">  &lt;li class=&quot;post-copyright-author&quot;&gt;</span><br><span class="line">      &lt;strong&gt;本文作者:&lt;/strong&gt;&#123;&#123; theme.author &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">  &lt;li class=&quot;post-copyright-link&quot;&gt;</span><br><span class="line">    &lt;strong&gt;本文链接:&lt;/strong&gt;</span><br><span class="line">    &lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.path &#125;&#125;&lt;/a&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">  &lt;li class=&quot;post-copyright-license&quot;&gt;</span><br><span class="line">    &lt;strong&gt;许可协议:&lt;/strong&gt;</span><br><span class="line">    除特殊声明外，本站博文均采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-sa/3.0/cn/&quot; rel=&quot;external nofollow&quot; target=&quot;_blank&quot;&gt;CC BY-NC-SA 4.0 CN&lt;/a&gt; 许可协议，转载请注明出处！</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><h3 id="修改-post-swig-文件"><a href="#修改-post-swig-文件" class="headerlink" title="修改 post.swig 文件"></a>修改 post.swig 文件</h3><p>在\themes\next\layout_macro\post.swig中，post-body之后，post-footer之前添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% if not is_index %&#125;</span><br><span class="line">    &#123;% include &apos;passage-end-tag.swig&apos; %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h3 id="在主题配置文件中添加字段"><a href="#在主题配置文件中添加字段" class="headerlink" title="在主题配置文件中添加字段"></a>在主题配置文件中添加字段</h3><p>在主题配置文件”_config.yml”中添加以下字段开启此功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#文章末尾添加“本文结束”标记</span><br><span class="line">passage_end_tag:</span><br><span class="line">  enabled: true</span><br></pre></td></tr></table></figure><p>完成以上设置之后，在每篇文章之后都会添加“版权声明”标记。</p><h2 id="添加动画效果"><a href="#添加动画效果" class="headerlink" title="添加动画效果"></a>添加动画效果</h2><p>背景动画基于canvas，添加到博客上也比较简单，在\themes\next\layout_layout.swig的上面添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.canvas_nest %&#125;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>在\themes\next_config.yml中添加以下字段开启此功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># background settings</span><br><span class="line"># add canvas-nest effect</span><br><span class="line"># see detail from https://github.com/hustcc/canvas-nest.js</span><br><span class="line">canvas_nest: true</span><br></pre></td></tr></table></figure></p><p>添加完了，发现博客背景是白色，会遮住动画，只留下两边一点点的位置看到动画效果，这时候可以去设置一下背景颜色，在\themes\next\source\css_schemes\Pisces_layout.styl中，把.content-wrap中的background修改为none。</p><p>这时候如果用手机打开，也能看到动画效果，但是带来的体验不好，显得页面比较乱，这是可以把.content-wrap的+mobile()中的background修改为white，这样手机端的体验就好很多，却又不影响电脑端的炫酷动画。</p><h2 id="解决博客浏览统计功能突然失效的方法（hexo-theme-next-busuanzi-count）"><a href="#解决博客浏览统计功能突然失效的方法（hexo-theme-next-busuanzi-count）" class="headerlink" title="解决博客浏览统计功能突然失效的方法（hexo-theme-next-busuanzi_count）"></a>解决博客浏览统计功能突然失效的方法（hexo-theme-next-busuanzi_count）</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>我这里是使用的hexo-theme-next主题，主题版本为：3.8.0(更新于10-31日)</p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>由于定位到是不蒜子统计功能突然有问题了，所以前往不蒜子官网进行查看，发现官网有一段很重要的提示：<br><strong>“因七牛强制过期『dn-lbstatics.qbox.me』域名，与客服沟通无果，只能更换域名到『busuanzi.ibruce.info』！”</strong><br>所以定位到问题，原来是不蒜子使用的七牛的域名被强制过期。<br>需要把 dn-lbstatics.qbox.me 域名更换为 busuanzi.ibruce.info</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>hexo-theme-next主题中使用了dn-lbstatics.qbox.me域名的文件位置为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">themes\next\layout\_third-party\analytics\busuanzi-counter.swig</span><br></pre></td></tr></table></figure><p>修改busuanzi-counter.swig</p><p>找到如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>重新预览，即可看到不蒜子统计功能已经生效<br><a href="https://blog.csdn.net/qijian2003122/article/details/82987577" target="_blank" rel="noopener">原文</a></p><h2 id="恢复你的博客，只需要三步"><a href="#恢复你的博客，只需要三步" class="headerlink" title="恢复你的博客，只需要三步"></a>恢复你的博客，只需要三步</h2><p><strong>如果你重装了系统或者更换了新电脑/新平台，怎么才能快速恢复原来的博客呢？</strong><br>如果你保留了原来博客文件夹下所有文件，那么恢复博客只需要三步：</p><h3 id="安装必备组件"><a href="#安装必备组件" class="headerlink" title="安装必备组件"></a>安装必备组件</h3><p>包括：安装Git，安装Node.js</p><h3 id="Github配对"><a href="#Github配对" class="headerlink" title="Github配对"></a>Github配对</h3><p>打开git bash，在用户主目录下运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure></p><p>把其中的邮件地址换成自己的邮件地址，然后一路回车,在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥<br>登陆GitHub，打开「Settings」-&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容），最后点击「Add SSH Key」<br>测试是否配对成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>打开git bash客户端，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure></p><p>，开始安装hexo<br>安装成功后，进入你原来的博客目录，就可以用hexo命令进行博客生成和部署啦~</p><h2 id="给博客自定义域名开启Https"><a href="#给博客自定义域名开启Https" class="headerlink" title="给博客自定义域名开启Https"></a>给博客自定义域名开启Https</h2><p><strong>HTTPS</strong>（全称：Hyper Text Transfer Protocol over Secure Socket Layer 或 Hypertext Transfer Protocol Secure，超文本传输安全协议），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。<br>GitHub官方在5月1号宣布，GitHub Pages的自定义域名获得对HTTPS的支持。但是因为自己的域名是自定义的，购于阿里云，因此不能直接在Setting中设置Enforce HTTPS:<br><img src="https://s1.ax1x.com/2018/12/26/F2rlvj.png" alt="此处输入图片的描述"><br>而Github pages不支持SSL证书上传，因此，开启HTTPS需要借助CloudFlare的CDN代理。即用户到CDN服务器的连接为https，而CDN服务器到GithubPage服务器的连接为http，就是在CDN服务器那里加上反向代理。<br><strong>步骤如下：</strong></p><ol><li>首先注册并登陆CloudFlare,在域名购买的地方修改name sever，修改DNS解析地址。（启用动态DNS加速）<br><img src="https://s1.ax1x.com/2018/12/26/F2r3Ks.png" alt="此处输入图片的描述"></li><li>与域名绑定并激活成功后，设置CloudFlare 的 DNS：<br><img src="https://s1.ax1x.com/2018/12/26/F2rdGF.png" alt="此处输入图片的描述"></li><li>设置CloudFlare 的 Crypto：<br><img src="https://s1.ax1x.com/2018/12/26/F2rDM9.png" alt="此处输入图片的描述"></li><li>设置路由规则Page Rules：<br><img src="https://s1.ax1x.com/2018/12/26/F2rsq1.png" alt="此处输入图片的描述"><br>至此，等待一段时间，就可以用https协议访问你的自定义域名<br>为了让博客完全开启Https，还需要修改文章内容中用http协议的链接，比如图片，这样，就能看到浏览器域名旁边的小绿锁啦！<br><img src="https://s1.ax1x.com/2018/12/27/F255Q0.png" alt="此处输入图片的描述"><br>同时，修改了DNS解析服务器后，网站响应速度也更快了！一举两得！</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;汇总搭建博客遇见的几个问题&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="https://yoursite.com/categories/linux/"/>
    
    
      <category term="github" scheme="https://yoursite.com/tags/github/"/>
    
      <category term="blog" scheme="https://yoursite.com/tags/blog/"/>
    
      <category term="hexo" scheme="https://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>CUDA安装问题解决</title>
    <link href="https://yoursite.com/2018/07/29/CUDA%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>https://yoursite.com/2018/07/29/CUDA安装问题解决/</id>
    <published>2018-07-29T06:38:20.000Z</published>
    <updated>2018-12-26T15:37:28.949Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>CUDA安装失败问题解决。</p><p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRkXxUeuvvVGryPwRjR_fSlc7YHFVRj7oq-475WcJFVBQ2zZII6" alt="此处输入图片的描述"><br><a id="more"></a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>CUDA安装失败都是由于其中Visual Studio(VS) Intergration无法安装导致：</li></ul><p><img src="https://img-blog.csdn.net/20180511161737668?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6cG9uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="此处输入图片的描述"></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul><li>择自定义安装，并不要安装VS组件：</li></ul><p><img src="https://img-blog.csdn.net/20180511162009392?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6cG9uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="此处输入图片的描述"></p><ul><li><p>将<strong>“CUDAVisualStudioIntegration\extras\visual_studio_integration\MSBuildExtensions”</strong>下的文件直接拷贝到<strong>“C:\Program Files (x86)\MSBuild\Microsoft.Cpp\v4.0\V140\BuildCustomizations”</strong>文件夹中。<br> <strong>“CUDAVisualStudioIntegration”</strong>这个可以在默认文件：<strong>“C:\Users\用户名\AppData\Local\Temp\CUDA”</strong>下找到，但是如果你把NVIDIA安装程序关闭了，那么这个默认文件就会消失的，所以可以等NVIDIA安装程序将数据解压完毕后再去找，肯定能找到。</p></li><li><p>复制解压后的cudnn文件到cuda对应目录下即可。最后验证安装成功：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\wufan&gt;nvcc -V</span><br><span class="line">nvcc: NVIDIA (R) Cuda compiler driver</span><br><span class="line">Copyright (c) 2005-2017 NVIDIA Corporation</span><br><span class="line">Built on Fri_Sep__1_21:08:32_Central_Daylight_Time_2017</span><br><span class="line">Cuda compilation tools, release 9.0, V9.0.176</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;CUDA安装失败问题解决。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRkXxUeuvvVGryPwRjR_fSlc7YHFVRj7oq-475WcJFVBQ2zZII6&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="https://yoursite.com/categories/linux/"/>
    
    
      <category term="notes" scheme="https://yoursite.com/tags/notes/"/>
    
      <category term="Machine Learning" scheme="https://yoursite.com/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Linux之路</title>
    <link href="https://yoursite.com/2018/07/22/Linux%E4%B9%8B%E8%B7%AF/"/>
    <id>https://yoursite.com/2018/07/22/Linux之路/</id>
    <published>2018-07-22T06:38:00.000Z</published>
    <updated>2018-12-26T15:38:53.467Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>记录使用Linux遇到的问题与解决办法。</p><p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRkXxUeuvvVGryPwRjR_fSlc7YHFVRj7oq-475WcJFVBQ2zZII6" alt="此处输入图片的描述"><br><a id="more"></a></p><h2 id="无法解析或打开软件包的列表或是状态文件问题的解决方案"><a href="#无法解析或打开软件包的列表或是状态文件问题的解决方案" class="headerlink" title="无法解析或打开软件包的列表或是状态文件问题的解决方案"></a>无法解析或打开软件包的列表或是状态文件问题的解决方案</h2><p>在通过sudo apt-get install安装软件的时候，可能会出现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">正在读取软件包列表... 有错误！</span><br><span class="line">E: Encountered a section with no Package: header</span><br><span class="line">E: Problem with MergeList /var/lib/apt/lists/??</span><br><span class="line">E: 无法解析或打开软件包的列表或是状态文件。</span><br></pre></td></tr></table></figure></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>执行下面两条语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /var/lib/apt/lists/* -vf #删掉apt下的lists文件下的内容</span><br><span class="line">sudo apt-get update # 更新软件源</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;记录使用Linux遇到的问题与解决办法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRkXxUeuvvVGryPwRjR_fSlc7YHFVRj7oq-475WcJFVBQ2zZII6&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="https://yoursite.com/categories/linux/"/>
    
    
      <category term="notes" scheme="https://yoursite.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>JupyterNotebook教程</title>
    <link href="https://yoursite.com/2018/07/15/JupyterNotebook%E6%95%99%E7%A8%8B/"/>
    <id>https://yoursite.com/2018/07/15/JupyterNotebook教程/</id>
    <published>2018-07-15T05:40:42.000Z</published>
    <updated>2018-12-26T15:38:36.126Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要</strong>：简单总结Jupyter Notebook的教程,方便以后使用。</p><p><img src="https://qiot.qnap.com/blog/wp-content/uploads/2018/08/JupyterHub-2.png" alt="此处输入图片的描述"><br><a id="more"></a></p><h2 id="notebook-界面组成"><a href="#notebook-界面组成" class="headerlink" title="notebook 界面组成"></a>notebook 界面组成</h2><ol><li>notebook 的名称</li><li>主工具栏，提供了保存、导出、重载 notebook，以及重启内核等选项</li><li>快捷键</li><li>notebook 主要区域，包含了 notebook 的内容编辑区</li></ol><h2 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h2><p>Command mode 和 Edit mode。 在一个cell中，按下Enter,进入Edit模式，按下Esc,进入Command 模式</p><p>运行当前cell，并移动到下一个Cell<br>在一个cell中（在command模式下）,  Shift + Enter  </p><h2 id="创建Cell"><a href="#创建Cell" class="headerlink" title="创建Cell"></a>创建Cell</h2><p>在一个cell中（在command模式下）</p><ol><li>按下 a ,即可在这个cell之前创建一个新的cell；</li><li>按下 b,即可在这个cell之后创建一个新的cell;</li></ol><h2 id="Cell中-Code-和-Markdown的切换"><a href="#Cell中-Code-和-Markdown的切换" class="headerlink" title="Cell中 Code 和 Markdown的切换"></a>Cell中 Code 和 Markdown的切换</h2><p>在一个cell中（在command模式下）</p><ol><li>按下y, 进入Code;</li><li>按下m, 进入Markdown;</li></ol><h2 id="显示Cell中的行数"><a href="#显示Cell中的行数" class="headerlink" title="显示Cell中的行数"></a>显示Cell中的行数</h2><p>在一个cell中（在command模式下），按下 l</p><h2 id="删除Cell"><a href="#删除Cell" class="headerlink" title="删除Cell"></a>删除Cell</h2><p>在一个cell中（在command模式下）, 按两次d</p><h2 id="保存Notebook"><a href="#保存Notebook" class="headerlink" title="保存Notebook"></a>保存Notebook</h2><p>在一个cell中（在command模式下）, 按下s</p><h2 id="启动命令面板"><a href="#启动命令面板" class="headerlink" title="启动命令面板"></a>启动命令面板</h2><p>在一个cell中（在command模式下）, 按下 Ctrl + Shift + P<br>界面中的小键盘图标也可以启动。</p><p>可以通过这个命令面板快速的执行命令。比如我这里将一个cell移动到它下一个cell的下面：在一个cell中（在command模式下），然后按下 Ctrl + Shift + P ，输入 move ，键盘方向键选择要执行的命令即可，然后按下回车即可执行。</p><h2 id="Matplotlib-集成"><a href="#Matplotlib-集成" class="headerlink" title="Matplotlib 集成"></a>Matplotlib 集成</h2><p>如果你用 Python 绘制过图形，那你肯定知道 matplotlib。Matplotlib 是一个用于创建漂亮图形的 Python 库，结合 Jupyter notebook 使用时体验更佳。</p><p>要想在 Jupyter notebook 中使用 matplotlib，需要告诉 Jupyter 获取 matplotlib 生成的所有图形，并将其嵌入 notebook 中。为此，需要计算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure></p><p>译注：要想执行成功，需要先<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install matplotlib。</span><br></pre></td></tr></table></figure></p><p>运行这个指令可能要花个几秒钟，但是在 notebook 中需要执行一次即可。接下来，我们来绘制一个图形，看看具体的集成效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">x = np.arange(20)</span><br><span class="line">y = x**2</span><br><span class="line"></span><br><span class="line">plt.plot(x, y)</span><br></pre></td></tr></table></figure><p>上面的代码将绘制方程式 y=x^2 。计算单元格后，会得到如下图形：<br><img src="https://www.packtpub.com/sites/default/files/new_blog_images/Extra_Blogs/Jupyter_01_11.png" alt="此处输入图片的描述"></p><h2 id="终极奥义"><a href="#终极奥义" class="headerlink" title="终极奥义"></a><font color="red">终极奥义</font></h2><p>按下键盘的 h。查看所有快捷键~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;：简单总结Jupyter Notebook的教程,方便以后使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://qiot.qnap.com/blog/wp-content/uploads/2018/08/JupyterHub-2.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="guidance" scheme="https://yoursite.com/categories/guidance/"/>
    
    
      <category term="notes" scheme="https://yoursite.com/tags/notes/"/>
    
      <category term="python" scheme="https://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Donkeycar教程</title>
    <link href="https://yoursite.com/2018/07/13/Donkeycar%E6%95%99%E7%A8%8B/"/>
    <id>https://yoursite.com/2018/07/13/Donkeycar教程/</id>
    <published>2018-07-13T06:44:00.000Z</published>
    <updated>2018-12-26T15:37:27.598Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong>本教程是基于Donkeycar的智能小车教程。DonkeyCar小车是基于树莓派和Python，利用Keras深度学习框架实现的自动驾驶小车。</p><p><img src="https://ss0.baidu.com/73F1bjeh1BF3odCf/it/u=2559738123,4256387987&amp;fm=85&amp;s=752AB952CCB777A7958C48AE03007022" alt="此处输入图片的描述"></p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><font color="red">简介</font></h2><p>本教程是基于Donkeycar的智能小车教程。DonkeyCar小车是基于树莓派和Python，利用Keras深度学习框架实现的自动驾驶小车。<br>本文档参考和整合<a href="https://docs.donkeycar.com/" target="_blank" rel="noopener">Donkeycar文档</a>和<a href="https://www.ncnynl.com/archives/201804/2398.html" target="_blank" rel="noopener">创客智造</a>的中英文教程，以及安装可能碰到的问题，以“HSP无限94186 ——1比16有刷无控车型”为模型作详细演示，从硬件，软件，系统整合，模型修改等方面介绍Donkeycar智能小车的实现。<br><strong>整体框架：</strong><br><img src="https://s1.ax1x.com/2018/07/15/PMHIqf.png" alt="此处输入图片的描述"><br>1)    Vehicle - a container class to hold and manage all aspects of the vehicle.<br>2)    Parts - modular components of the vehicle that read/write to the memory. This includes sensors, actuators, remote controlers and a datastore.<br>3)    Memory - holds the state of the vehicle and is used to pass variables between parts.<br>4)    Drive loop - a function of the vehicle that runs ensures each part interacts with the memory.</p><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a><font color="red">硬件</font></h2><h3 id="硬件清单"><a href="#硬件清单" class="headerlink" title="硬件清单"></a>硬件清单</h3><h4 id="配件明细"><a href="#配件明细" class="headerlink" title="配件明细"></a>配件明细</h4><h5 id="模型要求："><a href="#模型要求：" class="headerlink" title="模型要求："></a>模型要求：</h5><p>我们需要选择：<br>①独立ESC（电子调速器）和接收机的RC小车<br>②选择三线连接器，三线舵机<br>③选择速度更慢的有刷小车模型更容易实现。</p><h5 id="推荐配置参考："><a href="#推荐配置参考：" class="headerlink" title="推荐配置参考："></a>推荐配置参考：</h5><p>1:16模型配置<br><img src="https://s1.ax1x.com/2018/07/15/PMH7dS.png" alt="此处输入图片的描述"></p><p>1:10模型配置<br><img src="https://s1.ax1x.com/2018/07/15/PMHHIg.png" alt="此处输入图片的描述"><br>参数解释：<br>motor是电机的参数，2040就是表示定子外径是20mm，定子高度是40mm，定子的外径和高度越多，定子的铁芯越大，线圈绕的匝数也越多，表现出来就是电机的功率越大。<br>无刷电机KV值定义为转速/V，意思为输入电压增加1伏特(V)，无刷电机空转转速（转/分钟）增加的转速值。<br>ESC的25A是指持续电流25A，这个峰值电流是85A，BEC输出5V，1A。<br>Tcaction：四驱，双差速器。<br>Groung Clearance：小车底部离地面的距离。</p><h5 id="购买配置清单（价格仅供参考，更新于2018-7-3）"><a href="#购买配置清单（价格仅供参考，更新于2018-7-3）" class="headerlink" title="购买配置清单（价格仅供参考，更新于2018-7-3）"></a>购买配置清单（价格仅供参考，更新于2018-7-3）</h5><table><thead><tr><th>名称</th><th style="text-align:center">淘宝地址</th><th style="text-align:center">价格（税点费+邮费）/元</th><th style="text-align:right">备注</th></tr></thead><tbody><tr><td>小车主体</td><td style="text-align:center"><a href="https://item.taobao.com/item.htm?spm=a1z10.1-c.w4004-10687857697.2.14566a1aBpsYGj&amp;id=524795742343" target="_blank" rel="noopener">https://item.taobao.com/item.htm?spm=a1z10.1-c.w4004-10687857697.2.14566a1aBpsYGj&amp;id=524795742343</a></td><td style="text-align:center">329.8(+20)</td><td style="text-align:right">无限94182——1比16有刷无控车架（有刷不要遥控）电调（已包含）舵机（已包含）</td></tr><tr><td>USB电池</td><td style="text-align:center"><a href="https://detail.tmall.com/item.htm?spm=a230r.1.14.9.2c9e646ctC49zM&amp;id=564303977283&amp;cm_id=140105335569ed55e27b&amp;abbucket=13&amp;skuId=3563362700791" target="_blank" rel="noopener">https://detail.tmall.com/item.htm?spm=a230r.1.14.9.2c9e646ctC49zM&amp;id=564303977283&amp;cm_id=140105335569ed55e27b&amp;abbucket=13&amp;skuId=3563362700791</a></td><td style="text-align:center">49(0.2)</td><td style="text-align:right">2A 5V输出，小米充电宝</td></tr><tr><td>树莓派3B+</td><td style="text-align:center"><a href="https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-14802299686.14.485c40da2EhCk5&amp;id=527630316715" target="_blank" rel="noopener">https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-14802299686.14.485c40da2EhCk5&amp;id=527630316715</a></td><td style="text-align:center">354(21.64)</td><td style="text-align:right">3B E14中国版  套餐16G，包括SD卡及配件</td></tr><tr><td>广角摄像头</td><td style="text-align:center"><a href="https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-14802299686.26.54ba6ae1HJKd7d&amp;id=537191521576" target="_blank" rel="noopener">https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-14802299686.26.54ba6ae1HJKd7d&amp;id=537191521576</a></td><td style="text-align:center">100(6.72)</td><td style="text-align:right">树莓派摄像头5MP</td></tr><tr><td>树莓派杜邦线</td><td style="text-align:center"><a href="https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-14802299686.23.2fd00909E38MRt&amp;id=18189793269" target="_blank" rel="noopener">https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-14802299686.23.2fd00909E38MRt&amp;id=18189793269</a></td><td style="text-align:center">2</td><td style="text-align:right">树莓派连接线</td></tr><tr><td>电机驱动芯片 PCA 9685</td><td style="text-align:center"><a href="https://detail.tmall.com/item.htm?spm=a230r.1.14.1.3bc5178b59bMmJ&amp;id=538283746663&amp;cm_id=140105335569ed55e27b&amp;abbucket=1" target="_blank" rel="noopener">https://detail.tmall.com/item.htm?spm=a230r.1.14.1.3bc5178b59bMmJ&amp;id=538283746663&amp;cm_id=140105335569ed55e27b&amp;abbucket=1</a></td><td style="text-align:center">15(+5.4)</td><td style="text-align:right">资料下载<a href="https://pan.baidu.com/s/1miRuKti" target="_blank" rel="noopener">https://pan.baidu.com/s/1miRuKti</a></td></tr><tr><td>3D打印架</td><td style="text-align:center">CAD Files: a360.co/2pf3Dam STL Files: thingiverse.com/thing:2260575</td><td style="text-align:center">x</td><td style="text-align:right">需要3D打印机</td></tr></tbody></table><h4 id="配件介绍"><a href="#配件介绍" class="headerlink" title="配件介绍"></a>配件介绍</h4><h5 id="HSP无限94182"><a href="#HSP无限94182" class="headerlink" title="HSP无限94182"></a>HSP无限94182</h5><p>模型参数：<br><img src="https://img.alicdn.com/imgextra/i4/13651274/TB2OMaChVXXXXbbXXXXXXXXXXXX_!!13651274.jpg" alt="此处输入图片的描述"><br>模型结构：<br> <img src="https://img.alicdn.com/imgextra/i3/13651274/TB2CqaihVXXXXbwXpXXXXXXXXXX_!!13651274.jpg" alt="此处输入图片的描述"></p><h5 id="电调（Electronic-Speed-Control，ESC）"><a href="#电调（Electronic-Speed-Control，ESC）" class="headerlink" title="电调（Electronic Speed Control，ESC）"></a>电调（Electronic Speed Control，ESC）</h5><p>电子调速器，主要有两个作用，一是将电池降压，适合接收机和其他舵机的工作电压；二是从接收机获得油门信号，控制马达的转速，从而改变飞机的速度。<br>❤连接方式为：<br>1、电调的输入线与电池连接；<br>2、电调的输出线（有刷两根、无刷三根）与电机连接；（在我们用到的有刷模型中，是红色和黑色的两根比较粗的线）<br>3、电调的信号线（三根红色，白色和黑色的较细的线）与接收机（PCA驱动芯片）连接。</p><h5 id="舵机"><a href="#舵机" class="headerlink" title="舵机"></a>舵机</h5><p>舵机的工作原理：舵机常用的控制信号是一个周期为20毫秒左右，宽度为1毫秒到2毫秒的脉冲信号。当舵机收到该信号后，会马上激发出一个与之相同的，宽度为1.5毫秒的负向标准的中位脉冲。之后二个脉冲在一个加法器中进行相加得到了所谓的差值脉冲。输入信号脉冲如果宽于负向的标准脉冲，得到的就是正的差值脉冲。如果输入脉冲比标准脉冲窄，相加后得到的肯定是负的脉冲。此差值脉冲放大后就是驱动舵机正反转动的动力信号。舵机电机的转动，通过齿轮组减速后，同时驱动转盘和标准脉冲宽度调节电位器转动。直到标准脉冲与输入脉冲宽度完全相同时，差值脉冲消失时才会停止转动。<br>❤连接方式：将输出的三线与对应的PCA驱动板引脚连接。电调和舵机都是标准3线母插头连接只要按照对应的引脚插入驱动板就可以了。(地线一般为黑色或棕色、信号线一般为黄色或白色)。</p><h5 id="树莓派-miscro-SD存储卡："><a href="#树莓派-miscro-SD存储卡：" class="headerlink" title="树莓派+miscro SD存储卡："></a>树莓派+miscro SD存储卡：</h5><p>Raspberry Pi(中文名为“树莓派”,简写为RPi，(或者RasPi / RPI) <a href="https://docs.donkeycar.com/" target="_blank" rel="noopener">1</a>  是为学习计算机编程教育而设计，只有信用卡大小的微型电脑，其系统基于Linux。<br>关于树莓派的详细教程参考<a href="https://img.alicdn.com/imgextra/i4/13651274/TB2OMaChVXXXXbbXXXXXXXXXXXX_!!13651274.jpg" target="_blank" rel="noopener">7</a>。<br>Raspberry Pi 3B+主板图解：<br><img src="https://s1.ax1x.com/2018/07/15/PMHqiQ.png" alt="此处输入图片的描述"><br>树莓派主板图解<br><img src="https://s1.ax1x.com/2018/07/15/PMHORs.jpg" alt="此处输入图片的描述"></p><p>树莓派引脚GPIO定义<br>❤连接方式：<br>1、USB电源接口接入充电宝电源<br>2、摄像头接口连接摄像头<br>3、树莓派和PCA9685连接：只连四根线，3.3v，两根 I2C 引脚 (SDA 和 SCL)，地线 ground。</p><h5 id="PCA电机驱动芯片9685（舵机驱动板）"><a href="#PCA电机驱动芯片9685（舵机驱动板）" class="headerlink" title="PCA电机驱动芯片9685（舵机驱动板）"></a>PCA电机驱动芯片9685（舵机驱动板）</h5><p>资料下载：<a href="https://pan.baidu.com/s/1miRuKti" target="_blank" rel="noopener">https://pan.baidu.com/s/1miRuKti</a><br>详细教程参考<a href="https://s1.ax1x.com/2018/07/15/PMHqiQ.png" target="_blank" rel="noopener">9</a>。</p><p>PCA9685是一款基于IIC总线通信的12位精度16通道PWM波输出的芯片, 可用于控制舵机、led、电机等设备，i2c通信，节省主机资源。<br>❤连接和使用方式：<br>1、    连接树莓派：<br>GND -&gt; RPi GND（9脚）<br>SCL -&gt; RPi SCL1（5脚）<br>SDA -&gt; RPi SDA1（3脚）<br>VCC -&gt; RPi 3.3V （1脚）<br>V+ -&gt; RPi 5V（本实验中PCA上的V+接口不需要接入电源）</p><p>树莓派和PCA9685连接图<br><img src="https://s1.ax1x.com/2018/07/15/PMHXzn.png" alt="此处输入图片的描述"><br>2、    连接舵机和电调：电调和舵机都是标准3线母插头连接只要按照对应的引脚插入驱动板就可以了。(地线一般为黑色或棕色、信号线一般为黄色或白色，所以对应黑色的线要插在GND对应的针头)。</p><p>PCA9685连接图<br>在上图中，两股标准3线母插头分别连接舵机与电调。</p><h5 id="广角摄像头"><a href="#广角摄像头" class="headerlink" title="广角摄像头"></a>广角摄像头</h5><p>WARNING：不要在树莓派开机时插拔摄像头！<br>摄像头需要满足的参数：<br><img src="https://s1.ax1x.com/2018/07/15/PMHvMq.png" alt="此处输入图片的描述"><br>购买的Camera 5MP广角摄像头参数：<br><img src="https://s1.ax1x.com/2018/07/15/PMHxs0.png" alt="此处输入图片的描述"></p><h5 id="充电宝"><a href="#充电宝" class="headerlink" title="充电宝"></a>充电宝</h5><p>提供5v2A的usb输出和12V输出，主要给树莓派供电<br>❤连接方式：将充电宝的输出microusb输出连接到树莓派的电源输入端。</p><h5 id="3D打印架"><a href="#3D打印架" class="headerlink" title="3D打印架"></a>3D打印架</h5><p><img src="https://s1.ax1x.com/2018/07/15/PMHzLV.png" alt="此处输入图片的描述"><br>❤用螺丝和销钉固定在小车车架上。</p><h5 id="杜邦线"><a href="#杜邦线" class="headerlink" title="杜邦线"></a>杜邦线</h5><p>杜邦线可用于实验板的引脚扩展，增加实验项目等。可以非常牢靠地和插针连接,无需焊接,可以快速进行电路试验。<br>本实验中，用来连接树莓派与PCA驱动芯片的对应引脚。<br><img src="https://s1.ax1x.com/2018/07/15/PMbpZT.jpg" alt="此处输入图片的描述"></p><h3 id="硬件组装"><a href="#硬件组装" class="headerlink" title="硬件组装"></a>硬件组装</h3><h4 id="组装流程"><a href="#组装流程" class="headerlink" title="组装流程"></a>组装流程</h4><p>1)，2)两步为3D打印步骤，如果不适用3D打印，可以用纸板和小刀手工完成顶部结构。<br>1)    打印部件（3D打印）<br>用黑色PLA打印零件，层高2毫米，没有支撑。顶部翻转杆设计成倒置打印。<br>用黑色PLA打印零件，0.3mm层高，一个0.5mm喷嘴，没有支撑。顶部翻转杆设计成倒置打印。<br>打印的结构图：<br><img src="https://s1.ax1x.com/2018/07/15/PMHzLV.png" alt="此处输入图片的描述"><br>2)    清理零件（手工修正）<br>几乎所有3D打印部件都需要清理。重新钻孔，并清理多余的塑料。</p><p><img src="http://images.ncnynl.com/ros/2018/hardware_ass_2a.png" alt="此处输入图片的描述"><br><img src="http://images.ncnynl.com/ros/2018/hardware_ass_2b.png" alt="此处输入图片的描述"></p><p>3)    组装顶板结构，树莓派电源充电宝<br>顶部结构手工完成后的图片：</p><p>4)    将PCA驱动板连接到树莓派<br>利用杜邦线连接，对应的针脚如下：<br>GND -&gt; RPi GND（9脚）<br>SCL -&gt; RPi SCL1（5脚）<br>SDA -&gt; RPi SDA1（3脚）<br>VCC -&gt; RPi 3.3V （1脚）<br>V+ -&gt; RPi 5V（本实验中PCA上的V+接口不需要接入电源）<br>本实验只需要连接四个针脚即可。</p><p>5)    将树莓派和PCA驱动板附加到3D打印的底板上。</p><p>6)    安装摄像头<br>使用摄像头前，取下相机镜头上的塑料薄膜。<br>安装方式：将树莓派上摄像头插销扒开，插入相机电缆，注意触点的位置，随后按入插销即可。<br><img src="http://images.ncnynl.com/ros/2018/hardware_ass_6a.png" alt="此处输入图片的描述"><br><img src="http://images.ncnynl.com/ros/2018/hardware_ass_6b.png" alt="此处输入图片的描述"></p><p>7)    硬件整合<br>舵机与电调已经在小车上固定好，所以接下来只需用三线母插头把PCA驱动板连接舵机与电调。因为电调和舵机都是标准3线母插头连接只要按照对应的引脚插入驱动板就好。(地线一般为黑色或棕色、信号线一般为黄色或白色，所以对应黑色的线要插在GND对应的针头)。</p><h4 id="组装完成"><a href="#组装完成" class="headerlink" title="组装完成"></a>组装完成</h4><p>几种不同形态智能小车的完成体：<br><img src="http://images.ncnynl.com/ros/2018/donkey.png" alt="此处输入图片的描述"><br><img src="https://s1.ax1x.com/2018/07/15/PMb9dU.jpg" alt="此处输入图片的描述"><br><img src="https://s1.ax1x.com/2018/07/15/PMbCoF.jpg" alt="此处输入图片的描述"></p><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a><font color="red">软件</font></h2><h3 id="软件清单"><a href="#软件清单" class="headerlink" title="软件清单"></a>软件清单</h3><p>❤系统：<br>树莓派系统<br>Ubuntu系统<br>❤在linux下安装donkeycar<br>安装依赖：virtualenv build-essential python3-dev gfortran libhdf5-dev<br><a href="https://github.com/wroscoe/donkey" target="_blank" rel="noopener">https://github.com/wroscoe/donkey</a><br>❤在Windows下安装donkeycar<br><a href="https://conda.io/miniconda.html" target="_blank" rel="noopener">https://conda.io/miniconda.html</a><br><a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a><br>git库<a href="https://github.com/wroscoe/donkey" target="_blank" rel="noopener">https://github.com/wroscoe/donkey</a><br>❤在MAC下安装donkeycar<br><a href="https://conda.io/miniconda.html" target="_blank" rel="noopener">https://conda.io/miniconda.html</a><br><a href="https://www.atlassian.com/git/tutorials/install-git" target="_blank" rel="noopener">https://www.atlassian.com/git/tutorials/install-git</a><br>xcode-select –install<br>pip install <a href="https://storage.googleapis.com/tensorflow/mac/cpu/tensorflow-1.3.0-py3-none-any.whl" target="_blank" rel="noopener">https://storage.googleapis.com/tensorflow/mac/cpu/tensorflow-1.3.0-py3-none-any.whl</a><br>开源机器学习框架：<br>❤pip install keras==2.0.6<br>❤pip install tensorflow==1.3.0</p><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><h4 id="安装树莓派系统"><a href="#安装树莓派系统" class="headerlink" title="安装树莓派系统"></a>安装树莓派系统</h4><p>将SD卡用读卡器连接到本地PC。<br>首先为树莓派安装固件，下载地址：<br><a href="https://www.dropbox.com/s/wiudnm2dcsvoquu/donkey_v22.img.zip?dl=0" target="_blank" rel="noopener">https://www.dropbox.com/s/wiudnm2dcsvoquu/donkey_v22.img.zip?dl=0</a><br>安装步骤：<br>方法1：使用<a href="https://s1.ax1x.com/2018/07/15/PMHHIg.png" target="_blank" rel="noopener">6</a>中的推荐步骤<br><img src="https://s1.ax1x.com/2018/07/15/PMbFJJ.png" alt="此处输入图片的描述"><br>方法2：利用安装软件Etcher。<br>    安装方法参考教程<a href="https://bbs.pediy.com/thread-221193.htm" target="_blank" rel="noopener">（For ubuntu）</a>,<a href="http://www.xue51.com/soft/2044.html" target="_blank" rel="noopener">（For windows）</a>。</p><h4 id="设置wifi连接"><a href="#设置wifi连接" class="headerlink" title="设置wifi连接"></a>设置wifi连接</h4><p>我们需要让树莓派连接wifi热点，从而可以无线操控小车。方法有两种：<br>方法1：SD卡插入树莓派，显示屏，键盘和鼠标连入树莓派，开机后通过界面链接wifi。<br>方法2：（没有显示屏和键鼠条件下）<br>首先，新建一个无线热点。可以使用本地PC新建wifi热点。记录ssid和password。<br>接下来修改树莓派的系统文件：<br>在boot部分的根目录下，新建文件名为wpa_supplicant.conf的文件，文件内容为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">country=US</span><br><span class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line">update_config=1</span><br><span class="line">network=&#123;</span><br><span class="line">   ssid=&quot;&lt;your network name&gt;&quot;</span><br><span class="line">    psk=&quot;&lt;your password&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分别在ssid和psk设置自己的WiFi用户名和密码，注意不能有&lt;&gt;，</p><h4 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h4><p>如果网络中有多个树莓派，还需要修改本树莓派的用户名,以下命令需要将sd卡挂载到Linux上运行，由于创建本文档时只有一个树莓派，所以并没有修改用户名，本文档的所有用户名均为pi，若读者对树莓派的用户名有修改，登录时需要改成自己的用户名和密码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /media/userID/UUID/etc/hostname</span><br><span class="line">sudo vi /media/userID/UUID/etc/hosts</span><br></pre></td></tr></table></figure></p><p>注意用户名只能是小写。<br>然后把SD卡插进树莓派里，给树莓派上电。</p><h4 id="设置SSH远程登录"><a href="#设置SSH远程登录" class="headerlink" title="设置SSH远程登录"></a>设置SSH远程登录</h4><p>首先查看网络环境，树莓派连接的网络是本地连接13创建的共享热点：<br><img src="https://s1.ax1x.com/2018/07/15/PMbudO.png" alt="此处输入图片的描述"><br>用抓包工具或者nmap扫描工具查找树莓派的ip地址：<br><img src="https://s1.ax1x.com/2018/07/15/PMbAzR.png" alt="此处输入图片的描述"><br>或者可以用cmd自带的ARP命令查看相应地址的ARP缓存也可以找到小车地址，arp -a<br>从上图可以找到树莓派的ip地址是192.168.155.2，接着通过ssh登录树莓派，用户名pi,密码asdfasdf ，登录进去之后界面如图所示：<br><img src="https://s1.ax1x.com/2018/07/15/PMbZsx.png" alt="此处输入图片的描述"><br>另外，可以通过win10自带的移动热点看到连接设备的IP地址：<br><img src="https://s1.ax1x.com/2018/07/15/PMbeL6.png" alt="此处输入图片的描述"><br>推荐使用的ssh客户端登录软件比如Xshell。</p><h4 id="在树莓派镜像安装，升级donkeycar"><a href="#在树莓派镜像安装，升级donkeycar" class="headerlink" title="在树莓派镜像安装，升级donkeycar"></a>在树莓派镜像安装，升级donkeycar</h4><p>存储卡图像上的donkeycar Python代码可能比Github repo上的要早，所以一旦你运行了Pi，需要更新，在ssh客户端连接树莓派后，键入命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/donkeycar</span><br><span class="line">git pull</span><br><span class="line">pip install -e .</span><br></pre></td></tr></table></figure></p><h4 id="在本地PC安装donkeycar并创建本地工作目录"><a href="#在本地PC安装donkeycar并创建本地工作目录" class="headerlink" title="在本地PC安装donkeycar并创建本地工作目录"></a>在本地PC安装donkeycar并创建本地工作目录</h4><p>接下来是在本地笔记本电脑或服务器上设置相同的代码库，以便测试和训练智能小车。安装因平台而异。有如下三种方法，仅给出了windows上的安装结果。</p><h5 id="Windows系统"><a href="#Windows系统" class="headerlink" title="Windows系统"></a>Windows系统</h5><p>❤安装miniconda Python 3.6 64 bit. <a href="https://conda.io/miniconda.html" target="_blank" rel="noopener">https://conda.io/miniconda.html</a><br>❤确保选中该框以允许它修改您的系统路径变量以添加conda。<br>❤安装git 64 bit，<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a><br>❤从开始菜单启动Anaconda<br>❤更改为您希望用作项目主管的目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir projects</span><br><span class="line">cd projects</span><br></pre></td></tr></table></figure></p><p>❤安装donkeycar<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/wroscoe/donkey</span><br><span class="line">cd donkey</span><br></pre></td></tr></table></figure></p><p>❤创建Python Anaconda环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda env create -f envs\windows.yml</span><br><span class="line">activate donkey</span><br></pre></td></tr></table></figure></p><p>❤安装代码源并创建您的本地工作目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install -e .</span><br><span class="line">donkey createcar --path ~/d2 #本地工作目录名称设置为d2，可以自己定义</span><br></pre></td></tr></table></figure></p><p>安装结果：<br><img src="https://s1.ax1x.com/2018/07/15/PMbkW9.png" alt="此处输入图片的描述"><br>注意：在关闭Anaconda提示符后，当再次打开它时，您需要键入activate donkey以重新启用映射到特定于donkey的Python库。（关于anaconda的使用，可以参考<a href="https://s1.ax1x.com/2018/07/15/PMHORs.jpg" target="_blank" rel="noopener">10</a>）<br>项目主管目录示例：<br><img src="https://s1.ax1x.com/2018/07/15/PMbVQ1.png" alt="此处输入图片的描述"><br>创建的本地工作目录示例：<br><img src="https://s1.ax1x.com/2018/07/15/PMbneK.png" alt="此处输入图片的描述"></p><h5 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h5><p>❤安装依赖和python环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install virtualenv build-essential python3-dev gfortran libhdf5-dev</span><br><span class="line">virtualenv env -p python3</span><br><span class="line">source env/bin/activate</span><br><span class="line">pip install keras==2.0.6</span><br><span class="line">pip install tensorflow==1.3.0</span><br></pre></td></tr></table></figure></p><p>❤安装donkeycar<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/wroscoe/donkey donkeycar</span><br><span class="line">pip install -e donkeycar</span><br></pre></td></tr></table></figure></p><h5 id="Mac系统"><a href="#Mac系统" class="headerlink" title="Mac系统"></a>Mac系统</h5><p>❤安装miniconda Python 3.6 64 bit. <a href="https://conda.io/miniconda.html" target="_blank" rel="noopener">https://conda.io/miniconda.html</a><br>❤安装git 64 bit，<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a><br>❤启动终端<br>❤如果Xcode or gcc 没安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure></p><p>❤创建项目根目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir projects</span><br><span class="line">cd projects</span><br></pre></td></tr></table></figure></p><p>❤下载donkeycar<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/wroscoe/donkey</span><br><span class="line">cd donkey</span><br></pre></td></tr></table></figure></p><p>❤创建Python Anaconda环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda env create -f envs/mac.yml</span><br><span class="line">source activate donkey</span><br></pre></td></tr></table></figure></p><p>❤安装Tensorflow<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install https://storage.googleapis.com/tensorflow/mac/cpu/tensorflow-1.3.0-py3-none-any.whl</span><br></pre></td></tr></table></figure></p><p>❤安装donkey<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install -e .</span><br><span class="line">donkey createcar --path ~/d2</span><br></pre></td></tr></table></figure></p><p>注意：关闭终端后，当您再次打开终端时，您需要键入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source activate donkey</span><br></pre></td></tr></table></figure></p><p>来重新启用映射到特定于donkey的Python库。</p><h2 id="运行智能小车"><a href="#运行智能小车" class="headerlink" title="运行智能小车"></a><font color="red">运行智能小车</font></h2><p>WARNING：先放置到安全地方并让轮子离地！</p><h3 id="Windows系统-1"><a href="#Windows系统-1" class="headerlink" title="Windows系统"></a>Windows系统</h3><p>-打开Anaconda<br>-激活映射到donkey的Python设置：<br><figure class="highlight plain"><figcaption><span>donkey</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">-进入管理donkey的本地目录：</span><br><span class="line">```cd ~/d2</span><br></pre></td></tr></table></figure></p><h3 id="远程登录树莓派"><a href="#远程登录树莓派" class="headerlink" title="远程登录树莓派"></a>远程登录树莓派</h3><p>-用Xshell登录，详细见3.2.4节。</p><h3 id="启动和控制小车"><a href="#启动和控制小车" class="headerlink" title="启动和控制小车"></a>启动和控制小车</h3><p>-在Xshell连接成功后，打开你小车目录，并开启小车<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/d2</span><br><span class="line">python manage.py drive</span><br></pre></td></tr></table></figure></p><p>-这个脚本将启动你的小车，其中包括一个作为Web服务器的部件，以便控制你的小车。<br>-现在可以通过以下网址从网络浏览器控制您的汽车：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;your car&apos;s IP&apos;s address&gt;:8887</span><br></pre></td></tr></table></figure></p><p>接下来在本地PC通过浏览器（推荐Chrome浏览器）登录上述网址，在web端控制智能小车：<br><img src="https://s1.ax1x.com/2018/07/15/PMbYOP.png" alt="此处输入图片的描述"></p><h3 id="校准小车"><a href="#校准小车" class="headerlink" title="校准小车"></a>校准小车</h3><p>小车的配置信息是存在config.py脚本中的，这个脚本会在运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">donkey createcar --path ~/d2</span><br></pre></td></tr></table></figure></p><p>这个命令之后出现在”./d2”这个目录下，如下所示：<br><img src="https://s1.ax1x.com/2018/07/15/PMbwFg.png" alt="此处输入图片的描述"><br>其内容是各个部件的参数配置：<br><img src="https://s1.ax1x.com/2018/07/15/PMb8SA.png" alt="此处输入图片的描述"><br>校准小车的目的就是将上述参数调整到合适的值，这样才能顺利的驾驶小车，以及共享同款小车的校准数据。</p><h4 id="舵机校准（转向校准）"><a href="#舵机校准（转向校准）" class="headerlink" title="舵机校准（转向校准）"></a>舵机校准（转向校准）</h4><p>要填的数据有：<br><img src="https://s1.ax1x.com/2018/07/15/PMbJyt.png" alt="此处输入图片的描述"><br>注意，此时应让小车离开地面，避免乱跑<br>1、    打开小车，找到舵机伺服电缆插到了PCA的那个通道上了，应该是1或者0.<br>2、    运行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">donkey calibrate --channel &lt;your_steering_channel&gt;</span><br></pre></td></tr></table></figure></p><p>3、    输入 360’会看到小车的轮子轻微转动，如果没有的话就输入400或者300<br>4、    左右调整 +/- 10，一直到轮子完全转向左边或者右边，记录此时的值，并填入config.py</p><h4 id="马力校准（电机控制）"><a href="#马力校准（电机控制）" class="headerlink" title="马力校准（电机控制）"></a>马力校准（电机控制）</h4><p>需要校准的参数：<br><img src="https://s1.ax1x.com/2018/07/15/PMb0YQ.png" alt="此处输入图片的描述"><br>1、    找到ESC的电缆，看看它插到PCA的哪个位置，这就是马力通道。<br>2、    运行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">donkey calibrate --channel &lt;your_throttle_channel&gt;</span><br></pre></td></tr></table></figure></p><p>当提示输入PWM值的时候输入370，此时应该能听到ESC发出哔哔声，表示已经经过校准。<br>3、    输入400，这时小车应该就能往前走了，如果不能往前，则有可能是反向的，此时应该输入330<br>4、    多尝试几次，直到找到你认为比较合适的最大速度，记下此时的PWM值。</p><h4 id="校准微调"><a href="#校准微调" class="headerlink" title="校准微调"></a>校准微调</h4><p>现在小车已经校准过了，可以开动小车查看是否按照预期运行：<br>1、    运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py drive</span><br></pre></td></tr></table></figure></p><p>命令启动小车<br>2、    在浏览器中访问<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;your_cars_ip_address&gt;:8887</span><br></pre></td></tr></table></figure></p><p>3、    按j，一直到小车的方向完全转向右边<br>4、    按i，一直到小车的方向完全朝向前方<br>5、    测量转弯直径，并将它记录在表格中<br>6、    在不同的转向值下重复同样的测量<br>7、    绘制表格看看小车在各个方向的转向是否相同（角度相同时）<br>如果你的转向在80%PWM和100%PWM相同时，将PWM值变为80%PWM,<br>如果你的车往一边偏，改变另一边的PWM值<br>经过微调之后你的表格大概会是这个样子<br><img src="https://s1.ax1x.com/2018/07/15/PMbUw8.png" alt="此处输入图片的描述"></p><h2 id="训练智能小车"><a href="#训练智能小车" class="headerlink" title="训练智能小车"></a><font color="red">训练智能小车</font></h2><h3 id="赛道设置"><a href="#赛道设置" class="headerlink" title="赛道设置"></a>赛道设置</h3><p>可以用带颜色的胶带、丝带或者绳子，赛道最好宽4英尺，并且有2英寸的白色边框和黄色虚线中线。</p><h3 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h3><p>①    先不记录数据，在跑道上跑几圈，当熟练跑道之后（10圈以上不出错）点击按钮Start Recording<br><img src="https://s1.ax1x.com/2018/07/15/PMbBWj.png" alt="此处输入图片的描述"><br>②    如果出错或者有意外发生时马上点击Stop Car停止记录<br>③    至少收集10-20圈好的数据之后即可以停止收集，Ctrl-c即可，收集的数据在data文件夹里</p><p>需要注意的细节：<br>1，    清除d2/data目录下的之前的数据<br>2，    回到d2目录下 python namage.py drive启动小车<br>3，    到浏览器中model选择user，然后用电脑控制小车在场景下跑几圈<br>4，    等到操作小车在场景下基本不出错之后点击start recording开始记录数据<br>5，    记录大约半个小时的数据就可以了<br>注意在记录数据的过程中，可能会出现小车没电的情况，解决的办法就是，刚开始在config.py文件中把THROTTLE_FORWARD_PWM设置的小一点，本车是335或者330，过一会感觉小车跑的变慢了，停止记录，停下小车，关闭程序。调整THROTTLE_FORWARD_PWM变大一点到440，重启程序，记得保持小车的运行速度以及Throttle差不多一致。同理慢慢可以变为445和450<br>6，    记录完数据，筛选数据。手动删除数据中撞墙等不好的数据<br>7，    将数据考到电脑上装的donkey的d2/data目录下（小文件太多，速度会特别慢）<br>8，    进入d2目录，运行命令 python manage.py train –model ~/d2/models/mypilot<br>9，    等待训练结束，到到d2/models下将mypilot文件发送到小车的对应目录下<br>10，    用命令python manage.py drive –model ~/d2/models/mypilot启动小车，然后到浏览器中选择local pilot模式启动自动驾驶</p><h3 id="拷贝数据至本地PC"><a href="#拷贝数据至本地PC" class="headerlink" title="拷贝数据至本地PC"></a>拷贝数据至本地PC</h3><p>由于树莓派计算能力有限，需要将数据迁移到电脑上进行模型的训练，有两种方法：<br>方法1：新开一个SSH窗口用rsync命令从树莓派复制数据。命令如下：<br>rsync -r pi@&lt;your_pi_ip_address&gt;:~/d2/data/  ~/d2/data/<br>方法2：利用Xshell里面的新建文件传输直接复制粘贴。<br><img src="https://s1.ax1x.com/2018/07/15/PMbaTS.md.png" alt="此处输入图片的描述"></p><h3 id="利用keras训练模型"><a href="#利用keras训练模型" class="headerlink" title="利用keras训练模型"></a>利用keras训练模型</h3><p>复制好数据之后就可以运行训练脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python ~/d2/manage.py train --tub &lt;tub folder names comma separated&gt; --model ./models/mypilot</span><br></pre></td></tr></table></figure></p><p>或者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python ~/d2/manage.py train --model ~/d2/models/mypilot</span><br></pre></td></tr></table></figure></p><p><img src="https://s1.ax1x.com/2018/07/15/PMbrSs.png" alt="此处输入图片的描述"></p><h3 id="拷贝模型至树莓派"><a href="#拷贝模型至树莓派" class="headerlink" title="拷贝模型至树莓派"></a>拷贝模型至树莓派</h3><p>训练好之后再讲pilot迁移回树莓派：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -r ~/d2/models/ pi@&lt;your_ip_address&gt;:~/d2/models/</span><br></pre></td></tr></table></figure></p><h3 id="用自动驾驶模型启动小车"><a href="#用自动驾驶模型启动小车" class="headerlink" title="用自动驾驶模型启动小车"></a>用自动驾驶模型启动小车</h3><p>重新启动小车，将训练好的模型穿进去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py drive --model ~/d2/models/mypilot</span><br></pre></td></tr></table></figure></p><h3 id="用模拟器训练小车"><a href="#用模拟器训练小车" class="headerlink" title="用模拟器训练小车*"></a>用模拟器训练小车*</h3><p>用于生成训练用的图片，测试自动驾驶仪等。当然你也可以不用这种方法，根据网页【<a href="http://docs.donkeycar.com/guide/build_hardware/】的描述，你也可以先用手机控制小车在赛道上开10-20次来收集训练数据。" target="_blank" rel="noopener">http://docs.donkeycar.com/guide/build_hardware/】的描述，你也可以先用手机控制小车在赛道上开10-20次来收集训练数据。</a><br>下载之后直接双击EXE文件运行，你可以在input里面看到控制按钮信息。<br><img src="https://s1.ax1x.com/2018/07/15/PMbRTU.png" alt="此处输入图片的描述"><br><img src="https://s1.ax1x.com/2018/07/15/PMb2wT.png" alt="此处输入图片的描述"><br>模拟器中共有三个场景，但是网站【<a href="http://docs.donkeycar.com/guide/simulator/】中只给了前两种的描述，第三种是sparkfun" target="_blank" rel="noopener">http://docs.donkeycar.com/guide/simulator/】中只给了前两种的描述，第三种是sparkfun</a> AVC机器人大赛的场景：<br>Generated Road Scene：通用场景<br>The purpose of this is to create a randomly generated road so that you can have miles of curves on different road surfaces. You can train on one road and test on something similar, or a totally different surface.<br>Warehouse Scene：专用场景<br>The purpose of this is to create a specific track that is somewhat similar to an actual course in use as the primary track for the Oakland DIYRobocars Meetup.<br><img src="https://s1.ax1x.com/2018/07/15/PMbfkF.md.png" alt="此处输入图片的描述"></p><p>进入模拟器，右上角可以选择操作选项，根据网站【<a href="http://docs.donkeycar.com/guide/simulator/】的介绍，Joystick/Keyboard" target="_blank" rel="noopener">http://docs.donkeycar.com/guide/simulator/】的介绍，Joystick/Keyboard</a> No Rec的意思就是摇杆或者键盘控制，但是数据不记录，其他选项意思类推。Next Track：在生成的道路场景中，这将改变路面和轨道宽度。Regen Track：使用当前的表面类型，但生成一个新的随机路径和路径。<br>下图为我用键盘控制时的截图，在网站【<a href="http://docs.donkeycar.com/guide/simulator/】的介绍中，有一个注意事项是这样描述的：Note" target="_blank" rel="noopener">http://docs.donkeycar.com/guide/simulator/】的介绍中，有一个注意事项是这样描述的：Note</a>: Keyboard data produces steering information that is stepped (ie. -1, 0, +1) and may be difficult to train with. See below for joystick setup.大意是说由于键盘控制并不像摇杆可以产生连续的转向信息，而只能是间断的，所以并不适合用来训练。<br><img src="https://s1.ax1x.com/2018/07/15/PMbhY4.png" alt="此处输入图片的描述"><br>键盘控制页面<br>下图为自动驾驶页面，可以看到左下角一共有四个参数，目前并没有搞得很清楚这四个参数的具体含义，暂且先贴出网页【<a href="http://docs.donkeycar.com/guide/simulator/】上的解释：" target="_blank" rel="noopener">http://docs.donkeycar.com/guide/simulator/】上的解释：</a><br>Max Speed：这个应该就是决定了自动驾驶的最大速度<br>This setting determines the target speed during the PID auto drive. It will also affect the speed when driving by keyboard controls (not recommended).<br>Prop：转向角度<br>This is short for proportional. This is the P part of PID that attempts to adjust steering back to the path in proportion to the deviation.<br>Diff：为了防止角度调整过大<br>This is the D part of PID that attempts to limit steering back to the path as derivative to the trend of deviation, designed to limit overshoot.<br>Max Steering<br>Max steering can only be adjusted when using Auto Drive No Rec. It will also affect joystick and keyboard steering range, and should be saved and reloaded for you.<br>另外关于这个参数，原文中有一个注意事项： Max Steering is an important adjustment. This affects categorical training quite strongly. As the steering data is normalized when written, and multiplies after coming from Python, this angle should remain constant over training and simulation. Take care when changing this value. And separate data and models by max steering setting.<br><img src="https://s1.ax1x.com/2018/07/15/PMb4fJ.md.png" alt="此处输入图片的描述"><br>自动驾驶时的截图<br>训练结束后，在log目录中会有训练的图片，图片大小为160*120像素<br><img src="https://s1.ax1x.com/2018/07/15/PMbgmV.md.png" alt="此处输入图片的描述"><br>贴一个网页【<a href="http://docs.donkeycar.com/guide/simulator/】上给出的典型用法，方便以后使用。" target="_blank" rel="noopener">http://docs.donkeycar.com/guide/simulator/】上给出的典型用法，方便以后使用。</a><br><img src="https://s1.ax1x.com/2018/07/15/PMb6O0.png" alt="此处输入图片的描述"></p><h2 id="更新DonkeycarV2-5教程"><a href="#更新DonkeycarV2-5教程" class="headerlink" title="更新DonkeycarV2.5教程"></a>更新DonkeycarV2.5教程</h2><ol><li>用Etcher给SD卡写入树莓派系统<a href="https://drive.google.com/uc?id=1vr4nEXLEh4xByKAXik8KhK3o-XWgo2fQ&amp;export=download" target="_blank" rel="noopener">镜像文件名为：donkey_2.5.0_pi3.img</a>，新建并编辑boot目录下的wpa_supplicant.conf文件。</li><li><p>SSH连接树莓派并登陆。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户名：pi</span><br><span class="line">密码：raspberry</span><br></pre></td></tr></table></figure></li><li><p>在树莓派上安装Donkeycar V2.5.1环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a)pip install donkeycar[pi]</span><br><span class="line">b)donkey createcar ~/</span><br></pre></td></tr></table></figure></li><li><p>在windows上安装DonkeycarV2.5.1<br>（注意区分本地工作目录与本地代码目录）<br>a)    新建一个本地代码目录，存放代码库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir projects</span><br><span class="line">cd projects</span><br></pre></td></tr></table></figure></li></ol><p>b)    从github上clone最新的donkeycar代码库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/wroscoe/donkey</span><br><span class="line">cd donkey</span><br></pre></td></tr></table></figure></p><p>c)    安装donkeycar资源环境，新建本地工作目录（mycar）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install -e .</span><br><span class="line">donkey createcar C:\Users\WuFan\new_mycar(自己修改)</span><br></pre></td></tr></table></figure></p><ol><li>会遇到的问题：<br>a)    ModuleNotFoundError: No module named ‘controller’：<br>解决办法：<br>将文件<br>（可直接复制粘贴word中的这个文件）<br>拷贝至\donkey\donkeycar\parts对应的本地代码目录下。<br>修改本地工作目录中文件“manage.py”中第24行，修改为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from donkeycar.parts.controller import LocalWebController, JoystickController</span><br></pre></td></tr></table></figure></li></ol><p>b)    训练后的数据存放在树莓派tub文件夹下，而不是data</p><p>训练的时候，把tub文件夹下所有数据复制到本地工作目录下的data文件夹下。再开始训练。</p><p>c)  大家在用训练的模型驾驶的时候，切换到local pilot时，可能会遇到类似摄像头框消失，树莓派报错的情况。</p><p>这是因为树莓派上有的python文件版本和本地电脑从github上面clone的文件不一致。如果有报这种错误，可以把本地代码库上面的对应文件覆盖到树莓派上解决。</p><h2 id="参考创新方向"><a href="#参考创新方向" class="headerlink" title="参考创新方向"></a><font color="red">参考创新方向</font></h2><h3 id="无人驾驶车障碍竞速"><a href="#无人驾驶车障碍竞速" class="headerlink" title="无人驾驶车障碍竞速"></a>无人驾驶车障碍竞速</h3><h3 id="无人取件车-送餐车-领路车"><a href="#无人取件车-送餐车-领路车" class="headerlink" title="无人取件车/送餐车/领路车"></a>无人取件车/送餐车/领路车</h3><h3 id="无人捡球车"><a href="#无人捡球车" class="headerlink" title="无人捡球车"></a>无人捡球车</h3><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li style="list-style: none"><input type="checkbox"> <a href="https://docs.donkeycar.com/" target="_blank" rel="noopener">https://docs.donkeycar.com/</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.ncnynl.com/archives/201804/2398.html" target="_blank" rel="noopener">https://www.ncnynl.com/archives/201804/2398.html</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://github.com/OSSDC/donkey" target="_blank" rel="noopener">https://github.com/OSSDC/donkey</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://github.com/wroscoe/donkey\" target="_blank" rel="noopener">https://github.com/wroscoe/donkey\</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://docs.donkeycar.com/guide/build_hardware/" target="_blank" rel="noopener">https://docs.donkeycar.com/guide/build_hardware/</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.donkeycar.com/" target="_blank" rel="noopener">https://www.donkeycar.com/</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.makerspace.cn/thread-5681-1-1.html" target="_blank" rel="noopener">http://www.makerspace.cn/thread-5681-1-1.html</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.raspberrypi.org/blog/self-driving-car/" target="_blank" rel="noopener">https://www.raspberrypi.org/blog/self-driving-car/</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://blog.csdn.net/nicekwell/article/details/53616277" target="_blank" rel="noopener">https://blog.csdn.net/nicekwell/article/details/53616277</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://python.jobbole.com/87522/" target="_blank" rel="noopener">https://python.jobbole.com/87522/</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://bbs.pediy.com/thread-221193.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-221193.htm</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.xue51.com/soft/2044.html" target="_blank" rel="noopener">https://www.xue51.com/soft/2044.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;本教程是基于Donkeycar的智能小车教程。DonkeyCar小车是基于树莓派和Python，利用Keras深度学习框架实现的自动驾驶小车。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ss0.baidu.com/73F1bjeh1BF3odCf/it/u=2559738123,4256387987&amp;amp;fm=85&amp;amp;s=752AB952CCB777A7958C48AE03007022&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="guidance" scheme="https://yoursite.com/categories/guidance/"/>
    
    
      <category term="notes" scheme="https://yoursite.com/tags/notes/"/>
    
      <category term="Machine Learning" scheme="https://yoursite.com/tags/Machine-Learning/"/>
    
      <category term="donkeycar" scheme="https://yoursite.com/tags/donkeycar/"/>
    
  </entry>
  
  <entry>
    <title>Conda常用命令</title>
    <link href="https://yoursite.com/2018/05/02/Conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://yoursite.com/2018/05/02/Conda常用命令/</id>
    <published>2018-05-02T06:38:20.000Z</published>
    <updated>2018-08-10T14:06:50.003Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong>使用Anaconda管理python各种python环境和库，可以极大提高在不同项目切换的效率。</p><p><img src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=694027017,1634354710&amp;fm=58&amp;bpow=944&amp;bpoh=794" alt="此处输入图片的描述"></p><a id="more"></a><h2 id="帮助与版本"><a href="#帮助与版本" class="headerlink" title="帮助与版本"></a>帮助与版本</h2><ul><li><p>查看当前conda版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda -V</span><br><span class="line">conda -version</span><br></pre></td></tr></table></figure></li><li><p>更新conda</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda update conda</span><br><span class="line">conda update anaconda #更新anaconda</span><br></pre></td></tr></table></figure></li><li><p>某个命令的帮助信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install --help</span><br></pre></td></tr></table></figure></li></ul><h2 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h2><ul><li><p>查看当前环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info -e</span><br></pre></td></tr></table></figure></li><li><p>查看所有环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda info --envs</span><br><span class="line">conda env list</span><br></pre></td></tr></table></figure></li><li><p>创建新的环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">conda create --name environment_name</span><br><span class="line">#创建不同python版本的环境</span><br><span class="line">conda create --name environment_name python=3.6</span><br><span class="line">conda create --name environment_name python=2.7</span><br><span class="line">#创建时添加库的环境</span><br><span class="line">conda create --name environment_name numpy scipy</span><br></pre></td></tr></table></figure></li><li><p>切换环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#切换到新环境</span><br><span class="line">activate environment_name</span><br><span class="line">#在linux于macos系统中，激活环境的命令为：</span><br><span class="line">source active environment_name</span><br><span class="line">#退出环境</span><br><span class="line">deactivate environment_name</span><br></pre></td></tr></table></figure></li><li><p>移除环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#conda remove --name environment_name --all</span><br><span class="line">conda remove -n py36 --all</span><br></pre></td></tr></table></figure></li><li><p>复制某个环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name new_name --clone old_name</span><br></pre></td></tr></table></figure></li><li><p>保存环境配置信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env export &gt; environment.yml</span><br></pre></td></tr></table></figure></li><li><p>读取环境配置信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env create -f environment.yml</span><br></pre></td></tr></table></figure></li></ul><p><strong>Note:</strong> 当遇到错误”SpecNotFound: Can’t process without a name”时，因为导入环境时目录有问题，所以需要检查.yml文件的path是否有误。</p><h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><ul><li><p>列举当前环境下所有包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure></li><li><p>列举某个环境下所有包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list -n environment_name</span><br></pre></td></tr></table></figure></li><li><p>查找某个包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda search package_name</span><br></pre></td></tr></table></figure></li><li><p>为指定环境安装某个包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -n environment_name package_name</span><br></pre></td></tr></table></figure></li><li><p>更新包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update package_name</span><br></pre></td></tr></table></figure></li><li><p>卸载包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove package_name</span><br></pre></td></tr></table></figure></li></ul><h2 id="设置镜像"><a href="#设置镜像" class="headerlink" title="设置镜像"></a>设置镜像</h2><p>访问国外资源网速较低时，可以考虑改变源，使用国内镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;使用Anaconda管理python各种python环境和库，可以极大提高在不同项目切换的效率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=694027017,1634354710&amp;amp;fm=58&amp;amp;bpow=944&amp;amp;bpoh=794&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://yoursite.com/categories/linux/"/>
    
    
      <category term="notes" scheme="https://yoursite.com/tags/notes/"/>
    
      <category term="python" scheme="https://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>对抗攻击防御策略一览</title>
    <link href="https://yoursite.com/2018/04/17/%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E9%98%B2%E5%BE%A1%E7%AD%96%E7%95%A5%E4%B8%80%E8%A7%88/"/>
    <id>https://yoursite.com/2018/04/17/对抗攻击防御策略一览/</id>
    <published>2018-04-17T07:46:27.000Z</published>
    <updated>2018-05-26T02:24:35.717Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要</strong>：根据最近的学习，按照自己的理解给不同对抗攻击的防御方法作简单总结。对抗防御从形式上看可以被分为三类：①对抗样本检测；②改变对抗样本；③增强模型。<br><a id="more"></a></p><hr><h2 id="①对抗样本检测："><a href="#①对抗样本检测：" class="headerlink" title="①对抗样本检测："></a>①对抗样本检测：</h2><p>指根据对抗样本与原始样本的分布差异，在模型Inference阶段将对抗样本区分出来。</p><p>检测对抗样本的方法有：</p><h3 id="1）-基于统计检验的检测（Sample-statistic）："><a href="#1）-基于统计检验的检测（Sample-statistic）：" class="headerlink" title="1）    基于统计检验的检测（Sample statistic）："></a>1）    基于统计检验的检测（Sample statistic）：</h3><p>这种方法比较直接，效果也比较差，并且因为是基于大量对抗样本的统计结论，因此需要大量对抗样本挖掘其统计规律，在检测的时候也不适于检测单个对抗样本。常见的统计检验方法如下：<br><strong>A．    Maximum mean discrepancy and energy distance.</strong><br>【Kathrin Grosse, Praveen Manoharan, Nicolas Papernot, Michael Backes, and Patrick McDaniel. On the (Statistical) Detection of Adversarial Examples. arXiv preprint arXiv:1702.06280, 2017.】<br>    但是这种方法不能对单个样本作出预测，只能揭示对抗样本与原始样本在平均偏差和距离的差异，不具有检测对抗样本的可行性。<br><strong>B．    Kernel density estimation</strong><br>【Reuben Feinman, Ryan R Curtin, Saurabh Shintre, and Andrew B Gardner. Detecting Adversarial Samples from Artifacts. arXiv preprint arXiv:1703.00410, 2017.】<br>这种方法即是在折叠的空间中计算一个测试样本和所有初始样本的距离，根据数据特征降维之后的差异区分对抗样本和真实样本。这种方法的缺陷是需要很大的计算资源，并且只能检测出对抗攻击时添加的对抗扰动比较大，让对抗样本和原始样本差异比较大的情况。<br><strong>C.    输入特征差异：</strong>包括JSMA攻击的论文中提到的，利用相邻像素间的平方差检测对抗样本。（这个方法前面的讨论中提到过，缺乏直观的合理性，所以也没什么价值）</p><h3 id="2）-训练检测器（Detector）："><a href="#2）-训练检测器（Detector）：" class="headerlink" title="2）    训练检测器（Detector）："></a>2）    训练检测器（Detector）：</h3><p>将对抗样本和原始样本作为训练集进行监督训练。<br>而检测器的训练包括两种：<br><strong>一种</strong>是直接将对抗样本和原始样本，打上label作为训练集训练一个分类器；<br><strong>另一种</strong>是将原始数据和对抗样本数据通过原始分类模型后，在输出层的值（或某一层神经网络层的输出值）打上label作为训练集训练一个分类器。</p><h3 id="3）-预测结果差异（Prediction-Inconsistency）"><a href="#3）-预测结果差异（Prediction-Inconsistency）" class="headerlink" title="3）    预测结果差异（Prediction Inconsistency）"></a>3）    预测结果差异（Prediction Inconsistency）</h3><p>根据预测结果差异来检测对抗样本主要有三种：<br><strong>(1)对抗样本和正常样本在原始模型的输出层差异。</strong><br>利用这种差异来检测对抗样本和原始样本，需要利用第2）点中构建一个检测器来实现；或者像我们前面的工作——根据模型输出层的统计差异来区分，但是这种方法不能对单个对抗样本做出判断。<br><strong>(2)对抗样本和原始样本经过特征处理之后，他们在输出层的变化不同。</strong><br>这种方法在前面的报告中提到了，这部分内容在后面的部分详细给出。<br><strong>(3)对抗样本在不同的模型下输出差异。</strong><br>这部分内容和前面和老师讨论的依据Byzantine Generals problem来设计系统相关联，让对抗样本经过多个分类模型，按照3t+1的原则，保证分类输出的正常。<br>其中，不同的模型获得方式有很多，一种是其他能应用于同一个任务的分类模型，比如在用VGG16分类时，用ResNet，WRN，DenseNet等同样能用作分类的网络模型作为参照，检测出对抗样本。另外一种就是基于原始模型的修改，包括结构的修改和训练过程的修改，不同的修改过程可以得到不同的子模型。比如在训练过程中，每次训练采用不同的dropout策略，可以得到几个类似功能的分类模型，只要测试样本在这几个分类模型上满足拜占庭问题的解，就可以判断为是原始样本。</p><hr><h2 id="②改变对抗样本："><a href="#②改变对抗样本：" class="headerlink" title="②改变对抗样本："></a>②改变对抗样本：</h2><p>1）用对抗攻击的方法处理对抗样本，让对抗样本重新被分类准确。<br>2）用特征处理的方法处理对抗样本，让对抗样本重新被分类准确。<br>3) Denoise the adversarial perturbation<br>4）添加去噪器，构建生成式模型，例如APE-GAN</p><hr><h2 id="③增强模型："><a href="#③增强模型：" class="headerlink" title="③增强模型："></a>③增强模型：</h2><p>1）    用更多数据训练，增强模型的泛化能力。包括对抗训练。<br>2）    修改模型的激活函数或者损失函数。<br>3）    使用network add-on，包括利用GAN，Defensive distillation。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;：根据最近的学习，按照自己的理解给不同对抗攻击的防御方法作简单总结。对抗防御从形式上看可以被分为三类：①对抗样本检测；②改变对抗样本；③增强模型。&lt;br&gt;
    
    </summary>
    
      <category term="paper" scheme="https://yoursite.com/categories/paper/"/>
    
    
      <category term="papernotes" scheme="https://yoursite.com/tags/papernotes/"/>
    
      <category term="secure" scheme="https://yoursite.com/tags/secure/"/>
    
  </entry>
  
  <entry>
    <title>Academic Writing Lessons</title>
    <link href="https://yoursite.com/2018/03/30/Academic%20Writing%20Lessons/"/>
    <id>https://yoursite.com/2018/03/30/Academic Writing Lessons/</id>
    <published>2018-03-30T15:48:00.000Z</published>
    <updated>2018-12-26T15:51:16.584Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Academic Writing Lessons</strong><br><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQZEUjfFCOgzo42UDMJb7Bkaaeir4-iYFO71yZOZDYurU3Q7Edg" alt="此处输入图片的描述"></p><a id="more"></a><hr><h2 id="Use-Better-alternative-words"><a href="#Use-Better-alternative-words" class="headerlink" title="Use Better alternative words"></a>Use Better alternative words</h2><table><thead><tr><th>Original</th><th style="text-align:center">Better alternative</th></tr></thead><tbody><tr><td>consider</td><td style="text-align:center">evaluate,assess</td></tr><tr><td>check</td><td style="text-align:center">verify,confirm</td></tr><tr><td>different</td><td style="text-align:center">distinct,diverse,various,varied</td></tr><tr><td>little/few</td><td style="text-align:center">seldom,slightly</td></tr><tr><td>problem</td><td style="text-align:center">limitaion,restriction,obstacle,hindrance</td></tr><tr><td>need</td><td style="text-align:center">require,stipulate</td></tr><tr><td>affect</td><td style="text-align:center">influence,shape</td></tr><tr><td>carry out</td><td style="text-align:center">implement,execute,primulgate,conduct</td></tr><tr><td>change</td><td style="text-align:center">modify,adjust,alter,vary</td></tr><tr><td>complicated</td><td style="text-align:center">complex,cumbersome,intricate</td></tr><tr><td>correct/incorrect</td><td style="text-align:center">precise/imprecise,accurate/inaccurate</td></tr><tr><td>find</td><td style="text-align:center">determine,derive,attain,locate,identify</td></tr><tr><td>help</td><td style="text-align:center">assist,facilitate,guide,direct</td></tr><tr><td>important</td><td style="text-align:center">critical,crucial,essential,pertinent,relevant,significant,vital</td></tr><tr><td>improve</td><td style="text-align:center">enhance,upgrade,elevate</td></tr><tr><td>is made of</td><td style="text-align:center">consists of,comprises,is composed of</td></tr><tr><td>make clear</td><td style="text-align:center">elucidate,clarify</td></tr><tr><td>makesure</td><td style="text-align:center">ensure,assure</td></tr><tr><td>meet</td><td style="text-align:center">satisfy,fulfill,adhere to</td></tr><tr><td>much/strongly</td><td style="text-align:center">markedly,considerably,substantially</td></tr><tr><td>realize</td><td style="text-align:center">comprehend,preceive,understand</td></tr><tr><td>solve</td><td style="text-align:center">alleviate,modify,resolve,eliminate,eradicate</td></tr><tr><td>suitable</td><td style="text-align:center">appropriate,adequate</td></tr><tr><td>tries</td><td style="text-align:center">attempts,aims,aspires</td></tr><tr><td>usually</td><td style="text-align:center">normally,typically,generally</td></tr><tr><td>very</td><td style="text-align:center">highly,rather,quite,extremely</td></tr><tr><td>way</td><td style="text-align:center">method,means,approach,strategy</td></tr><tr><td>whole</td><td style="text-align:center">complete,entire,comprehensive</td></tr><tr><td>is found to be</td><td style="text-align:center">is</td></tr><tr><td>is capable of</td><td style="text-align:center">can</td></tr><tr><td>is view of the fact that</td><td style="text-align:center">because</td></tr><tr><td>in this case</td><td style="text-align:center">here</td></tr><tr><td>in some cases</td><td style="text-align:center">occasionally</td></tr><tr><td>in no case</td><td style="text-align:center">never</td></tr><tr><td>the question as to</td><td style="text-align:center">whether</td></tr><tr><td>subsequent to</td><td style="text-align:center">after,following</td></tr><tr><td>serves the function of</td><td style="text-align:center">is</td></tr><tr><td>reach a conclusion</td><td style="text-align:center">is</td></tr><tr><td>put an end to</td><td style="text-align:center">end</td></tr><tr><td>provided that</td><td style="text-align:center">if</td></tr><tr><td>come to a conclusion</td><td style="text-align:center">conclude</td></tr><tr><td>by means of</td><td style="text-align:center">by</td></tr><tr><td>in a position to</td><td style="text-align:center">can</td></tr><tr><td>be deficient in</td><td style="text-align:center">lack</td></tr><tr><td>at this point in time</td><td style="text-align:center">now</td></tr><tr><td>at the present time</td><td style="text-align:center">now</td></tr><tr><td>notwithstanding the fact that</td><td style="text-align:center">although</td></tr><tr><td>manner in which</td><td style="text-align:center">how</td></tr><tr><td>make inquiry regrading</td><td style="text-align:center">ask about,inquire about</td></tr><tr><td>it is possible that</td><td style="text-align:center">may,might,could,can</td></tr><tr><td>in most cases</td><td style="text-align:center">uaually</td></tr><tr><td>in many cases</td><td style="text-align:center">often</td></tr><tr><td>in large measure</td><td style="text-align:center">largely</td></tr><tr><td>is in excess of</td><td style="text-align:center">exceeds,surpasses</td></tr><tr><td>in proximity to</td><td style="text-align:center">near</td></tr><tr><td>in case</td><td style="text-align:center">if</td></tr><tr><td>in all cases</td><td style="text-align:center">always</td></tr><tr><td>a number of</td><td style="text-align:center">several,many,numerous</td></tr><tr><td>if conditions are such that</td><td style="text-align:center">if</td></tr><tr><td>happens to be</td><td style="text-align:center">am,is,are</td></tr><tr><td>give indication of</td><td style="text-align:center">indicate,suggest</td></tr><tr><td>give consideration to</td><td style="text-align:center">consider</td></tr><tr><td>for this reason</td><td style="text-align:center">because</td></tr><tr><td>for the reason that</td><td style="text-align:center">so</td></tr><tr><td>for the purpose of</td><td style="text-align:center">for/to</td></tr><tr><td>during the time that</td><td style="text-align:center">while</td></tr><tr><td>due to the fact that</td><td style="text-align:center">because</td></tr><tr><td>despite the fact that</td><td style="text-align:center">althought</td></tr><tr><td>at such time as</td><td style="text-align:center">when</td></tr><tr><td>ascertain the location of</td><td style="text-align:center">find</td></tr><tr><td>along the lines of</td><td style="text-align:center">such as</td></tr><tr><td>a majority of</td><td style="text-align:center">most</td></tr></tbody></table><hr><h2 id="Formal-Grammer-and-Style"><a href="#Formal-Grammer-and-Style" class="headerlink" title="Formal Grammer and Style"></a>Formal Grammer and Style</h2><ol><li><p>Avoid contracion</p><pre><code>Export figures will not improve until the economy is stronger.Export figures won&apos;t improve until the economy is stronger.</code></pre></li><li><p>Use the more appropriate formal negative forms.</p><pre><code>not...much -&gt; littlenot...any -&gt; nonot...many -&gt; few</code></pre></li><li><p>Limit the use of “run on” expressions, such as “and so forth” and “etc.”</p><pre><code>These semiconductors can be used in robots, CD players, etc. —&gt;These semiconductors can be used in robots, CD players, and other electronic devices.</code></pre></li><li><p>Avoid addressing the reader as “you”</p><pre><code>You can see the results in Table 1.The results can be seen in Table 1.</code></pre></li><li><p>Limit the use of direct questions.</p><pre><code>Instead, use &quot;we now need to consider...&quot;</code></pre></li><li><p>Place adverbs within the verb.</p><pre><code>Then the solution can be discarded.The solution can then be discarded.The blood is withdraw slowly.The blood is slowly withdraw.</code></pre></li><li>Do not be wordy.</li></ol><p><strong>(To be continued…)</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Academic Writing Lessons&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQZEUjfFCOgzo42UDMJb7Bkaaeir4-iYFO71yZOZDYurU3Q7Edg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="English" scheme="https://yoursite.com/categories/English/"/>
    
    
      <category term="paper" scheme="https://yoursite.com/tags/paper/"/>
    
      <category term="notes" scheme="https://yoursite.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>python函数式编程</title>
    <link href="https://yoursite.com/2018/03/29/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://yoursite.com/2018/03/29/python函数式编程/</id>
    <published>2018-03-29T15:48:42.000Z</published>
    <updated>2018-07-15T08:05:55.226Z</updated>
    
    <content type="html"><![CDATA[<p><strong>python函数式编程</strong><br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1522348726856&amp;di=94ad6fe367916649eef70bb9303a9537&amp;imgtype=0&amp;src=http://file.digitaling.com/eImg/image/20140113/20140113145051_79090.jpg" alt="此处输入图片的描述"></p><a id="more"></a><hr><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a><font color="red">高阶函数</font></h2><h3 id="map-和reduce"><a href="#map-和reduce" class="headerlink" title="map()和reduce()"></a>map()和reduce()</h3><p>参考<a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf" target="_blank" rel="noopener">论文</a><br><strong>map():</strong> 这个函数接收两个参数，一个是<strong>函数</strong>，一个是<strong>Iterable</strong>（可迭代对象），map将传入的函数$f(x)$依次作用到序列的每个元素上，并把结果作为新的<strong>Iterator</strong>（迭代器）返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#实现将一个数字序列转化成字符序列</span><br><span class="line">list(map(str,[1,2,3,4,5]))</span><br></pre></td></tr></table></figure></p><p><strong>reduce()</strong>: 把一个函数作用在一个序列[x1, x2, x3, …]上，这个<strong>函数必须接收两个参数$f(x,y)$</strong>，reduce把结果继续和序列的下一个元素做累积计算。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#对一个序列求和</span><br><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line">&gt;&gt;&gt; def add(x, y):</span><br><span class="line">...     return x + y</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])</span><br><span class="line">25</span><br></pre></td></tr></table></figure></p><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>用于过滤序列，和map()类似，<strong>filter()</strong>也接收一个函数和一个序列。<br>和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是<strong>True还是False</strong>决定保留还是丢弃该元素。返回一个<strong>Iterator</strong>（这说明返回的依旧是一个惰性序列）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删掉一个序列中的空字符串</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">注意filter()给函数默认加bool()修正</span></span><br><span class="line"><span class="string">比如：</span></span><br><span class="line"><span class="string">bool(" a")=True</span></span><br><span class="line"><span class="string">bool("  ")=True</span></span><br><span class="line"><span class="string">bool("  ".Strip())=False</span></span><br><span class="line"><span class="string">bool(None)=False</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">not_empty</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> s <span class="keyword">and</span> s.strip()</span><br><span class="line">list(filter(not_empty, [<span class="string">'A'</span>, <span class="string">''</span>, <span class="string">'B'</span>, <span class="keyword">None</span>, <span class="string">'C'</span>, <span class="string">'  '</span>]))</span><br><span class="line"><span class="comment"># 结果: ['A', 'B', 'C']</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#用filter()求素数的方法——埃氏筛法</span><br><span class="line">#定义一个筛选函数</span><br><span class="line">def _not_divisible(n):</span><br><span class="line">    return lambda x: x % n &gt; 0</span><br><span class="line">#初始化自然数序列</span><br><span class="line">def _iter():</span><br><span class="line">    n = 1</span><br><span class="line">    while True:</span><br><span class="line">        n = n + 2</span><br><span class="line">        yield n</span><br><span class="line">def primes():</span><br><span class="line">    yield 2</span><br><span class="line">    it = _iter()</span><br><span class="line">    while True:</span><br><span class="line">        n = next(it)</span><br><span class="line">        yield n</span><br><span class="line">        it = filter(_not_divisible(n), it)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">def _iter():</span></span><br><span class="line"><span class="string">    n = 1</span></span><br><span class="line"><span class="string">    while True:</span></span><br><span class="line"><span class="string">        yield n</span></span><br><span class="line"><span class="string">        n = n + 1</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> str(n) == str(n)[::<span class="number">-1</span>]</span><br><span class="line">list(filter(is_palindrome),range(<span class="number">1000</span>))</span><br></pre></td></tr></table></figure><h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a>sorted()</h3><p>可以实现对list进行排序。<br>同时，可以接受一个key <strong>函数</strong>来实现自定义排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)</span><br><span class="line">[5, 9, -12, -21, 36]</span><br></pre></td></tr></table></figure></p><p>key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>])</span><br><span class="line">[<span class="string">'Credit'</span>, <span class="string">'Zoo'</span>, <span class="string">'about'</span>, <span class="string">'bob'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>], key=str.lower)</span><br><span class="line">[<span class="string">'about'</span>, <span class="string">'bob'</span>, <span class="string">'Credit'</span>, <span class="string">'Zoo'</span>]</span><br></pre></td></tr></table></figure></p><hr><h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a><font color="red">返回函数</font></h2><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazy_sum</span><span class="params">(*args)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">()</span>:</span></span><br><span class="line">        ax = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> args:</span><br><span class="line">            ax = ax + n</span><br><span class="line">        <span class="keyword">return</span> ax</span><br><span class="line">    <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure></p><p>&hearts;&hearts;&hearts;&hearts; <strong><font color="red">闭包</font></strong>&hearts;&hearts;&hearts;&hearts;<br>建议参考教程——<a href="https://zhuanlan.zhihu.com/p/22229197" target="_blank" rel="noopener">知乎专栏</a><br><strong>闭包概念</strong>：在一个内部函数中，对外部作用域的变量进行引用，(并且一般外部函数的返回值为内部函数)，那么内部函数就被认为是闭包。<br>&emsp;在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这称为“闭包（Closure）”的程序结构。<br>&emsp;需要<strong>注意的问题</strong>是，循环在python中没有域的概念，向列表中添加函数的时候并不会保存循环中变量的值。<font color="blue"><strong>返回的函数并没有立刻执行，而是直到调用了f()才执行。</strong></font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def count():</span><br><span class="line">    fs = []</span><br><span class="line">    for i in range(1, 4):</span><br><span class="line">        def f():</span><br><span class="line">             return i*i</span><br><span class="line">        fs.append(f)</span><br><span class="line">    return fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = count()</span><br></pre></td></tr></table></figure></p><p>你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1()</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2()</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f3()</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure></p><p><font color="red">返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</font><br><strong>原因</strong>：闭包函数调用外部循环变量时，并没有保存这个值，只保存了变量的地址，要等到调用闭包函数时才会取具体的值，然而此时函数值可能已经发生了变化。<br><strong>解决办法</strong>：再定义一个函数，将g()形成闭包。主要是要在函数内部，把可变的循环值i作为函数参数调用。简单来说，一定要有f(i),在调用过程中，i就会被传入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def count():</span><br><span class="line">    def f(j):</span><br><span class="line">        def g():</span><br><span class="line">            return j*j</span><br><span class="line">        return g</span><br><span class="line">    fs = []</span><br><span class="line">    for i in range(1, 4):</span><br><span class="line">        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()</span><br><span class="line">    return fs</span><br></pre></td></tr></table></figure></p><p>利用闭包返回一个计数器函数，每次调用它返回递增整数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def createCounter()</span><br><span class="line">    s=[0]</span><br><span class="line">    def conter():</span><br><span class="line">        s[0] += 1</span><br><span class="line">        return s[0]</span><br><span class="line"></span><br><span class="line">    return counter</span><br></pre></td></tr></table></figure></p><p><strong><a href="https://www.cnblogs.com/Lin-Yi/p/7305364.html" target="_blank" rel="noopener">外函数返回了内函数的引用</a>：</strong>当我们在python中定义一个函数def demo():  的时候，内存当中会开辟一些空间，存下这个函数的代码、内部的局部变量等等。这个demo只不过是一个变量名字，它里面存了这个函数所在位置的引用而已。我们还可以进行x = demo， y = demo， 这样的操作就相当于，把demo里存的东西赋值给x和y，这样x 和y 都指向了demo函数所在的引用，在这之后我们可以用x() 或者 y() 来调用我们自己创建的demo() ，调用的实际上根本就是一个函数，x、y和demo三个变量名存了同一个函数的引用。</p><p><strong>闭包中内函数修改外函数局部变量：</strong></p><p>  在闭包内函数中，我们可以随意使用外函数绑定来的临时变量，但是如果我们想修改外函数临时变量数值的时候发现出问题了！<br>  在基本的python语法当中，一个函数可以随意读取全局数据，但是要修改全局数据的时候有两种方法:1 global 声明全局变量 2 全局变量是可变类型数据的时候可以修改<br>  在闭包内函数也是类似的情况。在内函数中想修改闭包变量（外函数绑定给内函数的局部变量）的时候：</p><ol><li>在python3中，可以用nonlocal 关键字声明 一个变量， 表示这个变量不是局部变量空间的变量，需要向上一层变量空间找这个变量。</li><li>在python2中，没有nonlocal这个关键字，我们可以把闭包变量改成可变类型数据进行修改，比如列表。</li></ol><p><strong>闭包的作用：</strong></p><ol><li>装饰器！！！装饰器是做什么的？？其中一个应用就是，我们工作中写了一个登录功能，我们想统计这个功能执行花了多长时间，我们可以用装饰器装饰这个登录模块，装饰器帮我们完成登录函数执行之前和之后取时间。</li><li>面向对象！！！经历了上面的分析，我们发现外函数的临时变量送给了内函数。大家回想一下类对象的情况，对象有好多类似的属性和方法，所以我们创建类，用类创建出来的对象都具有相同的属性方法。闭包也是实现面向对象的方法之一。在python当中虽然我们不这样用，在其他编程语言入比如avaScript中，经常用闭包来实现面向对象编程</li><li>实现单利模式！！</li><li>闭包可以保存当前的运行环境，以一个类似棋盘游戏的例子来说明。假设棋盘大小为50*50，左上角为坐标系原点(0,0)，我需要一个函数，接收2个参数，分别为方向(direction)，步长(step)，该函数控制棋子的运动。 这里需要说明的是，每次运动的起点都是上次运动结束的终点。</li></ol><hr><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a><font color="red">匿名函数</font></h2><p>在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(<span class="keyword">lambda</span> x: x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]))</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">其中，lambda x: x * x相当于：</span></span><br><span class="line"><span class="string">def f(x):</span></span><br><span class="line"><span class="string">    return x * x</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>同时，匿名函数可以作为返回函数。</p><hr><h2 id="装饰器（decorator）"><a href="#装饰器（decorator）" class="headerlink" title="装饰器（decorator）"></a><font color="red">装饰器（decorator）</font></h2><p><strong>装饰器就是一个返回函数的高阶函数，基于闭包原理。</strong><br>定义一个打印日志的decorator:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        print(<span class="string">'call %s():'</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure></p><p>定义一个带参数的decorator:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">            print(<span class="string">'%s %s():'</span> % (text, func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure></p><p>函数也是对象，它有<strong>name</strong>等属性，但你去看经过decorator装饰之后的函数，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'2015-3-25'</span>)</span><br></pre></td></tr></table></figure></p><p>它们的<strong>name</strong>已经从原来的’now’变成了’wrapper’：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>now.__name__</span><br><span class="line"><span class="string">'wrapper'</span></span><br></pre></td></tr></table></figure></p><p>因为返回的那个wrapper()函数名字就是’wrapper’，所以，需要把原始函数的__name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。</p><p>不需要编写wrapper.__name__ = func.__name__这样的代码，Python内置的<font color="red"><strong>functools.wraps</strong></font>就是干这个事的，所以，一个完整的decorator的写法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def log(func):</span><br><span class="line">    @functools.wraps(func)#复制依赖函数</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        print(&apos;call %s():&apos; % func.__name__)</span><br><span class="line">        return func(*args, **kw)</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure></p><hr><h2 id="偏函数（Partial-function）"><a href="#偏函数（Partial-function）" class="headerlink" title="偏函数（Partial function）"></a><font color="red">偏函数（Partial function）</font></h2><p><strong>偏函数可以通过设定参数的默认值，降低函数调用的难度。由Python的functools模块提供。</strong><br>举例说明：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2 = functools.partial(int, base=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'1000000'</span>)</span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'1010101'</span>)</span><br><span class="line"><span class="number">85</span></span><br></pre></td></tr></table></figure></p><p>上面的新的int2函数，仅仅是把base参数重新设定默认值为2，但也可以在函数调用时传入其他值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; int2(&apos;1000000&apos;, base=10)</span><br><span class="line">1000000</span><br></pre></td></tr></table></figure></p><p>创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数，当传入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int2 = functools.partial(int, base=2)</span><br><span class="line">#相当于</span><br><span class="line">kw = &#123; &apos;base&apos;: 2 &#125;</span><br><span class="line">int(&apos;10010&apos;, **kw)</span><br></pre></td></tr></table></figure></p><hr><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a><font color="red">Reference</font></h2><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431843456408652233b88b424613aa8ec2fe032fd85a000" target="_blank" rel="noopener">教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;python函数式编程&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1522348726856&amp;amp;di=94ad6fe367916649eef70bb9303a9537&amp;amp;imgtype=0&amp;amp;src=http://file.digitaling.com/eImg/image/20140113/20140113145051_79090.jpg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="coding" scheme="https://yoursite.com/categories/coding/"/>
    
    
      <category term="notes" scheme="https://yoursite.com/tags/notes/"/>
    
      <category term="python" scheme="https://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python可变与不可变对象</title>
    <link href="https://yoursite.com/2018/03/19/python%E5%8F%AF%E5%8F%98%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1/"/>
    <id>https://yoursite.com/2018/03/19/python可变与不可变对象/</id>
    <published>2018-03-19T15:17:20.000Z</published>
    <updated>2018-04-12T11:39:07.408Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Abstract</strong>：介绍python中的可变对象与不可变对象的概念。<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1522348726856&amp;di=94ad6fe367916649eef70bb9303a9537&amp;imgtype=0&amp;src=http://file.digitaling.com/eImg/image/20140113/20140113145051_79090.jpg" alt="此处输入图片的描述"><br><a id="more"></a></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li><strong>不可变对象</strong>，该对象所指向的内存中的值不能被改变。当改变某个变量时候，由于其所指的值不能被改变，相当于把原来的值复制一份后再改变，这会开辟一个新的地址，变量再指向这个新的地址。</li><li><strong>可变对象</strong>，该对象所指向的内存中的值可以被改变。变量（准确的说是引用）改变后，实际上是其所指的值直接发生改变，并没有发生复制行为，也没有开辟新的出地址，通俗点说就是原地改变。</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ul><li><p>不可变（immutable）：int、字符串(string)、float、（数值型number）、<strong>元组（tuple)</strong></p></li><li><p>可变（mutable）：字典型(dictionary)、列表型(list)、集合（set）</p></li></ul><h2 id="定义默认参数要牢记"><a href="#定义默认参数要牢记" class="headerlink" title="定义默认参数要牢记"></a><font color="red">定义默认参数要牢记</font></h2><p>默认参数必须指向<strong>不变对象</strong>！<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=[])</span>:</span></span><br><span class="line">    L.append(<span class="string">'END'</span>)</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</span><br><span class="line">[<span class="string">'END'</span>, <span class="string">'END'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</span><br><span class="line">[<span class="string">'END'</span>, <span class="string">'END'</span>, <span class="string">'END'</span>]</span><br></pre></td></tr></table></figure></p><p>Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L<strong>也是一个变量</strong>，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        L = []</span><br><span class="line">    L.append(<span class="string">'END'</span>)</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</span><br><span class="line">[<span class="string">'END'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</span><br><span class="line">[<span class="string">'END'</span>]</span><br></pre></td></tr></table></figure></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">2278158310408</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a += [<span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">2278158310408</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">4</span> <span class="comment">#不可变</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">1944540032</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a += <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">1944540128</span></span><br></pre></td></tr></table></figure><p>但是当不可变对象比较大时，这个规律不符合，并不会创建新的对象。<strong>常量池</strong></p><h2 id="python中的复制，浅拷贝和深拷贝"><a href="#python中的复制，浅拷贝和深拷贝" class="headerlink" title="python中的复制，浅拷贝和深拷贝"></a>python中的复制，浅拷贝和深拷贝</h2><p><strong>复制</strong>只传递对象的引用，也就是对象的地址<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">1264995283336</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">1264995283336</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure></p><p><strong>浅拷贝</strong>指把存放变量的地址值传给被赋值，最后两个变量引用了同一份地址。copy会根据数据类型为可变还是不可变进行判断：如果是不可变类型，和复制相同；如果是可变类型，只是<strong>拷贝第一层</strong>（也就是对于list类型中，其中的元素中指向的其他地址不变化）。<br>用到的方法是 copy.copy()<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c=copy.copy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(c)</span><br><span class="line"><span class="number">1264997856200</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">1264995283336</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c=copy.copy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">1264995283336</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(c)</span><br><span class="line"><span class="number">1264997856264</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d=copy.copy(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">1354853888</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(d)</span><br><span class="line"><span class="number">1354853888</span></span><br></pre></td></tr></table></figure></p><p>发现，同样是浅拷贝，拷贝后的a和b却给了不同的处理。因为a是list，是<strong>可变对象</strong>，而b是int数据类型，属于<strong>不可变对象</strong>。<br>换言之，对于可变对象，浅拷贝与复制不同，拷贝的结果存放在一个新的空间。而对于不可变对象，拷贝和复制的意义相同，都指向同一个地址空间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; id(c)</span><br><span class="line">1264997856200</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">1264995283336</span><br><span class="line">&gt;&gt;&gt; id(b)</span><br><span class="line">1354853888</span><br><span class="line">&gt;&gt;&gt; id(d)</span><br><span class="line">1354853888</span><br></pre></td></tr></table></figure></p><p>但是，对于不可变对象，当改变某个变量时候，由于其所指的值不能被改变，相当于把原来的值复制一份后再改变，这会开辟一个新的地址，变量再指向这个新的地址。因此，改变一个变量，其地址会发生改变，而原来复制出的变量则指向原来的值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = copy.copy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = copy.deepcopy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">1354853888</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">1354853888</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(c)</span><br><span class="line"><span class="number">1354853888</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(d)</span><br><span class="line"><span class="number">1354853888</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = a + <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">1354853984</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">1354853888</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(c)</span><br><span class="line"><span class="number">1354853888</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(d)</span><br><span class="line"><span class="number">1354853888</span></span><br></pre></td></tr></table></figure></p><p>可见，<strong>对于不可变对象，深拷贝，浅拷贝，复制 效果一样</strong>。</p><p><strong>深拷贝</strong>包含对象里面的内容的拷贝，重新开辟一个新的空间，所以原始对象的改变不会造成深拷贝里任何子元素的改变。<br>（<em>实际上，一般所谓的拷贝操作，都是在list上进行的，所以只需要知道在lists上着三种拷贝操作的意义和结论即可</em>）<br>深拷贝和浅拷贝的区别直接看代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = copy.copy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = copy.deepcopy(a)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">1264997889288</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">1264997862472</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(c)</span><br><span class="line"><span class="number">1264997889736</span></span><br><span class="line"><span class="comment">#深拷贝和浅拷贝的区别在，深拷贝复制了整个对象，而浅拷贝只是复制了第一层的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a[<span class="number">0</span>])</span><br><span class="line"><span class="number">1264997875208</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b[<span class="number">0</span>])</span><br><span class="line"><span class="number">1264997875208</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(c[<span class="number">0</span>])</span><br><span class="line"><span class="number">1264997861640</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">[[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>], <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>].append(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>], <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">[[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Abstract&lt;/strong&gt;：介绍python中的可变对象与不可变对象的概念。&lt;br&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1522348726856&amp;amp;di=94ad6fe367916649eef70bb9303a9537&amp;amp;imgtype=0&amp;amp;src=http://file.digitaling.com/eImg/image/20140113/20140113145051_79090.jpg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="coding" scheme="https://yoursite.com/categories/coding/"/>
    
    
      <category term="notes" scheme="https://yoursite.com/tags/notes/"/>
    
      <category term="python" scheme="https://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python惰性序列</title>
    <link href="https://yoursite.com/2018/03/17/python%E6%83%B0%E6%80%A7%E5%BA%8F%E5%88%97/"/>
    <id>https://yoursite.com/2018/03/17/python惰性序列/</id>
    <published>2018-03-17T02:48:20.000Z</published>
    <updated>2018-12-26T15:38:51.919Z</updated>
    
    <content type="html"><![CDATA[<p>python中的高级特性——惰性序列<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1522348726856&amp;di=94ad6fe367916649eef70bb9303a9537&amp;imgtype=0&amp;src=http://file.digitaling.com/eImg/image/20140113/20140113145051_79090.jpg" alt="此处输入图片的描述"></p><a id="more"></a><h2 id="生成器generator"><a href="#生成器generator" class="headerlink" title="生成器generator"></a><font color="red">生成器generator</font></h2><p>一边计算一边循环的机制，称为<strong>生成器</strong>。<br>generator非常强大。相比于传统的for循环直接生成一个list，generator可以<strong>节省大量的空间</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g = (x * x for x in range(10))</span><br><span class="line">&gt;&gt;&gt; for n in g:</span><br><span class="line">...     print(n)</span><br><span class="line">...</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">9</span><br><span class="line">16</span><br><span class="line">25</span><br><span class="line">36</span><br><span class="line">49</span><br><span class="line">64</span><br><span class="line">81</span><br></pre></td></tr></table></figure></p><p>如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。<br>著名的<strong>斐波拉契数列</strong>（Fibonacci）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def fib(max):</span><br><span class="line">    n, a, b = 0, 0, 1</span><br><span class="line">    while n &lt; max:</span><br><span class="line">        yield b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + 1</span><br><span class="line">    return &apos;done&apos;</span><br></pre></td></tr></table></figure></p><p><strong>杨辉三角</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def yanghui(max):</span><br><span class="line">    line=[1]</span><br><span class="line">    while True:</span><br><span class="line">        yield line</span><br><span class="line">        nextline = line+[1]#注意这个表达</span><br><span class="line">        for i in range(len(line)):</span><br><span class="line">             if i != 0:</span><br><span class="line">                 nextline[i] = line[i-1] + line[i]</span><br><span class="line">        line = nextline</span><br><span class="line">    return &quot;done&quot;</span><br></pre></td></tr></table></figure></p><h2 id="Iterable与Iterator，iter"><a href="#Iterable与Iterator，iter" class="headerlink" title="Iterable与Iterator，iter()"></a><font color="red">Iterable与Iterator，iter()</font></h2><h3 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a>Iterable</h3><p>python中直接作用于<font color="blue">for循环</font>的对象统称为可迭代对象：<strong>Iterabale</strong>.<br>一类是<strong>集合数据类型</strong>，如list、tuple、dict、set、str等；<br>一类是<strong>generator</strong>，包括生成器和带yield的generator function。<br>判断一个对象是否是可迭代对象,可以使用collections模块的<strong>Iterable</strong>类型判断。</p><h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><p>能够被<font color="blue">next()</font>函数调用并不断返回下一个值的对象称为迭代器：<strong>Iterator</strong>。</p><h3 id="iter"><a href="#iter" class="headerlink" title="iter()"></a>iter()</h3><p>可以使用isinstance()判断一个对象是否是Iterator对象。<br>可以使用iter()函数把list，dict，str获得一个Iterator对象，用next()计算。</p><h3 id="code-examples"><a href="#code-examples" class="headerlink" title="code examples"></a>code examples</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;from collections import Iterable</span><br><span class="line">&gt;&gt;&gt;isinstance(&quot;abc&quot;,Iterable)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;from collections import Iterator</span><br><span class="line">&gt;&gt;&gt;isinstance([],Iterator)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt;isinstance(iter([]),Iterator)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#注意下面的区别</span><br><span class="line">&gt;&gt;&gt;isinstance((x for x in range(10)),Iterator)</span><br><span class="line">#返回的是一个生成器对象，不是tuple</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt;isinstance((),Iterator)</span><br><span class="line">#tuple不是迭代器</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt;isinstance([x for x in range(10)],Iterator)</span><br><span class="line">#返回一个list</span><br><span class="line">False</span><br></pre></td></tr></table></figure><pre><code>为什么list、dict、str等数据类型不是Iterator？这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</code></pre><h2 id="惰性序列"><a href="#惰性序列" class="headerlink" title="惰性序列"></a><font color="red">惰性序列</font></h2><h3 id="惰性计算"><a href="#惰性计算" class="headerlink" title="惰性计算"></a><a href="https://zh.wikipedia.org/wiki/%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC" target="_blank" rel="noopener">惰性计算</a></h3><h3 id="惰性序列-1"><a href="#惰性序列-1" class="headerlink" title="惰性序列"></a>惰性序列</h3><p>python中的惰性序列多数指Iterator。对于存在巨大甚至无限多的元素的序列，迭代器仅仅在迭代至某个元素时才计算该元素，在此之前或者之后，元素可以不存在或者被销毁。</p><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>一是这样我们就可以实现的无限序列的表示，比如全部的自然数(无穷尽)，而不需要真的在内存中计算出所有的自然数(那根本不可能，因为内存也不是无限的)，而是需要哪个数，计算到哪个数，或者需要哪些数，计算到那些数(比如前1000个)。<br>二是在大规模数据处理中起到延迟计算的作用。当你处理大规模数据时，一次性进行处理往往是不方便的。而惰性序列就可以解决这个问题，它把计算的步骤延迟到了要实际使用该数据的时候。<br>惰性序列可以看作是一个”流”，需要的时候从其中取一滴水。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a><font color="red">reference</font></h2><p><a href="https://blog.csdn.net/solo95/article/details/78834041" target="_blank" rel="noopener">博客</a><br><a href="https://blog.csdn.net/it_dream_er/article/details/50890201" target="_blank" rel="noopener">博客2</a><br><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317852443934a86aa5bb5ea47fbbd5f35282b331335000" target="_blank" rel="noopener">教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python中的高级特性——惰性序列&lt;br&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1522348726856&amp;amp;di=94ad6fe367916649eef70bb9303a9537&amp;amp;imgtype=0&amp;amp;src=http://file.digitaling.com/eImg/image/20140113/20140113145051_79090.jpg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="coding" scheme="https://yoursite.com/categories/coding/"/>
    
    
      <category term="notes" scheme="https://yoursite.com/tags/notes/"/>
    
      <category term="python" scheme="https://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>“Google机器学习速成课程”概念浏览</title>
    <link href="https://yoursite.com/2018/03/13/%E2%80%9CGoogle%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%80%9F%E6%88%90%E8%AF%BE%E7%A8%8B%E2%80%9D%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/"/>
    <id>https://yoursite.com/2018/03/13/“Google机器学习速成课程”概念总结/</id>
    <published>2018-03-13T03:37:30.000Z</published>
    <updated>2018-03-13T03:29:51.437Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要</strong> ：简单总结几个最近发布的“机器学习速成课程”中的概念<br><a id="more"></a></p><p><strong>正文:</strong></p><p><strong>随机梯度下降法（SGD）</strong>：在梯度下降法中，批量指的是用于在单次迭代中计算梯度的样本总数。到目前为止，我们一直假定批量是指整个数据集。就 Google 的规模而言，数据集通常包含数十亿甚至数千亿个样本。此外，Google 数据集通常包含海量特征。因此，一个批量可能相当巨大。如果是超大批量，则单次迭代就可能要花费很长时间进行计算。</p><p>包含随机抽样样本的大型数据集可能包含冗余数据。实际上，批量大小越大，出现冗余的可能性就越高。一些冗余可能有助于消除杂乱的梯度，但超大批量所具备的预测价值往往并不比大型批量高。</p><p>如果我们可以通过更少的计算量得出正确的平均梯度，会怎么样？通过从我们的数据集中随机选择样本，我们可以通过小得多的数据集估算（尽管过程非常杂乱）出较大的平均值。 随机梯度下降法 (SGD) 将这种想法运用到极致，它每次迭代只使用一个样本（批量大小为 1）。如果进行足够的迭代，SGD 也可以发挥作用，但过程会非常杂乱。“随机”这一术语表示构成各个批量的一个样本都是随机选择的。</p><p>小批量随机梯度下降法（小批量 SGD）是介于全批量迭代与 SGD 之间的折衷方案。小批量通常包含 10-1000 个随机选择的样本。小批量 SGD 可以减少 SGD 中的杂乱样本数量，但仍然比全批量更高效。</p><p><strong>特征工程</strong>：从原始数据创建特征的过程。会花费实际工作中百分之70的时间。<br>良好特征具有下列特点：1.避免很少使用的离散特征值2.最好具有清晰明确的定义3.异常的数值不要和实际数据混为一谈4.考虑随着时间的不稳定性</p><p><strong>数据清洗</strong>：1.缩放特征值2.处理极端离群值3.分箱4.清查（遗漏值，重复样本，不良标签，不良特征值）5.了解数据</p><p><strong>特征组合</strong>:是指通过将两个或多个输入特征相乘来对特征空间中的非线性规律进行编码的合成特征。</p><ul><li>[A X B]：将两个特征的值相乘形成的特征组合。</li><li>[A x B x C x D x E]：将五个特征的值相乘形成的特征组合。</li><li>[A x A]：对单个特征的值求平方形成的特征组合。</li></ul><p><strong>机器学习训练过程问题</strong>：<br><em>梯度消失</em><br>较低层（更接近输入）的梯度可能会变得非常小。在深度网络中，计算这些梯度时，可能涉及许多小项的乘积。当较低层的梯度逐渐消失到 0时，这些层的训练速度会非常缓慢，甚至不再训练。<br>ReLU 激活函数有助于防止梯度消失。</p><p><em>梯度爆炸</em><br>如果网络中的权重过大，则较低层的梯度会涉及许多大项的乘积。在这种情况下，梯度就会爆炸：梯度过大导致难以收敛。<br>批标准化可以降低学习速率，因而有助于防止梯度爆炸。</p><p><em>ReLU 单元消失</em><br>一旦 ReLU 单元的加权和低于 0，ReLU 单元就可能会停滞。它会输出对网络输出没有任何贡献的 0 激活，而梯度在反向传播算法期间将无法再从中流过。由于梯度的来源被切断，ReLU 的输入可能无法作出足够的改变来使加权和恢复到 0 以上。<br>降低学习速率有助于防止 ReLU 单元消失。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt; ：简单总结几个最近发布的“机器学习速成课程”中的概念&lt;br&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="https://yoursite.com/categories/Machine-Learning/"/>
    
    
      <category term="notes" scheme="https://yoursite.com/tags/notes/"/>
    
      <category term="Machine Learning" scheme="https://yoursite.com/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>leetcode15-3sum解题报告</title>
    <link href="https://yoursite.com/2018/02/21/leetcode15%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <id>https://yoursite.com/2018/02/21/leetcode15解题报告/</id>
    <published>2018-02-21T08:31:08.000Z</published>
    <updated>2018-03-17T02:01:06.093Z</updated>
    
    <content type="html"><![CDATA[<p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.<br><a id="more"></a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>Note:</strong><br>Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)<br>The solution set must not contain duplicate triplets.<br>    For example, given array S = {-1 0 1 2 -1 -4},<br>    A solution set is:<br>    (-1, 0, 1)<br>    (-1, -1, 2)</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>先把无序数组排序</li><li>固定一个数，找出其余两个数让它们的和为固定数的相反数（相加为0）</li></ol><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;  </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;List&lt;Integer&gt;&gt;();  </span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] num) &#123;  </span><br><span class="line">        if (num == null || num.length &lt; 3) return ret;  </span><br><span class="line"></span><br><span class="line">        Arrays.sort(num);  </span><br><span class="line"></span><br><span class="line">        int len = num.length;  </span><br><span class="line">        for (int i = 0; i &lt; len-2; i++) &#123;  </span><br><span class="line">            if (i &gt; 0 &amp;&amp; num[i] == num[i-1]) continue;  </span><br><span class="line">            find(num, i+1, len-1, num[i]); //寻找两个数与num[i]的和为0  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        return ret;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    public void find(int[] num, int begin, int end, int target) &#123;  </span><br><span class="line">        int l = begin, r = end;  </span><br><span class="line">        while (l &lt; r) &#123;  </span><br><span class="line">            if (num[l] + num[r] + target == 0) &#123;  </span><br><span class="line">                List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();  </span><br><span class="line">                ans.add(target);  </span><br><span class="line">                ans.add(num[l]);  </span><br><span class="line">                ans.add(num[r]);  </span><br><span class="line">                ret.add(ans); //放入结果集中  </span><br><span class="line">                while (l &lt; r &amp;&amp; num[l] == num[l+1]) l++;  </span><br><span class="line">                while (l &lt; r &amp;&amp; num[r] == num[r-1]) r--;  </span><br><span class="line">                l++;  </span><br><span class="line">                r--;  </span><br><span class="line">            &#125; else if (num[l] + num[r] + target &lt; 0) &#123;  </span><br><span class="line">                l++;  </span><br><span class="line">            &#125; else &#123;  </span><br><span class="line">                r--;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><p>这个题目要注意得出的结论可能出现重复的可能，另外要考虑的所有特殊情况如下：</p><ol><li>结果重复</li><li>输入数组长度不够</li><li>输入数组为空<br>另外，在搜寻三个数使得其和为0的思路上，不能采取用三个循环的思想，这样会导致时间复杂度很高。可以固定其中的一个数，设置两个指针，让这两个指针移动计算,降低时间复杂度。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.&lt;br&gt;
    
    </summary>
    
      <category term="coding" scheme="https://yoursite.com/categories/coding/"/>
    
    
      <category term="algorithms" scheme="https://yoursite.com/tags/algorithms/"/>
    
      <category term="leetcode" scheme="https://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu16.04安装OpenCV3.3教程</title>
    <link href="https://yoursite.com/2017/12/22/Ubuntu16.04%E5%AE%89%E8%A3%85OpenCV3.3/"/>
    <id>https://yoursite.com/2017/12/22/Ubuntu16.04安装OpenCV3.3/</id>
    <published>2017-12-22T06:38:20.000Z</published>
    <updated>2018-12-26T13:12:13.076Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong>搭建OpenCV3.3的过程<br><a id="more"></a></p><h2 id="安装依赖环境"><a href="#安装依赖环境" class="headerlink" title="安装依赖环境"></a>安装依赖环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install build-essential libopencv-dev</span><br><span class="line">$ sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev</span><br><span class="line">$ sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev # 处理图像所需的包</span><br><span class="line">$ sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev liblapacke-dev</span><br><span class="line">$ sudo apt-get install libxvidcore-dev libx264-dev # 处理视频所需的包</span><br><span class="line">$ sudo apt-get install libatlas-base-dev gfortran # 优化opencv功能</span><br><span class="line">$ sudo apt-get install ffmpeg</span><br></pre></td></tr></table></figure><h2 id="获取源代码"><a href="#获取源代码" class="headerlink" title="获取源代码"></a>获取源代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/opencv/opencv.git</span><br></pre></td></tr></table></figure><h2 id="编译源代码"><a href="#编译源代码" class="headerlink" title="编译源代码"></a>编译源代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cd opencv</span><br><span class="line"></span><br><span class="line">$ mkdir build</span><br><span class="line"></span><br><span class="line">$ cd build</span><br><span class="line"></span><br><span class="line">$ cmake ..</span><br><span class="line"></span><br><span class="line">$ make -j 10</span><br></pre></td></tr></table></figure><h2 id="替换旧版本"><a href="#替换旧版本" class="headerlink" title="替换旧版本"></a>替换旧版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure><h2 id="编译出错的处理"><a href="#编译出错的处理" class="headerlink" title="编译出错的处理"></a>编译出错的处理</h2><p>执行cmake的时候，可能会出现下面的错误信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CMake Error at CMakeLists.txt:11 (message):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  FATAL: In-source builds are not allowed.</span><br><span class="line"></span><br><span class="line">         You should create separate directory for build files.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- Configuring incomplete, errors occurred!</span><br></pre></td></tr></table></figure></p><p>则是在代码根目录下直接执行过 cmake，导致根目录下生成了 CMakeCache.txt，需要删除 CMakeCache.txt再次执行编译即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;搭建OpenCV3.3的过程&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="https://yoursite.com/categories/linux/"/>
    
    
      <category term="notes" scheme="https://yoursite.com/tags/notes/"/>
    
      <category term="Machine Learning" scheme="https://yoursite.com/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>python字符串切片操作</title>
    <link href="https://yoursite.com/2017/11/26/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E5%8F%96%E6%93%8D%E4%BD%9C/"/>
    <id>https://yoursite.com/2017/11/26/python字符串切取操作/</id>
    <published>2017-11-26T09:04:31.000Z</published>
    <updated>2018-03-30T04:29:06.469Z</updated>
    
    <content type="html"><![CDATA[<p>详述在python中如何切片？<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1522348726856&amp;di=94ad6fe367916649eef70bb9303a9537&amp;imgtype=0&amp;src=http://file.digitaling.com/eImg/image/20140113/20140113145051_79090.jpg" alt="此处输入图片的描述"></p><a id="more"></a><h2 id="字符index"><a href="#字符index" class="headerlink" title="字符index"></a>字符index</h2><p>首先需要明白字符的index是什么？<br>对于一个字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;str = &quot;abcdefg&quot;</span><br></pre></td></tr></table></figure></p><p>其各个字符的index分别为 0 1 2 3 4 5 6<br>如果用负数表示，就是 -7 -6 -5 -4 -3 -2 -1</p><h2 id="取字符串中第几个字符"><a href="#取字符串中第几个字符" class="headerlink" title="取字符串中第几个字符"></a>取字符串中第几个字符</h2><p>根据index获取即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;str[2]</span><br><span class="line">a</span><br></pre></td></tr></table></figure></p><h2 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h2><p>表达式 str[a:b]，表示从字符串index为a的字符，截取到index为b-1的字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;str[1:2]</span><br><span class="line">b</span><br></pre></td></tr></table></figure></p><h2 id="步长截取"><a href="#步长截取" class="headerlink" title="步长截取"></a>步长截取</h2><p>str[a:b:c]:表示从第a个字符串开始，截取到第b个字符的前一个为止。<br>不过这里要&lt;\font color = ‘red’&gt;注意&lt;\font&gt;:<br>当c小于0时，字符串的index是反向数的，也就是从index为b的到index为a+1的字符，每隔-c个字符取一个字符。<br>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;str[3:1:-1]</span><br><span class="line">dc</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;详述在python中如何切片？&lt;br&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1522348726856&amp;amp;di=94ad6fe367916649eef70bb9303a9537&amp;amp;imgtype=0&amp;amp;src=http://file.digitaling.com/eImg/image/20140113/20140113145051_79090.jpg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="coding" scheme="https://yoursite.com/categories/coding/"/>
    
    
      <category term="notes" scheme="https://yoursite.com/tags/notes/"/>
    
      <category term="python" scheme="https://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>《Can you fool AI with adversarial examples on a visual Turing test?》论文笔记</title>
    <link href="https://yoursite.com/2017/11/21/%E3%80%8ACan-you-fool-AI-with-adversarial-examples-on-a-visual-Turing-test-%E3%80%8B%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <id>https://yoursite.com/2017/11/21/《Can-you-fool-AI-with-adversarial-examples-on-a-visual-Turing-test-》论文笔记/</id>
    <published>2017-11-21T12:46:27.000Z</published>
    <updated>2017-11-21T15:52:16.060Z</updated>
    
    <content type="html"><![CDATA[<p>Xu X. Can you fool AI with adversarial examples on a visual Turing test?[J]. 2017.<br><a id="more"></a></p><h2 id="citation"><a href="#citation" class="headerlink" title="citation"></a>citation</h2><p>Xu X. Can you fool AI with adversarial examples on a visual Turing test?[J]. 2017.</p><h2 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h2><p>先介绍<strong>VQA(Visual Question Answering)</strong>：也叫做visual Turing test，也就是让机器学习模型回答一个关于图片的用自然语言表述的问题。可以通过回答的正确度判断模型的效果。<br>VQA问题是深度学习的引用问题中比较复杂的一个分支，涉及的面也比较广，但是同样也会受到对抗样本攻击的影响。在这篇文章中，研究目标就是利用目标对抗攻击，让模型生成特定的question-answer pair。（这是对VQA系统进行对抗攻击的第一次尝试）</p><h2 id="content-and-contributions"><a href="#content-and-contributions" class="headerlink" title="content and contributions"></a>content and contributions</h2><p>本文的<strong>研究内容</strong>如下：</p><pre><code>1.  实验证明了一个训练好的VQA模型也会被对抗攻击影响。这里的攻击设定为白盒攻击：即是已知这个VQA模型的结构和权重。2.  进一步用对抗样本攻击目前效果最好的VQA模型，发现了两个现象：1) 如果目标question-answer对出现频率越大，内容更加想关，回答更加有意义，那么以这个“问答对”作为目标构造的对抗样本成功率更高。（这个现象叫做language prior，也比较好解释，模型往往会选择更加有意义，关联性更强的问答组合作为最终的结果。这种现象在针对具有显示推理特征的VQA模型时更加明显）2) 在VQA问题中构造的对抗样本具有可移植性，说明可以用这个方法构造黑盒攻击。3. 研究在两种训练好的模型的上进行了对抗攻击，一种模型是 bilinear fusion model MCG（结合问题和图片的特征预测答案），一种是组合模型NMN（建立依赖问题的网络布局，让这个网络处理图片得到预测答案）。比较之下，后者更不容易受到对抗样本的影响，说明了这种结构的模型更加稳定。</code></pre><p>研究的<strong>contribution</strong>如下：</p><pre><code>1. 第一个提出针对VQA模型的对抗攻击2. 提出生成对抗样本的新算法3. 实验发现了当目标问答对出现频率比较高时，VQA模型存在目标对抗样本。且这种对抗样本有可移植性4. 发现了language prior现象，即是当以一些问答对作为攻击目标时，效果很差5. 发现组合的神经网络模型更加稳定，这种增强模型稳定性的结构可以作为提升模型鲁棒性的参考。</code></pre><h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><h3 id="VQA"><a href="#VQA" class="headerlink" title="VQA"></a>VQA</h3><p>所谓的VQA，也就是Given an image and a natural language question as an input, the goal of VQA is to predict a natural language answer. 它的应用很广，研究中用到的组合VQA和非组合VQA如下：</p><h4 id="non-compositional"><a href="#non-compositional" class="headerlink" title="non-compositional"></a>non-compositional</h4><p>以[A. Fukui, D. H. Park, D. Yang, A. Rohrbach, T. Darrell, and M. Rohrbach, “Multimodal compact bilinear pooling for visual question answering and visual grounding,” in Proceedings of the Conference on Empirical Methods in Natural Language Processing (EMNLP), 2016.]提出的MCB方法为例。这个方法是先用两个网络模型$f_1$和$f_2$分别映射原始图片和question。它依赖的模型是一个整体结构，可以直观理解为输入端问题和图片到输出端答案的映射，输出就是计算出的$argmax_j(softmax(Wu^.))$。</p><h4 id="compositional"><a href="#compositional" class="headerlink" title="compositional"></a>compositional</h4><p>这种组合模型，比如[R. Hu, J. Andreas, M. Rohrbach, T. Darrell, and K. Saenko,“Learning to reason: End-to-end module networks for visual question answering,” in Proc. of ICCV, 2017.]提出的方法。这种组合可以解释为两步：首先计算根据问题和图片的表达式$u_i^.$；然后基于问题question和$u_i^.$预测答案。<br>也就是这种模型有两步操作，两步依次执行最终给出预测答案。而在Hu等人的研究中，将这两步又拆分成了九个module，比如找到图片中的相关区域算为一个module。这种不同module组合形成的模型，也就叫做组合模型。<br>adversarial examples、Transferability and Black-box Attacks的相关背景比较熟悉，不再赘述</p><h2 id="model-details"><a href="#model-details" class="headerlink" title="model details"></a>model details</h2><p>研究有几个前提：</p><pre><code>1. **白盒攻击**，即是攻击者知道模型的结构和网络权重。因此，攻击者可以计算模型的输出关于输入的梯度值。而本实验就是在这个假设的前提下进行的。利用这个梯度信息，就可以生成降低模型准确度的对抗攻击。2. 目标模型没有任何防御策略：并不会影响本实验的典型性，因为 most existing defense proposals are either not properly evaluated and vulnerable to strong attacks, or only designed for black-box attacks 。3. 攻击形式是指定目标的target attack：原因一是因为非目标攻击威胁不大，其二是因为真实攻击者用目标攻击往往能产生更好的攻击效果。4. attack success rate：攻击成功率用来衡量生成的对抗样本，也是一个标准测量方法。5. 提高模型的输出概率：因为模型是根据输出的概率向量来预测问题的答案，如果这个概率比较低，就容易被防御策略检测出来，因此，提高对抗样本的输出概率值，也能反映攻击的有效性。</code></pre><h2 id="algorithms"><a href="#algorithms" class="headerlink" title="algorithms"></a>algorithms</h2><p>VQA模型定义为$f_\theta(I,Q)$,$\theta$是模型的参数，I是输入图片，Q是输入问题，f的结果是预测的答案概率值。与传统将VQA问题视作分类问题不同，作者将对这个模型$f_\theta$攻击抽象为，构建一个对抗样本图片$I^{adv}$,让模型的输出为问答对$(Q^{target},A^{target})$的概率最大，即是<br>$$f_\theta(Q^{target},A^{target})=A^{target} s.t.d(I^{adv},I^{ori})\le B$$<br>整体的优化问题即是：<br>$$argmin_{I^{adv}}L(J_\theta (I^{adv},Q^{target}),A^{target}) s.t.d(I^{adv},I^{ori})\le B$$</p><p>本文提出的算法优化，主要就是用一种替代目标函数来逼近优化函数，从而提升效率。<br>$$\xi(A^{predict})= L(J_\theta (I^{adv},Q^{target})+\lambda <em>1.l(A</em>{target}\ne A^{predict}.(\tau-L(J_\theta(x,Q^{target},A^{predict})))+\lambda _2.ReLU(d(x,I^{ori})-B+\epsilon)$$<br>整体的算法如下：<br><img src="http://ww3.sinaimg.cn/large/0060lm7Tly1flq4t7v27ej30bn06lmxx.jpg" alt="此处输入图片的描述"></p><h2 id="conclusion"><a href="#conclusion" class="headerlink" title="conclusion"></a>conclusion</h2><p>文章的结论有三个方面：</p><pre><code>1. 目标对抗攻击（本文是目标对抗攻击）的成功率主要受到所选择的question-answer pair的类别的影响，跟参考图片的选择关系不大。2. 发现了language prior phenomenon，给针对特定question-answer pair能产生对抗样本提供了一种可能的解释。3. 发现组合VQA模型结构更加稳定。</code></pre><p>这篇文章对对抗攻击的创新主要就是1）应用在了VQA新场景下2）优化目标函数的方法比较新颖</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Xu X. Can you fool AI with adversarial examples on a visual Turing test?[J]. 2017.&lt;br&gt;
    
    </summary>
    
      <category term="paper" scheme="https://yoursite.com/categories/paper/"/>
    
    
      <category term="papernotes" scheme="https://yoursite.com/tags/papernotes/"/>
    
      <category term="secure" scheme="https://yoursite.com/tags/secure/"/>
    
  </entry>
  
  <entry>
    <title>《Delving into adversarial attacks on deep policies》论文笔记</title>
    <link href="https://yoursite.com/2017/11/19/%E3%80%8ADelving-into-adversarial-attacks-on-deep-policies%E3%80%8B%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <id>https://yoursite.com/2017/11/19/《Delving-into-adversarial-attacks-on-deep-policies》论文笔记/</id>
    <published>2017-11-19T15:53:55.000Z</published>
    <updated>2017-11-21T15:52:03.475Z</updated>
    
    <content type="html"><![CDATA[<p>Kos J, Song D. Delving into adversarial attacks on deep policies[J]. 2017.<br><a id="more"></a></p><h2 id="citation"><a href="#citation" class="headerlink" title="citation"></a>citation</h2><p>Kos J, Song D. Delving into adversarial attacks on deep policies[J]. 2017.</p><h2 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h2><p>这篇文章是关于深度<strong>增强学习策略</strong>网络模型的对抗攻击研究。<br>主要的研究内容有：</p><pre><code>1. 比较对抗样本和随机噪声的攻击性2. 提出了一个基于值函数的可以提高对抗样本生成效率，减少实现一个成功的对抗攻击时需要“入侵”目标模型的次数。3. 研究如何重新训练来增强模型对随机噪声和FGSM攻击的稳定性。</code></pre><h2 id="study-content"><a href="#study-content" class="headerlink" title="study content"></a>study content</h2><p>这篇文章contribution和objects都是三个：</p><pre><code>1. 比较了随机噪声和对抗样本对深度增强学习策略模型deep reinforcement learning (DRL) 的影响。发现了采用这种DRL策略的模型也容易受到对抗样本的攻击。2. 提出了利用增强学习策略中的值函数来引导攻击者选择在原始样本中添加对抗扰动的时间。（这种构造对抗样本的方法相比于以前在图片分类等等任务中，间隔固定时间添加对抗扰动的策略更复杂一些，但是作者发现这样效率更高）3. 通过re-training可以增强策略的稳定性。初步结果表明，通过re-training，agents可以对FGSM生成的对抗样本和随机噪音都更加稳定。同时，作者也研究了这种提高的稳定性是否会根据扰动的不同规模和不同种类而发生改变。发现这种方法并不能增强模型对其他攻击类型的防御能力。</code></pre><p>对第二个研究目标，作者提出了三个方法来探究是否减少了添加perturbation的频率也能生成有效的对抗样本：1)每隔N步给原始样本注入一次扰动，在间隔中计算扰动但是不添加到样本中；2)每隔N步计算一次扰动，并加入到数据样本中；3)引入一个“值函数”，计算什么时候添加扰动效果最好，确保添加的时机让这个值函数处于阈值。</p><h2 id="experimental-evaluation"><a href="#experimental-evaluation" class="headerlink" title="experimental evaluation"></a>experimental evaluation</h2><p>这部分首先是介绍两个概念，A3C算法是一个应用在深度增强学习任务中的比较成功的算法：通过策略权值的异步更新权值。<br>[Volodymyr Mnih, Adria Puigdomenech Badia, Mehdi Mirza, Alex Graves, Timothy P Lillicrap, Tim Harley, David Silver, and Koray Kavukcuoglu. Asynchronous methods for deep reinforcement learning. In International Conference on Machine Learning, 2016.]<br>另一个概念是FGSM，也就是  Goodfellow等人提出的比较典型的对抗样本生成算法。<br>实验首先在base-line的情况下得到了一个在Atari Pong任务中训练得到的增强模型，然后设定FGSM中的对抗扰动规模超参数$\epsilon$，并得到对抗样本。同时从均匀分布$unif(0,β)$随机取样得到随机噪声。<br><strong>实验结果</strong>上，第一个任务没有什么值得注意的。对于第二个任务，这里的N设为10，实验结果如图：<br><img src="http://ww4.sinaimg.cn/large/0060lm7Tly1floxb9x6nqj30qi0akmyf.jpg" alt="此处输入图片的描述"><br>在$\epsilon$为0.005，扰动规模一定的情况下，第一个方法生成的对抗样本效果不如每隔10步计算一次perturbation得到的样本（方法2）效果更好。<br>同时，用一个让值函数大于一个阈值时才加入对抗扰动的策略，如下图：<br><img src="http://ww4.sinaimg.cn/large/0060lm7Tly1floxhetyc7j30cm0a4t9j.jpg" alt="此处输入图片的描述"><br>红色的线表示值函数的变化，这个值函数即是增强学习的反馈值。当这个函数大于一定值的时机加入对抗扰动，即是这个扰动也更加贴近模型训练时的反馈。<br>最终的结论是，在增强学习背景下，用基于值函数得到的对抗样本，尽管更加复杂，但是也更加高效，得到的样本对抗性更强。</p><h2 id="conclusion"><a href="#conclusion" class="headerlink" title="conclusion"></a>conclusion</h2><p>今年才开始有将对抗样本应用到增强学习领域的相关研究。相比于《Vulnerability of Deep Reinforcement Learning to Policy Induction Attacks》，，前者是通过改变对抗样本训练策略，将对抗样本的训练和增强学习的反馈结合起来，得到更高效且效果更好的攻击样本。后者针对的策略是Deep Q-networks，并且是利用了对抗样本的transferability。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kos J, Song D. Delving into adversarial attacks on deep policies[J]. 2017.&lt;br&gt;
    
    </summary>
    
      <category term="paper" scheme="https://yoursite.com/categories/paper/"/>
    
    
      <category term="papernotes" scheme="https://yoursite.com/tags/papernotes/"/>
    
      <category term="secure" scheme="https://yoursite.com/tags/secure/"/>
    
  </entry>
  
  <entry>
    <title>《Generative Face Completion》论文笔记</title>
    <link href="https://yoursite.com/2017/11/18/%E3%80%8AGenerative-Face-Completion%E3%80%8B%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <id>https://yoursite.com/2017/11/18/《Generative-Face-Completion》论文笔记/</id>
    <published>2017-11-18T08:46:15.000Z</published>
    <updated>2017-11-22T08:53:42.601Z</updated>
    
    <content type="html"><![CDATA[<p>Title: Generative Face Completion<br>Authors:  Li, Yijun; Liu, Sifei; Yang, Jimei; Yang, Ming-Hsuan<br>Publication: eprint arXiv:1704.05838<br>Publication Date:  04/2017<br>Origin:  ARXIV<br>Keywords: Computer Science - Computer Vision and Pattern Recognition<br>Comment: Accepted by CVPR 2017<br>Bibliographic Code: 2017arXiv170405838L </p><a id="more"></a><h2 id="citation"><a href="#citation" class="headerlink" title="citation"></a>citation</h2><p>Li Y, Liu S, Yang J, et al. Generative Face Completion[J]. 2017.</p><h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h2><p>论文用深度生成模型实现了一个高效面部补全算法。与传统从已给数据集中搜寻相似图片块儿来进行补全和合成残缺图片的方法不同，作者是直接使用一个神经网络来合成残缺部分的内容。整个模型由三部分构成：a reconstruction loss、two adversarial losses、a semantic parsing loss。</p><p><strong>a) 论文目的：</strong></p><p>传统以复制-粘贴的方式来进行图片补全在背景填充方面效果不错，但在面对填充脸部图片这种目标图片比较独特时却效果不佳。作者于是想用深度生成模型构建一个有效的目标补全算法，能不需要参照外部数据集快速完成对图片的补全。</p><p><strong>b) 论文贡献：</strong></p><p>首先提出了一个深度生成补全图片补全模型，这个模型通过encoding-decoding 生成器、两个对抗判别器来合成用随机噪声遮挡的部分；其次对挑战性的脸部补全任务进行处理，并且实现提出的模型能够根据学习到的目标特征，产生整体比较和谐的图片；最后，作者证明了生成semantic parsing部分的有效性。</p><p><strong>c) 模型结构：</strong></p><p>整体结构如下图：<br><img src="http://img.blog.csdn.net/20170426165038520?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbTBfMzcyMzEwMTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>生成器G：结构有encoder层、两个全连接层和decoder层，输入的残缺图片通过encoder层映射成隐藏特征，然后再通过decoder层得出生成的图片。里面的encoder层是两层以上卷积层加上一层以上池化层，decoder层与encoder对称。</p><p>判别器D：如果只有一个生成器，那么生成的图片将会非常模糊，只有一个粗略的轮廓。因此，采用了两个判别器来对生成图片的细节进行完善，使得生成的图片更加真实。其中，有两个判别器：local discriminator和global discriminator。其中，局部判别器是为了让生成器生成图片中补全的部分更加真实，而整体的判别器是为了让整个生成的图片看起来更加真实。</p><p>Semantic Regularization：前面的两个部分其实就是原始GAN的变形，作者加上后面这一部分的原因是，前面生成的图片虽然整体上轮廓清晰比较真实，但是看上去却不像是人脸的图片。如下图：</p><p><img src="http://img.blog.csdn.net/20170426165055177?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbTBfMzcyMzEwMTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>加上autoencoder结构的semantic parsing network之后，生成的图片会更加和谐：</p><p><img src="http://img.blog.csdn.net/20170426165112396?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbTBfMzcyMzEwMTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>d) 损失函数：</strong></p><p>因为模型分为三部分，因此损失函数也有三部分：<br>    整体的损失函数如下：<br>        $$L = L_r + λ_1L_{a1} + λ_2L_{a2} + λ_3L_p$$<br>    其中，<br>    ①$L_r$是生成器的损失，就是输入与输出的二阶范数。<br>    ②$L_{a1}$与$L_{a2}$是两个判别器的损失，其形式跟GAN的判别器损失大同小异：</p><p><img src="http://img.blog.csdn.net/20170426165144818?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbTBfMzcyMzEwMTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>③Lp就是semantic parsing network的损失，就是简单的softmax层损失。<br>    它们前面的参数是用来平衡各个部分损失不同影响的。</p><p><strong>e) 训练步骤：</strong></p><p>与我上一篇看的pix2pix两步走的训练步骤类似，作者采用了三步训练：<br>    ①用生成器直接训练，得到模糊的结果；<br>    ②用局部判别器损失来微调生成模型；<br>    ③联合整体判别器和意义转化网络损失来调整生成模型参数。<br>    这个方法据说可以避免训练开始阶段判别器的作用过强。和我毕设的预训练类似。</p><p><strong>f) 数据集选择：</strong></p><p>作者用到了两个数据集，一个是Celeb A，一个是Helen test数据集，这两个数据集都是面部图片的集合，并且后者还有segment label。以后做实验可以考虑使用。</p><p><strong>g) 实验结果：</strong></p><p>作者将自己模型产生的结果与CE模型产生的结果进行直接对比，并用了三种测量标准测试，证明作者提出的模型效果更好。作者还做了遮挡不同面积的图片，来观察结果的效果，并得出在size是32×32时效果是最好的，因为此时的遮挡面积刚好是面部器官的一部分，比如半只眼睛。</p><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>a)    训练步骤也有一个预训练部分（只训练生成器），和我毕设中对生成器预训练类似。以前一直以为只是用来让后面的训练时间更短，论文中提到这样训练也可以避免在训练的初始阶段，判别器的作用太强，影响训练效果。</p><p>b)    论文对GAN的变形方式值得借鉴，采用两个判别器的模型分别完成对局部和整体的训练，思路很好。<br>d）    作者在模型的最后部分还采用了一个semantic parsing networks结构，这个部分能让整体的输出更加和谐，具体的参考论文还没了解，因此其原理了解很模糊。<br>e)    论文的目的是对独特的目标图片进行补全，以面部图片为例，但是论文一直是以脸部图片作为实验训练集，如果能加入其他比较独特的图片，比如建筑、动物等，可能说服力会更强。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Title: Generative Face Completion&lt;br&gt;Authors:  Li, Yijun; Liu, Sifei; Yang, Jimei; Yang, Ming-Hsuan&lt;br&gt;Publication: eprint arXiv:1704.05838&lt;br&gt;Publication Date:  04/2017&lt;br&gt;Origin:  ARXIV&lt;br&gt;Keywords: Computer Science - Computer Vision and Pattern Recognition&lt;br&gt;Comment: Accepted by CVPR 2017&lt;br&gt;Bibliographic Code: 2017arXiv170405838L &lt;/p&gt;
    
    </summary>
    
      <category term="paper" scheme="https://yoursite.com/categories/paper/"/>
    
    
      <category term="papernotes" scheme="https://yoursite.com/tags/papernotes/"/>
    
      <category term="secure" scheme="https://yoursite.com/tags/secure/"/>
    
  </entry>
  
  <entry>
    <title>《NO Need to Worry about Adversarial Examples in Object Detection in Autonomous Vehicles》论文笔记</title>
    <link href="https://yoursite.com/2017/11/02/%E3%80%8ANO-Need-to-Worry-about-Adversarial-Examples-in-Object-Detection-in-Autonomous-Vehicles%E3%80%8B%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <id>https://yoursite.com/2017/11/02/《NO-Need-to-Worry-about-Adversarial-Examples-in-Object-Detection-in-Autonomous-Vehicles》论文笔记/</id>
    <published>2017-11-02T02:30:03.000Z</published>
    <updated>2017-11-03T06:38:48.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="citation"><a href="#citation" class="headerlink" title="citation"></a>citation</h2><p>Lu J, Sibai H, Fabry E, et al. NO Need to Worry about Adversarial Examples in Object Detection in Autonomous Vehicles[J]. 2017.</p><a id="more"></a><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>这篇文章是在<strong>《Adversarial examples in the physical world》</strong>（A. Kurakin, I. J. Goodfellow, and S. Bengio. Adversarial examples in the physical world. CoRR, abs/1607.02533, 2016.）的基础上的进一步研究。因为在传统的对抗攻击构建过程中，对抗perturbation直接和数字图片叠加，作为神经网络模型的输入。Kurakin等人的研究中，对抗的perturbation被生成之后，如果和原始数据叠加后，不是直接作为模型的输入，而是通过相机拍摄的方式输入到模型中。Kurakin等人的研究模拟了实际physical场景下的对抗攻击场景，并且证明了对抗扰动在从对抗样本到拍照后的对抗样本的转化过程中，虽然有相机的noise，仍然是具有对抗性的。<br>同时，也因为<strong>《Concrete Problems for Autonomous Vehicle Safety: Advantages of Bayesian Deep Learning》</strong>（Mcallister R, Gal Y, Kendall A, et al. Concrete Problems for Autonomous Vehicle Safety: Advantages of Bayesian Deep Learning[C]// Twenty-Sixth International Joint Conference on Artificial Intelligence. 2017:4745-4753.）中应用对抗攻击到自动汽车驾驶问题中的挑战问题。<br>另一个相关研究是<strong>《Accessorize to a crime: Real and stealthy attacks on state-ofthe-art face recognition》</strong>（M. Sharif, S. Bhagavatula, L. Bauer, and M. K. Reiter. Accessorize to a crime: Real and stealthy attacks on state-ofthe-art face recognition. In Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security, CCS ’16, pages 1528–1540, New York, NY, USA, 2016. ACM. ），本文的研究证明了在面部识别的实际应用中，通过构建对抗样本，不论是否已知面部识别模型的结构（黑盒或者白盒攻击），都可以在把实际拍摄脸部照片作为模型输入的情况下，极大地影响识别的结果。<br>上述研究都给神经网络模型的实际应用带来了很多concern。</p><p><strong>本文</strong>的研究则是通过一些实验，证实物理世界中的对抗攻击在多种距离和角度效果不佳。在汽车驾驶中交通标示识别实验中，大部分的在汽车行进过程中拍摄对抗样本都被分类模型正确分类。</p><h2 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h2><p>论文的实验方法是使用多种攻击方法测试得到训练好的模型的稳定性。并且训练的模型有两种不同的结构。所用的数据集是width<em>length</em>depth的三维向量。<br>所用的攻击方法有：</p><ul><li>Goodfellow提出的<strong>FGSM</strong><br>[I. J. Goodfellow, J. Shlens, and C. Szegedy. Explaining and harnessing adversarial examples. arXiv preprint arXiv:1412.6572, 2014.]</li><li>Kurakin等人提出的<strong>迭代FGSM</strong><br>[A. Kurakin, I. J. Goodfellow, and S. Bengio. Adversarial examples in the physical world.CoRR, abs/1607.02533, 2016.]</li><li>Szegedy 等提出的<strong>L-BFGS方法</strong><br>[C. Szegedy, W. Zaremba, I. Sutskever, J. Bruna, D. Erhan,I. Goodfellow, and R. Fergus. Intriguing properties of neural networks. arXiv preprint arXiv:1312.6199, 2013.]</li></ul><p>与一般的对抗攻击研究只针对分类问题不同，本文所攻击的目标模型也采用了探测器模型：the <strong>YOLO multiple object detector</strong> [J. Redmon, S. Divvala, R. Girshick, and A. Farhadi. You only look once: Unified, real-time object detection. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pages 779–788, 2016.]<br>本文中classifier与detector的不同之处在于：</p><ul><li><p>classifier使用交叉熵损失函数，衡量输入图片真正的标签($y_{true}$)和输出的one-hot标签($y_{fool}$)的差别。</p></li><li><p>detector中，模型的输出是向量$p_{output}$ ，但是输入样本却没有one-hot标示的标签（因为输入的数据是即时的，一直变化的）。因此实验设置是输入的标签的维度和输出一样，都为 $ l_{p_{output}} $ 。</p></li></ul><p>本文的实验方法与前面提到的攻击算法研究中修改图片不同，关注的是在物理世界的攻击，也就是打印应用这些攻击之后的图片并测试目标模型的稳定性。应用到实际场景时，作者考虑了<strong>拍摄相机与目标的距离</strong>和<strong>拍摄角度</strong>的变量影响。</p><h2 id="experimental-results"><a href="#experimental-results" class="headerlink" title="experimental results"></a>experimental results</h2><ul><li>分析生成的对抗样本结果<br>首先是针对detector目标模型生成的对抗样本：<br><img src="http://ww2.sinaimg.cn/large/0060lm7Tly1fl4pq1sy7pj30gn04raac.jpg" alt="此处输入图片的描述"><br>对比针对traffic sign classifier生成的对抗样本：<br><img src="http://ww1.sinaimg.cn/large/0060lm7Tly1fl4pq38tx7j30gl04wq7c.jpg" alt="此处输入图片的描述"><br>可以发现前者的密度更低。从直观理解也很容易，因为密度越高的对抗扰动可以让探测器的实时监测扰动更加困难。</li><li>整体的对抗样本稳定性的实验结果<br><img src="http://ww3.sinaimg.cn/large/0060lm7Tly1fl4pq4gonwj30n108twfz.jpg" alt="此处输入图片的描述"><br>DR%代表这个stop标志被识别的概率。表格中的Ori指的是完整的图片，Crop则指的是裁剪出只有交通标志的部分。表格的左边是对抗样本在直接作为模型输入时的对抗效果，右边是在现实场景下的实验结果。<br>从表格可以得出下面的结论： </li><li>只关注标志本身的，经过裁剪之后的对抗样本效果更好</li><li>在实际应用场景下，对抗样本的对抗性会随着距离的增加而减弱，模型的识别准确率会更高</li><li>从结果来看对抗攻击方法的效果，L-BFGS整体要差于FGSM方法。</li></ul><p>而这篇文章主要关注的变量，也就是对样本效果影响最大的变量，就是距离的变化。从实验结果中最后两列可以看出，随着距离的增加，对抗样本的对抗性衰减十分明显。但是这种情况也有例外，这说明了对抗扰动的效果在随着距离而变化。因此，在实际应用场景下，探测系统/分类模型只需要调整距离和角度，是可以实现正确识别输入样本的。</p><h2 id="conclusion"><a href="#conclusion" class="headerlink" title="conclusion"></a>conclusion</h2><p>此外，这两天的对比看文章，和前几天看的《Standard detectors aren’t (currently) fooled by physical adversarial stop signs》比较相似，这一类的文章的内容只是通过实验推翻了前面研究的实验结果。<br>不过本文的观点显然也有一定的缺陷，因为在很多场景下，人们允许的失误率阈值会比较低，甚至不能容忍模型的识别错误。本文只是说明了对抗的效果没有Kurakin等人的研究中那么显著而已。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;citation&quot;&gt;&lt;a href=&quot;#citation&quot; class=&quot;headerlink&quot; title=&quot;citation&quot;&gt;&lt;/a&gt;citation&lt;/h2&gt;&lt;p&gt;Lu J, Sibai H, Fabry E, et al. NO Need to Worry about Adversarial Examples in Object Detection in Autonomous Vehicles[J]. 2017.&lt;/p&gt;
    
    </summary>
    
      <category term="paper" scheme="https://yoursite.com/categories/paper/"/>
    
    
      <category term="papernotes" scheme="https://yoursite.com/tags/papernotes/"/>
    
      <category term="secure" scheme="https://yoursite.com/tags/secure/"/>
    
  </entry>
  
</feed>
