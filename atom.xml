<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fan Wu&#39;s Blog</title>
  
  <subtitle>Nothing is impossible!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yoursite.com/"/>
  <updated>2019-03-12T07:37:06.736Z</updated>
  <id>https://yoursite.com/</id>
  
  <author>
    <name>Fan Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法之美-用两个X实现一个Y</title>
    <link href="https://yoursite.com/2019/02/21/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E2%80%94%E2%80%94%E7%94%A8%E4%B8%A4%E4%B8%AAX%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAY/"/>
    <id>https://yoursite.com/2019/02/21/算法之美——用两个X实现一个Y/</id>
    <published>2019-02-21T12:01:01.000Z</published>
    <updated>2019-03-12T07:37:06.736Z</updated>
    
    <content type="html"><![CDATA[<p>对于经典面试题：“两个栈实现队列”和“两个队列实现栈”,应该怎么考虑呢？<br><a id="more"></a></p><h2 id="两个栈实现队列"><a href="#两个栈实现队列" class="headerlink" title="两个栈实现队列"></a>两个栈实现队列</h2><p><strong>思路:</strong> 利用inStack作为进队的缓存。出队时，因为考虑到“先进先出”，可以利用另一个栈outStack转存当前的缓存。出队时，为了保证再入队依旧满足规律，若outStack为空，先<strong>全部</strong>倒入outStack；若不为空，则outStack直接出栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Stack&lt;Integer&gt; inStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> Stack&lt;Integer&gt; outStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(Integer in)</span></span>&#123;</span><br><span class="line">    inStack.push(in);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Integer <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(outStack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(!inStack.isEmpty())&#123;</span><br><span class="line">            outStack.push(inStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(outStack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"no data"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> outStack.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Solution9 test = <span class="keyword">new</span> Solution9();</span><br><span class="line">    test.push(<span class="number">8</span>);</span><br><span class="line">    test.push(<span class="number">9</span>);</span><br><span class="line">    test.push(<span class="number">99</span>);</span><br><span class="line">    System.out.println(test.pop());</span><br><span class="line">    test.push(<span class="number">999</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两个队列实现栈"><a href="#两个队列实现栈" class="headerlink" title="两个队列实现栈"></a>两个队列实现栈</h2><p><strong>思路：</strong> 利用一个队存储，另一个队作为缓存。当出栈时，让非空的队列先出队n-1，最后剩下的一个出队则完成了栈的“先入先出”的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; queue1=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();  </span><br><span class="line">LinkedList&lt;Integer&gt; queue2=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span><span class="comment">//入栈  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    queue1.addLast(value);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span><span class="comment">//出栈     必须是非空的栈才能出栈啊  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(sSize()!=<span class="number">0</span>)<span class="comment">//栈不为空  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//移动一个队的n-1个到另一个中  </span></span><br><span class="line">        <span class="keyword">if</span>(!queue1.isEmpty())<span class="comment">//q1 空  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            putN_1ToAnthor();  </span><br><span class="line">            <span class="keyword">return</span> queue1.removeFirst();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//q2 空  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            putN_1ToAnthor();  </span><br><span class="line">            <span class="keyword">return</span> queue2.removeFirst();  </span><br><span class="line">        &#125;          </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">"栈已经为空啦，不能出栈"</span>);  </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sSize</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> queue1.size()+queue2.size();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putN_1ToAnthor</span><span class="params">()</span><span class="comment">//从非空中出队n-1个到另一个队列   因为队列总是一空一非空  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(!queue1.isEmpty())  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">while</span>(queue1.size()&gt;<span class="number">1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            queue2.addLast(queue1.removeFirst());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!queue2.isEmpty())  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">while</span>(queue2.size()&gt;<span class="number">1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            queue1.addLast(queue2.removeFirst());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其他类似题目（不断更新中。。）</p></blockquote><h2 id="包含-min-函数的栈"><a href="#包含-min-函数的栈" class="headerlink" title="包含 min 函数的栈"></a>包含 min 函数的栈</h2><p><strong>题目描述</strong>：定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; datastack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minstack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        datastack.push(node);</span><br><span class="line"><span class="comment">//        if(minstack.isEmpty())&#123;</span></span><br><span class="line"><span class="comment">//            minstack.push(node);</span></span><br><span class="line"><span class="comment">//        &#125;else&#123;</span></span><br><span class="line"><span class="comment">//            if(minstack.peek()&lt;node)&#123;</span></span><br><span class="line"><span class="comment">//                minstack.push(minstack.peek());</span></span><br><span class="line"><span class="comment">//            &#125;else&#123;</span></span><br><span class="line"><span class="comment">//                minstack.push(node);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//注意minstack栈顶始终存储的当前栈的最小值，且长度和datastack一样</span></span><br><span class="line">        minStack.push(minStack.isEmpty() ? node : Math.min(minStack.peek(), node));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        datastack.pop();</span><br><span class="line">        minstack.pop();<span class="comment">//注意这里</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> datastack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minstack.peek();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a>数据流中的中位数</h2><p><strong>题目描述</strong>：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p><blockquote><p>两个栈实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用两个栈实现的</span></span><br><span class="line">    Stack&lt;Integer&gt; min = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; max = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        number++;</span><br><span class="line">        <span class="keyword">if</span>(min.size() == <span class="number">0</span> &amp;&amp; (max.size() == <span class="number">0</span> || num &lt;= max.peek()))&#123;</span><br><span class="line">            min.push(num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max.size() == <span class="number">0</span> &amp;&amp; (min.size() == <span class="number">0</span> || num &gt;= min.peek()))&#123;</span><br><span class="line">            max.push(num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num &gt; max.peek())&#123;</span><br><span class="line">            <span class="keyword">while</span>(max.size() != <span class="number">0</span> &amp;&amp; num&gt;max.peek())&#123;</span><br><span class="line">                min.push(max.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; min.peek())&#123;</span><br><span class="line">            <span class="keyword">while</span>( min.size() != <span class="number">0</span>&amp;&amp; num&lt;min.peek() )&#123;</span><br><span class="line">                max.push(min.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        min.push(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(min.size()&lt;number/<span class="number">2</span>)&#123;</span><br><span class="line">            min.push(max.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(min.size()&gt;number/<span class="number">2</span>)&#123;</span><br><span class="line">            max.push(min.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(number%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (min.peek()+max.peek())/<span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)max.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>两个大根堆实现：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//用堆实现的</span></span><br><span class="line">    <span class="comment">/* 大顶堆，存储左半边元素 */</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; left = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line">    <span class="comment">/* 小顶堆，存储右半边元素，并且右半边元素都大于左半边 */</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; right = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="comment">/* 当前数据流读入的元素个数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert2</span><span class="params">(Integer val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 插入要保证两个堆存于平衡状态 */</span></span><br><span class="line">        <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* N 为偶数的情况下插入到右半边。</span></span><br><span class="line"><span class="comment">* 因为右半边元素都要大于左半边，但是新插入的元素不一定比左半边元素</span></span><br><span class="line"><span class="comment">来的大，</span></span><br><span class="line"><span class="comment">* 因此需要先将元素插入左半边，然后利用左半边为大顶堆的特点，取出堆</span></span><br><span class="line"><span class="comment">顶元素即为最大元素，此时插入右半边 */</span></span><br><span class="line">            left.add(val);</span><br><span class="line">            right.add(left.poll());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right.add(val);</span><br><span class="line">            left.add(right.poll());</span><br><span class="line">        &#125; N</span><br><span class="line">                ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (left.peek() + right.peek()) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) right.peek();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于经典面试题：“两个栈实现队列”和“两个队列实现栈”,应该怎么考虑呢？&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="https://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="algorithms" scheme="https://yoursite.com/tags/algorithms/"/>
    
      <category term="coding" scheme="https://yoursite.com/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>算法之美-回溯</title>
    <link href="https://yoursite.com/2019/01/21/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E5%9B%9E%E6%BA%AF/"/>
    <id>https://yoursite.com/2019/01/21/算法之美-回溯/</id>
    <published>2019-01-21T08:01:01.000Z</published>
    <updated>2019-03-11T01:48:32.625Z</updated>
    
    <content type="html"><![CDATA[<p>N皇后的问题应该怎么解决？回溯法来帮忙！<br><img src="https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike72%2C5%2C5%2C72%2C24/sign=b8f564729c22720e6fc3eaa81aa26123/b2de9c82d158ccbfdd83742a1dd8bc3eb13541e7.jpg" alt="此处输入图片的描述"><br><a id="more"></a></p><h2 id="什么是回溯？"><a href="#什么是回溯？" class="headerlink" title="什么是回溯？"></a>什么是回溯？</h2><p><strong>回溯</strong>法思路的简单描述是：把问题的解空间转化成了图或者树的结构表示，然后使用深度优先搜索策略进行遍历，遍历的过程中记录和寻找所有可行解或者最优解。基本思想类同于图的深度优先搜索和二叉树的后序遍历。</p><p>回溯法按深度优先策略搜索问题的解空间树。首先从根节点出发搜索解空间树，当算法搜索至解空间树的某一节点时，先利用剪枝函数判断该节点是否可行（即能得到问题的解）。如果不可行，则跳过对该节点为根的子树的搜索，逐层向其祖先节点回溯；否则，进入该子树，继续按深度优先策略搜索。</p><p>回溯法的基本思想是按照输入数组的顺序，每一层递归处理一个元素，当处理到最后一层的时候，也就是把数组中的所有元素都处理完的时候，把当前结果加入到最后的返回结果中。值得注意的是，每次在递归到下一层之前，我们加入了某个要处理的元素X，在下一层递归返回之后，我们要把之前加入的元素X从当前结果中取出来。如果我们不把元素X取出来，那么在下一次循环中，我们还会加入新的元素Y。那么在这一层递归中就相当于处理了不止一个新元素。</p><h2 id="经典题目实例"><a href="#经典题目实例" class="headerlink" title="经典题目实例"></a>经典题目实例</h2><h3 id="1-矩阵中的路径"><a href="#1-矩阵中的路径" class="headerlink" title="(1) 矩阵中的路径"></a>(1) 矩阵中的路径</h3><p><strong>题目描述</strong>：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。<br><strong>题解：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">private int rows;</span><br><span class="line">private int cols;</span><br><span class="line">public boolean hasPath(char[] array, int rows, int cols, char[] str) &#123;</span><br><span class="line">    //异常情况判断</span><br><span class="line">    if(array.length == 0 || array.length != rows * cols)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if(str.length == 0)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    char[][] matrix = new char[rows][cols];</span><br><span class="line">    boolean[][] mark = new boolean[rows][cols];</span><br><span class="line"></span><br><span class="line">    this.rows = rows;</span><br><span class="line">    this.cols = cols;</span><br><span class="line">    //把一维数组转化成二维矩阵</span><br><span class="line">    for (int r = 0, idx = 0; r &lt; rows; r++) &#123;  //注意括号内的inx的定义方式</span><br><span class="line">        for (int c = 0; c &lt; cols; c++) &#123;</span><br><span class="line">            matrix[r][c] = array[idx++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //遍历数组每个元素，依次与字符串比较</span><br><span class="line">    for (int r = 0; r &lt; rows; r++) &#123;</span><br><span class="line">        for (int c = 0; c &lt; cols; c++) &#123;</span><br><span class="line">            if (matrix[r][c] == str[0]) &#123;</span><br><span class="line">                mark[r][c] = true;</span><br><span class="line">                if(helper(matrix, r, c, str,mark, 0))&#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                mark[r][c] = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//回溯算法的主体，依次迭代，直到最后的结论；</span><br><span class="line">private boolean helper(char[][] matrix, int r, int c, char[] str,boolean[][] mark, int number) &#123;</span><br><span class="line"></span><br><span class="line">    if(number == str.length-1)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    number += 1;</span><br><span class="line">    if(r-1 &gt;=0)&#123;</span><br><span class="line">        if(matrix[r-1][c] == str[number] &amp;&amp; !mark[r-1][c])&#123;</span><br><span class="line">            mark[r-1][c] = true;</span><br><span class="line">            if(helper(matrix, r-1, c, str, mark, number))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(r+1 &lt; rows)&#123;</span><br><span class="line">        if(matrix[r+1][c] == str[number] &amp;&amp; !mark[r+1][c])&#123;</span><br><span class="line">            mark[r+1][c] = true;</span><br><span class="line"></span><br><span class="line">            if(helper(matrix, r+1, c, str, mark, number))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(c-1 &gt;= 0)&#123;</span><br><span class="line">        if(matrix[r][c-1] == str[number] &amp;&amp; !mark[r][c-1])&#123;</span><br><span class="line">            mark[r][c-1] = true;</span><br><span class="line">            if(helper(matrix, r, c-1, str, mark, number))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(c+1 &lt; cols)&#123;</span><br><span class="line">        if(matrix[r][c+1] == str[number] &amp;&amp; !mark[r][c+1])&#123;</span><br><span class="line">            mark[r][c+1] = true;</span><br><span class="line">            if(helper(matrix, r, c+1, str, mark, number))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="（2）机器人的运动范围"><a href="#（2）机器人的运动范围" class="headerlink" title="（2）机器人的运动范围"></a>（2）机器人的运动范围</h3><p><strong>题目描述：</strong>地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k 的格子。例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,38)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？<br><strong>题解：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">private int rows;</span><br><span class="line">private int cols;</span><br><span class="line">private int result = 0;</span><br><span class="line">private boolean[][] mark;</span><br><span class="line">public int movingCount(int threshold, int rows, int cols)&#123;</span><br><span class="line">    this.rows = rows;</span><br><span class="line">    this.cols = cols;</span><br><span class="line">    this.mark = new boolean[rows][cols];</span><br><span class="line">    boolean[][] marktmp = new boolean[rows][cols];</span><br><span class="line">    //注意边界问题</span><br><span class="line">    if(!(threshold &lt;= 0 || rows &lt;=0 || cols &lt;=0))&#123;</span><br><span class="line">        helper(threshold,rows,cols,0,0,marktmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">//回溯法核心</span><br><span class="line">private void helper(int threshold, int rows, int cols, int r, int c, boolean[][] marktmp) &#123;</span><br><span class="line">    if(judge(threshold,r,c) &amp;&amp; !marktmp[r][c])&#123;</span><br><span class="line">        System.out.println(Integer.toString(threshold)+&quot; &quot;+Integer.toString(r)+&quot; &quot;+Integer.toString(c));</span><br><span class="line">        marktmp[r][c] = true;</span><br><span class="line">        if(mark[r][c] == false)&#123;</span><br><span class="line">            mark[r][c] = true;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(r+1 &lt; rows)&#123;</span><br><span class="line">            helper(threshold,rows,cols,r+1,c,marktmp);</span><br><span class="line">        &#125;</span><br><span class="line">        if(c+1&lt;cols)&#123;</span><br><span class="line">            helper(threshold,rows,cols,r,c+1,marktmp);</span><br><span class="line">        &#125;</span><br><span class="line">        if(r-1 &gt;=0)&#123;</span><br><span class="line">            helper(threshold,rows,cols,r-1,c,marktmp);</span><br><span class="line">        &#125;</span><br><span class="line">        if(c-1 &gt;=0)&#123;</span><br><span class="line">            helper(threshold,rows,cols,r,c-1,marktmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//判断是否符合规则</span><br><span class="line">private boolean judge(int threshold, int row, int col)&#123;</span><br><span class="line">    int tmp = 0;</span><br><span class="line">    while(row &gt;0)&#123;</span><br><span class="line">        tmp += row%10;</span><br><span class="line">        row/=10;</span><br><span class="line">    &#125;</span><br><span class="line">    while(col &gt;0)&#123;</span><br><span class="line">        tmp += col%10;</span><br><span class="line">        col/=10;</span><br><span class="line">    &#125;</span><br><span class="line">    return threshold &gt;= tmp?true:false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="（3）N皇后问题"><a href="#（3）N皇后问题" class="headerlink" title="（3）N皇后问题"></a>（3）N皇后问题</h3><p><strong>题目描述：</strong>要求在一个n×n的棋盘上放置n个皇后，使得它们彼此不受攻击。按照国际象棋的规则，一个皇后可以攻击与之同一行或同一列或同一斜线上的任何棋子。因此，n皇后问题等价于：要求在一个n×n的棋盘上放置n个皇后，使得任意两个皇后不在同一行或同一列或同一斜线上。<br><strong>题解：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">   private static int SIZE = 0;//皇后的个数</span><br><span class="line">private static int count = 0;//记录摆放的方式数</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">Scanner input = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;请输入你要解决几个皇后的问题&quot;);</span><br><span class="line">SIZE = input.nextInt();</span><br><span class="line">input.close();</span><br><span class="line"> LinkedList&lt;Location&gt; list = new LinkedList&lt;Location&gt;();</span><br><span class="line">     NQueen(list, 0, 0);  //从棋盘的第0行第0列开始</span><br><span class="line">     System.out.println(SIZE + &quot;皇后共有 &quot; + count + &quot;种摆放方式&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">static class Location&#123;</span><br><span class="line">int x;//对应棋盘的行</span><br><span class="line">int y;//对应棋盘的列</span><br><span class="line"></span><br><span class="line">Location(int x,int y)&#123;</span><br><span class="line">this.x = x;</span><br><span class="line">this.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;(&quot; + x + &quot;,&quot; + y + &quot;)&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">    * 主要函数，用回溯法。</span><br><span class="line">    */</span><br><span class="line">   private static void NQueen(LinkedList&lt;Location&gt; list, int x, int y) &#123;   </span><br><span class="line"></span><br><span class="line">       if(list.size() == SIZE)&#123;  //当list元素个数为SIZE时，表示SIZE个皇后都摆放完毕，打印后即可退出函数。</span><br><span class="line">           printLocation(list);  //打印皇后摆放方式</span><br><span class="line">           return ;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       for(int i = x ; i &lt; SIZE ; i++)&#123;</span><br><span class="line">           Location loc = new Location(i, y);</span><br><span class="line">           if(isLegalLoc(list, loc))&#123;</span><br><span class="line">               list.offer(loc);  //将第y行的皇后摆放好</span><br><span class="line">               NQueen(list, 0, y+1);  //开始摆放y+1行的皇后，同样从第0列开始摆放</span><br><span class="line">               list.pollLast();  //每次摆放完一个皇后后，都要将其撤回，再试探其它的摆法。</span><br><span class="line">           &#125;                   </span><br><span class="line">       &#125;           </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">    * 判断位置为loc的皇后是否合法</span><br><span class="line">    */</span><br><span class="line">   private static boolean isLegalLoc(LinkedList&lt;Location&gt; list, Location loc) &#123;</span><br><span class="line">       for(Location each : list)&#123;</span><br><span class="line">           if(loc.x == each.x || loc.y == each.y)  //判断是否在同一行或同一列</span><br><span class="line">               return false;</span><br><span class="line">           else if (Math.abs(loc.x - each.x) == Math.abs(loc.y - each.y))  //判断是否在同斜线上</span><br><span class="line">               return false;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 打印皇后摆放方式</span><br><span class="line">    * @param list</span><br><span class="line">    */</span><br><span class="line">   private static void printLocation(LinkedList&lt;Location&gt; list) &#123;</span><br><span class="line">   String[][] show = new String[SIZE][SIZE];</span><br><span class="line">   for(int i = 0;i&lt;SIZE;i++) &#123;</span><br><span class="line">   for(int j = 0;j&lt;SIZE;j++) &#123;</span><br><span class="line">   show[i][j] = &quot;0&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   for(Location each : list)&#123;</span><br><span class="line">           System.out.print(each.toString() + &quot;\t&quot;);</span><br><span class="line">           show[each.x][each.y] = &quot;1&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println();</span><br><span class="line"></span><br><span class="line">       for(int i =0;i&lt;SIZE;i++) &#123;</span><br><span class="line">       for(int j=0;j&lt;SIZE;j++) &#123;</span><br><span class="line">       System.out.print(show[i][j] + &quot; &quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println();</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println();</span><br><span class="line"></span><br><span class="line">       count ++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-迷宫问题"><a href="#4-迷宫问题" class="headerlink" title="(4)迷宫问题"></a>(4)迷宫问题</h3><p><strong>题目描述：</strong>以一个M×N的长方阵表示迷宫，0和1分别表示迷宫中的通路和障碍。设计一个程序，对任意设定的迷宫，求出一条从入口到出口的通路，或得出没有通路的结论。<br> （1） 根据二维数组，输出迷宫的图形。<br> （2） 探索迷宫的四个方向：RIGHT为向右，DOWN向下，LEFT向左，UP向上，输出从入口到出口的行走路径。<br><strong>题解：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">class Position&#123;</span><br><span class="line">  public Position()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Position(int row, int col)&#123;</span><br><span class="line">    this.col = col;</span><br><span class="line">    this.row = row;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String toString()&#123;</span><br><span class="line">    return &quot;(&quot; + row + &quot; ,&quot; + col + &quot;)&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int row;</span><br><span class="line">  int col;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Maze&#123;</span><br><span class="line">  public Maze()&#123;</span><br><span class="line">    maze = new int[15][15];</span><br><span class="line">    stack = new Stack&lt;Position&gt;();</span><br><span class="line">    p = new boolean[15][15];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">   * 构造迷宫</span><br><span class="line">   */</span><br><span class="line">  public void init()&#123;</span><br><span class="line">    Scanner scanner = new Scanner(System.in);</span><br><span class="line">    System.out.println(&quot;请输入迷宫的行数&quot;);</span><br><span class="line">    row = scanner.nextInt();</span><br><span class="line">    System.out.println(&quot;请输入迷宫的列数&quot;);</span><br><span class="line">    col = scanner.nextInt();</span><br><span class="line">    System.out.println(&quot;请输入&quot; + row + &quot;行&quot; + col + &quot;列的迷宫&quot;);</span><br><span class="line">    int temp = 0;</span><br><span class="line">    for(int i = 0; i &lt; row; ++i) &#123;</span><br><span class="line">      for(int j = 0; j &lt; col; ++j) &#123;</span><br><span class="line">        temp = scanner.nextInt();</span><br><span class="line">        maze[i][j] = temp;</span><br><span class="line">        p[i][j] = false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">   * 回溯迷宫，查看是否有出路</span><br><span class="line">   */</span><br><span class="line">  public void findPath()&#123;</span><br><span class="line">    // 给原始迷宫的周围家一圈围墙</span><br><span class="line">    int temp[][] = new int[row + 2][col + 2];</span><br><span class="line">    for(int i = 0; i &lt; row + 2; ++i) &#123;</span><br><span class="line">      for(int j = 0; j &lt; col + 2; ++j) &#123;</span><br><span class="line">        temp[0][j] = 1;</span><br><span class="line">        temp[row + 1][j] = 1;</span><br><span class="line">        temp[i][0] = temp[i][col + 1] = 1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将原始迷宫复制到新的迷宫中</span><br><span class="line">    for(int i = 0; i &lt; row; ++i) &#123;</span><br><span class="line">      for(int j = 0; j &lt; col; ++j) &#123;</span><br><span class="line">        temp[i + 1][j + 1] = maze[i][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 从左上角开始按照顺时针开始查询</span><br><span class="line"></span><br><span class="line">    int i = 1;</span><br><span class="line">    int j = 1;</span><br><span class="line">    p[i][j] = true;</span><br><span class="line">    stack.push(new Position(i, j));</span><br><span class="line">    while (!stack.empty() &amp;&amp; (!(i == (row) &amp;&amp; (j == col)))) &#123;</span><br><span class="line"></span><br><span class="line">      if ((temp[i][j + 1] == 0) &amp;&amp; (p[i][j + 1] == false)) &#123;</span><br><span class="line">        p[i][j + 1] = true;</span><br><span class="line">        stack.push(new Position(i, j + 1));</span><br><span class="line">        j++;</span><br><span class="line">      &#125; else if ((temp[i + 1][j] == 0) &amp;&amp; (p[i + 1][j] == false)) &#123;</span><br><span class="line">        p[i + 1][j] = true;</span><br><span class="line">        stack.push(new Position(i + 1, j));</span><br><span class="line">        i++;</span><br><span class="line">      &#125; else if ((temp[i][j - 1] == 0) &amp;&amp; (p[i][j - 1] == false)) &#123;</span><br><span class="line">        p[i][j - 1] = true;</span><br><span class="line">        stack.push(new Position(i, j - 1));</span><br><span class="line">        j--;</span><br><span class="line">      &#125; else if ((temp[i - 1][j] == 0) &amp;&amp; (p[i - 1][j] == false)) &#123;</span><br><span class="line">        p[i - 1][j] = true;</span><br><span class="line">        stack.push(new Position(i - 1, j));</span><br><span class="line">        i--;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        if(stack.empty())&#123;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        i = stack.peek().row;</span><br><span class="line">        j = stack.peek().col;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Position&gt; newPos = new Stack&lt;Position&gt;();</span><br><span class="line">    if (stack.empty()) &#123;</span><br><span class="line">      System.out.println(&quot;没有路径&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      System.out.println(&quot;有路径&quot;);</span><br><span class="line">      System.out.println(&quot;路径如下：&quot;);</span><br><span class="line">      while (!stack.empty()) &#123;</span><br><span class="line">        Position pos = new Position();</span><br><span class="line">        pos = stack.pop();</span><br><span class="line">        newPos.push(pos);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 图形化输出路径</span><br><span class="line">     * */</span><br><span class="line"></span><br><span class="line">    String resault[][]=new String[row+1][col+1];</span><br><span class="line">    for(int k=0;k&lt;row;++k)&#123;</span><br><span class="line">      for(int t=0;t&lt;col;++t)&#123;</span><br><span class="line">        resault[k][t]=(maze[k][t])+&quot;&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (!newPos.empty()) &#123;</span><br><span class="line">      Position p1=newPos.pop();</span><br><span class="line">      resault[p1.row-1][p1.col-1]=&quot;#&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int k=0;k&lt;row;++k)&#123;</span><br><span class="line">      for(int t=0;t&lt;col;++t)&#123;</span><br><span class="line">        System.out.print(resault[k][t]+&quot;\t&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int maze[][];</span><br><span class="line">  private int row = 9;</span><br><span class="line">  private int col = 8;</span><br><span class="line">  Stack&lt;Position&gt; stack;</span><br><span class="line">  boolean p[][] = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class hello&#123;</span><br><span class="line">  public static void main(String[] args)&#123;</span><br><span class="line">    Maze demo = new Maze();</span><br><span class="line">    demo.init();</span><br><span class="line">    demo.findPath();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;N皇后的问题应该怎么解决？回溯法来帮忙！&lt;br&gt;&lt;img src=&quot;https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike72%2C5%2C5%2C72%2C24/sign=b8f564729c22720e6fc3eaa81aa26123/b2de9c82d158ccbfdd83742a1dd8bc3eb13541e7.jpg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="https://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="algorithms" scheme="https://yoursite.com/tags/algorithms/"/>
    
      <category term="coding" scheme="https://yoursite.com/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>Java的艺术-Java容器(2)之并发修改异常</title>
    <link href="https://yoursite.com/2019/01/06/Java%E7%9A%84%E8%89%BA%E6%9C%AF-Java%E5%AE%B9%E5%99%A8(2)%E4%B9%8B%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E5%BC%82%E5%B8%B8/"/>
    <id>https://yoursite.com/2019/01/06/Java的艺术-Java容器(2)之并发修改异常/</id>
    <published>2019-01-06T12:18:20.000Z</published>
    <updated>2019-03-12T07:39:23.615Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551345094255&amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;imgtype=0&amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png" alt="此处输入图片的描述"><br>ConcurrentModificationException（并发修改异常）为什么会出现？怎么解决呢？<br><a id="more"></a></p><h2 id="什么时候出现“并发修改异常”？"><a href="#什么时候出现“并发修改异常”？" class="headerlink" title="什么时候出现“并发修改异常”？"></a><strong>什么时候出现“并发修改异常”？</strong></h2><p>看下面这两段代码</p><blockquote><p>(1)增强for</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">res.add(<span class="string">"a"</span>);</span><br><span class="line">res.add(<span class="string">"b"</span>);</span><br><span class="line"><span class="keyword">for</span> (String s:res)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="string">"a"</span>)&#123;</span><br><span class="line">        res.add(<span class="string">"c"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>(2)迭代器</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">res.add(<span class="string">"a"</span>);</span><br><span class="line">res.add(<span class="string">"b"</span>);</span><br><span class="line">Iterator it = res.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    String s =(String) it.next();</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="string">"a"</span>)&#123;</span><br><span class="line">        res.add(<span class="string">"c"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码都会出现下面的异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.util.ConcurrentModificationException</span><br><span class="line">at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class="number">909</span>)</span><br><span class="line">at java.util.ArrayList$Itr.next(ArrayList.java:<span class="number">859</span>)</span><br><span class="line">at offer.Solution38.Permutation(Solution38.java:<span class="number">25</span>)</span><br><span class="line">at offer.Solution38.main(Solution38.java:<span class="number">35</span>)</span><br></pre></td></tr></table></figure><h2 id="为什么会出现“并发修改异常”？"><a href="#为什么会出现“并发修改异常”？" class="headerlink" title="为什么会出现“并发修改异常”？"></a><strong>为什么会出现“并发修改异常”？</strong></h2><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a><font color="red"><strong>源码分析</strong></font></h3><p>首先我们看ArrayList类的源码，其iterator()方法为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>返回一个新建的<strong>Itr</strong>对象，源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Itr() &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>是个没有内容内部类，我们只能看看ArrayList的父类AbstractList有没有对应的内容：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Index of element to be returned by subsequent call to next.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> cursor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Index of element returned by most recent call to next or</span></span><br><span class="line"><span class="comment">         * previous.  Reset to -1 if this element is deleted by a call</span></span><br><span class="line"><span class="comment">         * to remove.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The modCount value that the iterator believes that the backing</span></span><br><span class="line"><span class="comment">         * List should have.  If this expectation is violated, the iterator</span></span><br><span class="line"><span class="comment">         * has detected concurrent modification.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = cursor;</span><br><span class="line">                E next = get(i);</span><br><span class="line">                lastRet = i;</span><br><span class="line">                cursor = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                AbstractList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">                <span class="keyword">if</span> (lastRet &lt; cursor)</span><br><span class="line">                    cursor--;</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>是一个实现了<strong>Iterator</strong>接口的私有内部类。</p><p>分析它的<strong>hasNext()</strong>方法，会发现一个成员变量<strong>cursor</strong>。分析发现，这个变量表示下一个要访问元素的索引，当索引大于集合的<strong>size()</strong>后，则<strong>hasNext()=false</strong>。并且，<strong>next()</strong>方法返回的元素调用了<strong>get(cursor)</strong>,而get()方法在ArrayList中为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<strong>elementData</strong>就是用来存储ArrayList的Object数组。</p><blockquote><p>什么时候会出现ConcurrentModificationException呢？</p></blockquote><p>我们发现了Itr类的两个方法<strong>remove()和checkForComodification()</strong>会抛出这个异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            AbstractList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; cursor)</span><br><span class="line">                cursor--;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以及<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final void checkForComodification() &#123;</span><br><span class="line">            if (modCount != expectedModCount)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>我们观察上面抛出异常的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">res.add(&quot;a&quot;);</span><br><span class="line">res.add(&quot;b&quot;);</span><br><span class="line">Iterator it = res.iterator();</span><br><span class="line">while(it.hasNext())&#123;</span><br><span class="line">    String s =(String) it.next();</span><br><span class="line">    if(s == &quot;a&quot;)&#123;</span><br><span class="line">        res.add(&quot;c&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先在next()方法中会调用<strong>checkForComodification()</strong>方法，然后根据cursor的值获取到元素，接着将cursor的值赋给lastRet，并对cursor的值进行加1操作。初始时，cursor为0，lastRet为-1，那么调用一次之后，cursor的值为1，lastRet的值为0。注意此时，<strong>modCount为0，expectedModCount也为0</strong>。</p><p>随后，代码调用了res.add(“c”)。</p><p>查看源码，ArrayList的add()方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>再查看<strong>ensureCapacityInternal()</strong>的源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们发现了关键一行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modCount++;</span><br></pre></td></tr></table></figure><p>此时，<strong>modCount为1，expectedModCount为0</strong>。</p><p>在调用next()方法时，执行<strong>checkForComodification()</strong>显然就会抛出<strong>ConcurrentModificationException()</strong>！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>终于解决了这个疑惑！</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><blockquote><p>分析源码，在多线程程序中，如果有多个线程都在使用一个集合对象X，线程继续迭代，当A线程调用迭代器的next()方法时，发现modCount不等于expectedModCount，因此就抛出了ConcurrentModificationException异常。这可能就是它为什么叫并发修改异常的原因。<strong>从这一点也能说明ArrayList不是线程安全的。</strong></p></blockquote><blockquote><p>简单来说，调用list.remove(),list.add()方法导致modCount和expectedModCount的值不一致。使用for-each进行迭代实际上也会出现这种问题。</p></blockquote><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a><strong>解决办法</strong></h2><p>一般有2种解决办法：</p><blockquote><p>(1)不使用迭代器遍历集合,就可以在遍历的时候使用集合的方法进行增加或删除</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">res.add(<span class="string">"a"</span>);</span><br><span class="line">res.add(<span class="string">"b"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(res.get(i) == <span class="string">"a"</span>)</span><br><span class="line">        res.add(<span class="string">"c"</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><blockquote><p>(2)依然使用迭代器遍历,那么就需要使用Iterator的子接口ListIterator来实现向集合中添加</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ListIterator lit = res.listIterator();</span><br><span class="line"><span class="keyword">while</span>(lit.hasNext()) &#123;</span><br><span class="line">String s = (String)lit.next();</span><br><span class="line"><span class="keyword">if</span>(s.equals(<span class="string">"a"</span>)) &#123;</span><br><span class="line">lit.add(<span class="string">"c"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他解决同步问题的办法：</p><blockquote><p>(3)在使用iterator迭代的时候使用synchronized或者Lock进行同步；</p></blockquote><blockquote><p>(4)使用并发容器CopyOnWriteArrayList代替ArrayList和Vector。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1551345094255&amp;amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;amp;imgtype=0&amp;amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;ConcurrentModificationException（并发修改异常）为什么会出现？怎么解决呢？&lt;br&gt;
    
    </summary>
    
      <category term="Languages" scheme="https://yoursite.com/categories/Languages/"/>
    
    
      <category term="Java" scheme="https://yoursite.com/tags/Java/"/>
    
      <category term="容器" scheme="https://yoursite.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="源码" scheme="https://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Java的艺术-Java容器(1)之容器基础</title>
    <link href="https://yoursite.com/2019/01/05/Java%E7%9A%84%E8%89%BA%E6%9C%AF-Java%E5%AE%B9%E5%99%A8(1)%E4%B9%8B%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80/"/>
    <id>https://yoursite.com/2019/01/05/Java的艺术-Java容器(1)之容器基础/</id>
    <published>2019-01-05T11:48:20.000Z</published>
    <updated>2019-03-14T07:40:16.081Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551345094255&amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;imgtype=0&amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png" alt="此处输入图片的描述"><br>详解JAVA容器。<br><a id="more"></a></p><h2 id="Java容器是什么？"><a href="#Java容器是什么？" class="headerlink" title="Java容器是什么？"></a><font color="red"><strong>Java容器是什么？</strong></font></h2><blockquote><p><strong>容器</strong>，顾名思义，就是盛东西的地方。我们的程序中经常要管理大量的对象，比如在学校的信息管理系统里，每一个学生的相关信息，都可以抽象成一个对象；再比如在web server的场景下，一个客户端可以抽象成一个对象。这些情况下，都会产生很多同类型的对象，这时候，我们就会把同一个类型的对象放到同一个容器中进行集中管理。</p></blockquote><blockquote><p><strong>Java的容器</strong>是前人为我们设计好的一套存储对象和数据的一套轮子，<br>通过使用Java中写好的容器API我们可以很方便的存储、操作我们的数据。</p></blockquote><blockquote><p><strong>容器的作用：</strong><br>Java容器类库是用来保存对象的，他有两种不同的概念：（1）<strong>Collection</strong>，独立元素的序列，这些元素都服从一条或多条规则。List、Set以及Queue都是Collection的一种，List必须按照顺序保存元素，而Set不能有重复元素，Queue需要按照排队规则来确定对象的顺序。（2）<strong>Map</strong>，Map是键值对类型，允许用户通过键来查找对象。Hash表允许我们使用另一个对象来查找某个对象。</p></blockquote><blockquote><p>为什么需要容器呢？<br><strong>《thinking in java》</strong>书中说：“如果一个程序只包含固定数量的且生命周期都已知的对象，那么这是一个非常简单的数据。”但是事实上，我们平时接触的程序都不是如此简单的，很多程序都是在运行时才知道需要创建什么对象、创建多少对象，因此很可能我们需要在任意时刻任意位置创建任意数量的对象。因此，不能依靠创建命名的引用持有每一个对象，因为不确定性，我们必须要动态的创建对象，保存对象（其实是对象的引用）。</p></blockquote><h2 id="Java常见容器"><a href="#Java常见容器" class="headerlink" title="Java常见容器"></a><font color="red"><strong>Java常见容器</strong></font></h2><h3 id="Java完整容器类结构"><a href="#Java完整容器类结构" class="headerlink" title="Java完整容器类结构"></a>Java完整容器类结构</h3><p><img src="https://s2.ax1x.com/2019/03/07/kxN22n.md.jpg" alt="此处输入图片的描述"></p><h3 id="详细结构及概述"><a href="#详细结构及概述" class="headerlink" title="详细结构及概述"></a><strong>详细结构及概述</strong></h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a><strong>结构</strong></h4><p><strong>Collection</strong>接口<br>　├<strong>List</strong>接口<br>　　│├LinkedList 双向链表，顺序访问，快速增删，栈、队列、双向队列<br>　　│├ArrayList 顺序结构动态数组实现，随机访问<br>　　│└Vector 向量<br>　　　│└Stack 栈<br>　├<strong>Set</strong>接口<br>　　│├TreeSet 红黑树实现，有序，查找O(logN)<br>　　│├HashSet 哈希表实现，无序，查找O(1)<br>　　　│└LinkedHashSet<br>　├<strong>Queue</strong>接口<br>　　│├PriorityQueue 堆实现，可实现优先队列<br>　　│└LinkedList 双向链表，顺序访问，快速增删，栈、队列、双向队列<br><strong>Map</strong>接口<br>　├<strong>HashMap</strong> 哈希表实现，线程不安全<br>　　├Hashtable 线程安全，现为ConcurrentHashMap替换，分段锁<br>　├<strong>TreeMap</strong> 红黑树实现<br>　　├LinkedHashMap 双向链表实现<br>　　├WeakHashMap<br>　　└IdentityHashMap</p><h4 id="一句话概括常用不同容器类"><a href="#一句话概括常用不同容器类" class="headerlink" title="一句话概括常用不同容器类"></a><strong>一句话概括常用不同容器类</strong></h4><p>参考<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">Github</a></p><blockquote><p><strong>1.Set</strong><br>1.1 <strong>TreeSet</strong>：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。<br>1.2 <strong>HashSet</strong>：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。<br>1.3 <strong>LinkedHashSet</strong>：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</p></blockquote><blockquote><p><strong>2.List</strong><br>2.1 <strong>ArrayList</strong>：基于动态数组实现，支持随机访问。<br>2.2 <strong>Vector</strong>：和 ArrayList 类似，但它是线程安全的。<br>2.3 <strong>LinkedList</strong>：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间<br>插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</p></blockquote><blockquote><p><strong>3.Queue</strong><br>3.1 <strong>LinkedList</strong>：可以用它来实现双向队列。<br>3.2 <strong>PriorityQueue</strong>：基于堆结构实现，可以用它来实现优先队列。</p></blockquote><blockquote><p><strong>4.Map</strong><br>4.1 <strong>TreeMap</strong>：基于红黑树实现。<br>4.2 <strong>HashMap</strong>：基于哈希表实现。<br>4.3 <strong>HashTable</strong>：和 HashMap类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用ConcurrentHashMap 来支持线程安全，并且ConcurrentHashMap 的效率会更高，因为ConcurrentHashMap引入了分段锁。<br>4.4 <strong>LinkedHashMap</strong>：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（ LRU） 顺序。</p></blockquote><hr><blockquote><p><strong>接下来，详细比较不同容器的区别和联系！</strong></p></blockquote><h2 id="顶层接口-Collections接口"><a href="#顶层接口-Collections接口" class="headerlink" title="顶层接口-Collections接口"></a><font color="red"><strong>顶层接口-Collections接口</strong></font></h2><p>Collection是序列容器的顶级接口，这个interface定义了序列容器必须实现的所有成员方法。</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a><strong>常用方法</strong></h3><p>包括：容器容量，判断是否为空，检查容器元素，迭代器，增删等操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line">     <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">     Object[] toArray();</span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="List接口及常用实现类"><a href="#List接口及常用实现类" class="headerlink" title="List接口及常用实现类"></a><font color="red"><strong>List接口及常用实现类</strong></font></h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>实现List接口的常用类有LinkedList，ArrayList，Vector和Stack。</p></blockquote><blockquote><p>LinkedList、ArrayList都实现了List接口，都是不同步的，线程不安全，元素是有序的、可重复。</p></blockquote><blockquote><p>一般情况下使用LinkedList、ArrayList这两个就可以了，因为非同步，所以<strong>效率比较高</strong>。</p></blockquote><blockquote><p>ArrayList的随机访问效率较好，但是插入、删除元素较慢；LinkedList提供了优化的顺序访问，随机访问逊色于ArrayList，但插入、删除的代价较低。</p></blockquote><blockquote><p>总之，如果涉及到<strong>堆栈，队列</strong>等操作，应该考虑用List，对于需要<strong>快速插入，删除元素</strong>，应该使用LinkedList，如果需要<strong>快速随机</strong>访问元素，应该使用ArrayList。</p></blockquote><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a><strong>LinkedList</strong></h3><blockquote><p>基于双向链表的数据结构，允许null元素，增加、删除、修改元素方面效率比ArrayList高。</p></blockquote><blockquote><p>LinkedList提供额外的get，remove，insert方法在 LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。</p></blockquote><blockquote><p><strong>注意:LinkedList没有同步方法。</strong>如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：List list = Collections.synchronizedList(new LinkedList(…));</p></blockquote><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a><strong>ArrayList</strong></h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote><p>基于顺序结构的动态数组的数据结构，不同步，线程不安全，查询（get，set）效率高。</p></blockquote><blockquote><p>size()，isEmpty()，get()，set()方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。</p></blockquote><h4 id="Array和ArrayList的区别及各自适用的场景："><a href="#Array和ArrayList的区别及各自适用的场景：" class="headerlink" title="Array和ArrayList的区别及各自适用的场景："></a><strong>Array和ArrayList的区别及各自适用的场景：</strong></h4><blockquote><p>Array是数组，ArrayList是Array的加强版。</p></blockquote><blockquote><p>（1）array可以保存基本类型和对象类型，arrayList只能保存对象类型</p></blockquote><blockquote><p>（2）array数组的大小是固定的不能更改，而ArrayList的大小可以改变</p></blockquote><blockquote><p>（3）Array数组在存放的时候一定是同种类型的元素。ArrayList就不一定了，因为ArrayList可以存储Object。</p></blockquote><blockquote><p>（4）ArrayList有更加丰富的方法如addAll（）、removeAll()、iterator()</p></blockquote><blockquote><p><strong>适用场景：</strong><br>如果想要保存一些在整个程序运行期间都会存在而且不变的数据，我们可以将它们放进一个全局数组里，但是如果我们单纯只是想要以数组的形式保存数据，而不对数据进行增加等操作，只是方便我们进行查找的话，那么，我们就选择ArrayList。</p><p>如果我们需要对元素进行频繁的移动或删除，或者是处理的是超大量的数据，那么，使用ArrayList就真的不是一个好的选择，因为它的效率很低，使用数组进行这样的动作就很麻烦，那么，我们可以考虑选择LinkedList。</p></blockquote><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a><strong>Vector</strong></h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><blockquote><p>Vector类似ArrayList，但是Vector是<strong>线程同步</strong>的。由Vector创建的Iterator，虽然和ArrayList创建的 Iterator是同一接口，但是，因为Vector是同步的，当一个Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出ConcurrentModificationException，因此必须捕获该异常。</p></blockquote><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a><strong>Stack</strong></h3><blockquote><p>Stack继承自Vector，实现一个<strong>后进先出的堆栈</strong>。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop方法，还有 peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。</p></blockquote><hr><h2 id="Set接口及常用实现类"><a href="#Set接口及常用实现类" class="headerlink" title="Set接口及常用实现类"></a><font color="red"><strong>Set接口及常用实现类</strong></font></h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><blockquote><p>Set容器类主要有<strong>HashSet</strong>和<strong>TreeSet</strong>等。<br>元素不重复。</p></blockquote><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a><strong>HashSet</strong></h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><blockquote><p>允许包含值为null的元素，但最多只能有一个null元素。</p><p>基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</p></blockquote><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a><strong>TreeSet</strong></h3><blockquote><p>TreeSet基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</p></blockquote><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a><strong>LinkedHashSet</strong></h3><blockquote><p>LinkedHashSet的实现借助LinkedHashMap使用适配器模式实现的。具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</p></blockquote><hr><h2 id="Map接口及常用实现类"><a href="#Map接口及常用实现类" class="headerlink" title="Map接口及常用实现类"></a><font color="red"><strong>Map接口及常用实现类</strong></font></h2><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><blockquote><p>Map没有继承Collection接口，Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个value。Map接口提供3种集合的视图，Map的内容可以被当作一组key集合，一组value集合，或者一组key-value映射。</p></blockquote><blockquote><p>主要方法：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span><span class="comment">//比较对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span><span class="comment">//删除一个对象</span></span></span><br><span class="line"><span class="function"><span class="title">put</span><span class="params">(Object key,Object value)</span><span class="comment">//添加key和value</span></span></span><br></pre></td></tr></table></figure><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a><strong>TreeMap</strong></h3><h4 id="TreeMap-和-TreeSet"><a href="#TreeMap-和-TreeSet" class="headerlink" title="TreeMap 和 TreeSet"></a><strong>TreeMap 和 TreeSet</strong></h4><p>TreeSet是借助TreeMap实现的的适配器模式的体现。TreeMap懂了TreeSet也了解了，TreeMap实现了SortedMap接口，会根据key的大小对Map中的元素进行排序。key的大小判断在没有传入比较器Comparator的情况下通过自身的自然顺序比较。TreeMap底层通过红黑树实现</p><p><strong>红黑树</strong>是一颗近似平衡的二叉查找树，任何一个节点的左右子树高度差不会超过二者中较低的那个的一倍，TreeMap的每个节点即为一个键值对，红黑树的特性如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(1)每个节点要么是黑色，要么是红色</span><br><span class="line">(2)根节点必须为黑色</span><br><span class="line">(3)红色节点不能连续，即红色节点的孩子和父亲只能是黑色</span><br><span class="line">(4)任何节点到树的末端的任何路径包含的黑色节点个数相同</span><br><span class="line">(5)每次对红黑树操作后都要使其满足上述条件，调整红黑树的策略主要是：</span><br><span class="line"> - 改变节点颜色；</span><br><span class="line"> - 改变树的结构（左旋操作、右旋操作）</span><br></pre></td></tr></table></figure></p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a><strong>HashMap</strong></h3><h4 id="HashTable和HashMap"><a href="#HashTable和HashMap" class="headerlink" title="HashTable和HashMap"></a>HashTable和HashMap</h4><blockquote><p>第一、继承不同。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span> <span class="keyword">extends</span> <span class="title">Dictionary</span> <span class="keyword">implements</span> <span class="title">Map</span></span></span><br><span class="line"><span class="class">　　<span class="title">public</span> <span class="title">class</span> <span class="title">HashMap</span>  <span class="keyword">extends</span> <span class="title">AbstractMap</span> <span class="keyword">implements</span> <span class="title">Map</span></span></span><br></pre></td></tr></table></figure><blockquote><p>第二、Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。</p></blockquote><blockquote><p>第三、Hashtable中，key和value都不允许出现null值。在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。</p></blockquote><blockquote><p>第四、两个遍历方式的内部实现上不同。Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。</p></blockquote><blockquote><p>第五、哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。</p></blockquote><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a><strong>LinkedHashMap</strong></h3><p>LinkedHashMap实现了Map接口，即允许放入key为null的元素，也允许插入value为null的元素。从名字上可以看出该容器是linked list和HashMap的混合体，也就是说它同时满足HashMap和linked list的某些特性。可将LinkedHashMap看作采用LinkedList增强的HashMap。</p><h4 id="LinkedHashMap-和-LinkedHashSet"><a href="#LinkedHashMap-和-LinkedHashSet" class="headerlink" title="LinkedHashMap 和 LinkedHashSet:"></a><strong>LinkedHashMap 和 LinkedHashSet:</strong></h4><blockquote><p>LinkedHashSet和LinkedHashMap在Java里也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说LinkedHashSet里面有一个LinkedHashMap（适配器模式）。</p></blockquote><blockquote><p>LinkedHashMap是HashMap的子类，二者唯一的区别是LinkedHashMap在HashMap的基础上，采用双向链表（doubly-linkedlist）的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同。上图给出了LinkedHashMap的结构图，主体部分跟HashMap完全一样，多了header指向双向链表的头部（是一个哑元），该双向链表的迭代顺序就是entry的插入顺序。</p></blockquote><blockquote><p>LinkedHashMap在遍历的时候不同于HashMap需要先遍历整个table，LinkedHashMap只需要遍历header指向的双向链表即可，因此LinkedHashMap的迭代时间只和entry数量相关。其他的包括初始容量、负载因子以及hashCode、equals方法基本和HashMap一致。</p></blockquote><h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a><strong>WeakHashMap</strong></h3><blockquote><p>WeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。</p></blockquote><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a><strong>ConcurrentHashMap</strong></h3><p>HashMap不是线程安全的，HashTable是线程安全的，但是其安全性由全局锁保证，因此效率很低。而ConcurrentHashMap 是将锁的范围细化来实现高效并发的。 基本策略是将数据结构分为一个一个 Segment（每一个都是一个并发可读的 hash table， 即分段锁）作为一个并发单元。 为了减少开销， 除了一处 Segment 是在构造器初始化的， 其他都延迟初始化。 并使用 volatile 关键字来保证 Segment 延迟初始化的可见性问题。</p><blockquote><p>jdk1.8对ConcurrentHashMap做了一些改进：</p></blockquote><blockquote><p><strong>改进一</strong>：取消segments字段，直接采用transient volatile HashEntry&lt; K,V&gt;[] table保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。</p></blockquote><blockquote><p><strong>改进二</strong>：将原先table数组＋单向链表的数据结构，变更为table数组＋单向链表＋红黑树的结构。在冲突链表长度过长的情况，如果还是采用单向链表方式，那么查询某个节点的时间复杂度为O(n)；因此，对于个数超过8(默认值)的列表，jdk1.8中采用了红黑树的结构，那么查询的时间复杂度可以降低到O(logN)，可以改进性能。</p></blockquote><h2 id="容器的遍历"><a href="#容器的遍历" class="headerlink" title="容器的遍历"></a><font color="red"><strong>容器的遍历</strong></font></h2><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a><strong>迭代器模式</strong></h3><p>Collection 实现了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = container.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">　　Object obj = it.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="List遍历"><a href="#List遍历" class="headerlink" title="List遍历"></a><strong>List遍历</strong></h3><p>主要有三种：<br>第一种：迭代器+for<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator iterator = list.iterator();iterator.hasNext();)&#123;                    </span><br><span class="line">    <span class="keyword">int</span> i = (Integer) iterator.next();                   </span><br><span class="line">    System.out.println(i);               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二种：迭代器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    <span class="keyword">int</span> i = (Integer) iterator.next();<span class="comment">//注意next()返回的是Object对象！！</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第三种：增强for<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Object object : list) &#123;</span><br><span class="line">    System.out.println(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第四种：普通for<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;list.size();i++) &#123;  </span><br><span class="line">    <span class="keyword">int</span> j= (Integer) list.get(i);</span><br><span class="line">    System.out.println(j);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Map遍历"><a href="#Map遍历" class="headerlink" title="Map遍历"></a><strong>Map遍历</strong></h3><p><strong>有四种：</strong></p><p>第一种：通过获取所有的key按照key来遍历<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Set&lt;Integer&gt; set = map.keySet(); //得到所有key的集合</span></span><br><span class="line"><span class="keyword">for</span> (Integer in : map.keySet()) &#123;</span><br><span class="line">    String str = map.get(in);<span class="comment">//得到每个key多对用value的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二种：通过Map.entrySet使用iterator遍历key和value<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">     Map.Entry&lt;Integer, String&gt; entry = it.next();</span><br><span class="line">       System.out.println(<span class="string">"key= "</span> + entry.getKey() + <span class="string">" and value= "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意，用迭代器遍历Map时，Map没有iterator()方法，所以需要用entrySet()得到Set对象，再调用iterator()得到迭代器对象。</p></blockquote><p>第三种：通过Map.entrySet遍历key和value，<strong>推荐，尤其是容量大时</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="comment">//Map.entry&lt;Integer,String&gt; 映射项（键-值对）  有几个方法：用上面的名字entry</span></span><br><span class="line">    <span class="comment">//entry.getKey() ;entry.getValue(); entry.setValue();</span></span><br><span class="line">    <span class="comment">//map.entrySet()  返回此映射中包含的映射关系的 Set视图。</span></span><br><span class="line">    System.out.println(<span class="string">"key= "</span> + entry.getKey() + <span class="string">" and value= "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第四种：通过Map.values()遍历所有的value，但不能遍历key<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String v : map.values()) &#123;</span><br><span class="line">    System.out.println(<span class="string">"value= "</span> + v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong>参考：</strong><br><a href="https://blog.csdn.net/qq_37465368/article/details/80854672https://blog.csdn.net/qq_37465368/article/details/80854672" target="_blank" rel="noopener">Java常见的容器类及其区别</a><br><a href="https://blog.csdn.net/dandanzmc/article/details/23447827" target="_blank" rel="noopener">Java中的容器</a><br><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">一份涵盖大部分Java程序员所需要掌握的核心知识</a><br><a href="https://blog.csdn.net/starlh35/article/details/79262472" target="_blank" rel="noopener">深入整理java集合容器</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1551345094255&amp;amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;amp;imgtype=0&amp;amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;详解JAVA容器。&lt;br&gt;
    
    </summary>
    
      <category term="Languages" scheme="https://yoursite.com/categories/Languages/"/>
    
    
      <category term="Java" scheme="https://yoursite.com/tags/Java/"/>
    
      <category term="容器" scheme="https://yoursite.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>keras模型拼接</title>
    <link href="https://yoursite.com/2018/12/25/keras%E6%A8%A1%E5%9E%8B%E6%8B%BC%E6%8E%A5/"/>
    <id>https://yoursite.com/2018/12/25/keras模型拼接/</id>
    <published>2018-12-25T12:48:20.000Z</published>
    <updated>2019-03-05T07:22:22.896Z</updated>
    
    <content type="html"><![CDATA[<p><strong>在模型测试过程中，如何让两个模型中间层的输入输出拼在一起呢？</strong><br><img src="https://upgrad.com/blog/wp-content/uploads/2018/04/keras0.png" alt="此处输入图片的描述"></p><a id="more"></a><p>首先，加载训练好的模型后，我们可以用下面的方式获取模型的中间层输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = load_model(&quot;model1.h5&quot;)</span><br><span class="line">First_model = Model(inputs=model.input, outputs=model.layers[7].output)#表示获取模型第7层的输出</span><br></pre></td></tr></table></figure></p><p>然后如何把第7层的输出，作为下一个模型中间层的输入呢？用下面的方法是不可以的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model2 = load_model(&quot;model2.h5&quot;)</span><br><span class="line">second_model = Model(inputs=model2.layers[8].input, outputs=model2.layers[-1].output)</span><br></pre></td></tr></table></figure></p><p>这样会得到类似下面的错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RuntimeError: Graph disconnected: cannot obtain value for tensor Tensor(&quot;conv2d_1_input:0&quot;, shape=(?, 144, 144, 3), dtype=float32) at layer &quot;conv2d_1_input&quot;. The following previous layers were accessed without issue: []</span><br></pre></td></tr></table></figure></p><p>解决办法是声明一个新的Input Layer,用下面的方式拼接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">second_input = Input(model.layers[8].input_shape[1:])</span><br><span class="line">second_model = second_input</span><br><span class="line">for layer in model.layers[8:]:</span><br><span class="line">    second_model = layer(second_model)</span><br><span class="line">second_model = Model(inputs=second_input, outputs=second_model)</span><br></pre></td></tr></table></figure></p><p>由此，便完成了模型的拼接！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;在模型测试过程中，如何让两个模型中间层的输入输出拼在一起呢？&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://upgrad.com/blog/wp-content/uploads/2018/04/keras0.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="https://yoursite.com/categories/Machine-Learning/"/>
    
    
      <category term="python" scheme="https://yoursite.com/tags/python/"/>
    
      <category term="keras" scheme="https://yoursite.com/tags/keras/"/>
    
  </entry>
  
  <entry>
    <title>Java的艺术-Java技术栈</title>
    <link href="https://yoursite.com/2018/12/05/Java%E7%9A%84%E8%89%BA%E6%9C%AF-Java%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    <id>https://yoursite.com/2018/12/05/Java的艺术-Java技术栈/</id>
    <published>2018-12-05T13:48:20.000Z</published>
    <updated>2019-03-07T02:52:56.016Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551345094255&amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;imgtype=0&amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png" alt="此处输入图片的描述"><br>当学Java迷茫的时候，不妨看看，激励一下自己！<br><a id="more"></a></p><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a><font color="red">基础篇</font></h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p><strong>→ 什么是面向对象</strong><br>面向对象、面向过程<br>面向对象的三大基本特征和五大基本原则<br><strong>→ 平台无关性</strong><br>Java 如何实现的平台无关<br>JVM 还支持哪些语言（Kotlin、Groovy、JRuby、Jython、Scala）<br><strong>→ 值传递</strong><br>值传递、引用传递<br>为什么说 Java 中只有值传递<br><strong>→ 封装、继承、多态</strong><br>什么是多态、方法重写与重载<br>Java 的继承与实现<br>构造函数与默认构造函数<br>类变量、成员变量和局部变量<br>成员变量和方法作用域</p><h3 id="Java-基础知识"><a href="#Java-基础知识" class="headerlink" title="Java 基础知识"></a>Java 基础知识</h3><p><strong>→ 基本数据类型</strong><br>8 种基本数据类型：整型、浮点型、布尔型、字符型<br>整型中 byte、short、int、long 的取值范围<br>什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？<br><strong>→ 自动拆装箱</strong><br>什么是包装类型、什么是基本类型、什么是自动拆装箱<br>Integer 的缓存机制<br><strong>→ String</strong><br>字符串的不可变性<br>JDK 6 和 JDK 7 中 substring 的原理及区别、<br>replaceFirst、replaceAll、replace 区别、<br>String 对“+”的重载、字符串拼接的几种方式和区别<br>String.valueOf 和 Integer.toString 的区别、<br>switch 对 String 的支持<br>字符串池、常量池（运行时常量池、Class 常量池）、intern<br><strong>→ 熟悉 Java 中各种关键字</strong><br>transient、instanceof、final、static、volatile、synchronized、const 原理及用法<br><strong>→ 集合类</strong><br>常用集合类的使用、ArrayList 和 LinkedList 和 Vector 的区别 、SynchronizedList 和 Vector 的区别、HashMap、HashTable、ConcurrentHashMap 区别、<br>Set 和 List 区别？Set 如何保证元素不重复？<br>Java 8 中 stream 相关用法、apache 集合处理工具类的使用、不同版本的 JDK 中 HashMap 的实现的区别以及原因<br>Collection 和 Collections 区别<br>Arrays.asList 获得的 List 使用时需要注意什么<br>Enumeration 和 Iterator 区别<br>fail-fast 和 fail-safe<br>CopyOnWriteArrayList、ConcurrentSkipListMap<br><strong>→ 枚举</strong><br>枚举的用法、枚举的实现、枚举与单例、Enum 类<br>Java 枚举如何比较<br>switch 对枚举的支持<br>枚举的序列化如何实现<br>枚举的线程安全性问题<br><strong>→ IO</strong><br>字符流、字节流、输入流、输出流、<br>同步、异步、阻塞、非阻塞、Linux 5 种 IO 模型<br>BIO、NIO 和 AIO 的区别、三种 IO 的用法与原理、netty<br><strong>→ 反射</strong><br>反射与工厂模式、反射有什么用<br>Class 类、java.lang.reflect.*<br><strong>→ 动态代理</strong><br>静态代理、动态代理<br>动态代理和反射的关系<br>动态代理的几种实现方式<br>AOP<br><strong>→ 序列化</strong><br>什么是序列化与反序列化、为什么序列化、序列化底层原理、序列化与单例模式、protobuf、为什么说序列化并不安全</p><p><strong>→ 注解</strong><br>元注解、自定义注解、Java 中常用注解使用、注解与反射的结合<br>Spring 常用注解<br><strong>→ JMS</strong><br>什么是 Java 消息服务、JMS 消息传送模型<br><strong>→ JMX</strong><br>java.lang.management.<em>、 javax.management.</em><br><strong>→ 泛型</strong><br>泛型与继承、类型擦除、泛型中 KTVE? object 等的含义、泛型各种用法<br>限定通配符和非限定通配符、上下界限定符 extends 和 super<br>List<object> 和原始类型 List 之间的区别?<br>List&lt;?&gt; 和 List<object> 之间的区别是什么?<br><strong>→ 单元测试</strong><br>junit、mock、mockito、内存数据库（h2）<br><strong>→ 正则表达式</strong><br>java.lang.util.regex.<em><br><strong>→ 常用的 Java 工具库</strong><br>commons.lang、commons.</em>…、 guava-libraries、 netty<br><strong>→ API &amp; SPI</strong><br>API、API 和 SPI 的关系和区别<br>如何定义 SPI、SPI 的实现原理<br><strong>→ 异常</strong><br>异常类型、正确处理异常、自定义异常<br>Error 和 Exception<br>异常链、try-with-resources<br>finally 和 return 的执行顺序<br><strong>→ 时间处理</strong><br>时区、冬令时和夏令时、时间戳、Java 中时间 API<br>格林威治时间、CET,UTC,GMT,CST 几种常见时间的含义和关系<br>SimpleDateFormat 的线程安全性问题<br>Java 8 中的时间处理<br>如何在东八区的计算机上获取美国时间<br><strong>→ 编码方式</strong><br>Unicode、有了 Unicode 为啥还需要 UTF-8<br>GBK、GB2312、GB18030 之间的区别<br>UTF8、UTF16、UTF32 区别<br>URL 编解码、Big Endian 和 Little Endian<br>如何解决乱码问题<br><strong>→ 语法糖</strong><br>Java 中语法糖原理、解语法糖<br>语法糖：switch 支持 String 与枚举、泛型、自动装箱与拆箱、方法变长参数、枚举、内部类、条件编译、 断言、数值字面量、for-each、try-with-resource、Lambda 表达式</object></object></p><h3 id="阅读源代码"><a href="#阅读源代码" class="headerlink" title="阅读源代码"></a>阅读源代码</h3><p>String、Integer、Long、Enum、<br>BigDecimal、ThreadLocal、ClassLoader &amp; URLClassLoader、<br>ArrayList &amp; LinkedList、<br>HashMap &amp; LinkedHashMap &amp; TreeMap &amp; CouncurrentHashMap、HashSet &amp; LinkedHashSet &amp; TreeSet</p><h3 id="Java-并发编程"><a href="#Java-并发编程" class="headerlink" title="Java 并发编程"></a>Java 并发编程</h3><p><strong>→ 并发与并行</strong><br>什么是并发、什么是并行<br>并发与并行的区别<br><strong>→ 什么是线程，与进程的区别</strong><br>线程的实现、线程的状态、优先级、线程调度、创建线程的多种方式、守护线程<br>线程与进程的区别<br><strong>→ 线程池</strong><br>自己设计线程池、submit() 和 execute()、线程池原理<br>为什么不允许使用 Executors 创建线程池<br><strong>→ 线程安全</strong><br>死锁、死锁如何排查、线程安全和内存模型的关系<br><strong>→ 锁</strong><br>CAS、乐观锁与悲观锁、数据库相关锁机制、分布式锁、偏向锁、轻量级锁、重量级锁、monitor、<br>锁优化、锁消除、锁粗化、自旋锁、可重入锁、阻塞锁、死锁<br><strong>→ 死锁</strong><br>什么是死锁<br>死锁如何解决<br><strong>→ synchronized</strong><br>synchronized 是如何实现的？<br>synchronized 和 lock 之间关系、不使用 synchronized 如何实现一个线程安全的单例<br>synchronized 和原子性、可见性和有序性之间的关系<br><strong>→ volatile</strong><br>happens-before、内存屏障、编译器指令重排和 CPU 指令重<br>volatile 的实现原理<br>volatile 和原子性、可见性和有序性之间的关系<br>有了 symchronized 为什么还需要 volatile<br><strong>→ sleep 和 wait</strong><br><strong>→ wait 和 notify</strong><br><strong>→ notify 和 notifyAll</strong><br><strong>→ ThreadLocal</strong><br><strong>→ 写一个死锁的程序</strong><br><strong>→ 写代码来解决生产者消费者问题</strong><br><strong>→ 并方包</strong><br>Thread、Runnable、Callable、ReentrantLock、ReentrantReadWriteLock、Atomic*、Semaphore、CountDownLatch、ConcurrentHashMap、Executors</p><h2 id="底层篇"><a href="#底层篇" class="headerlink" title="底层篇"></a><font color="red">底层篇</font></h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p><strong>→ JVM 内存结构</strong><br>class 文件格式、运行时数据区：堆、栈、方法区、直接内存、运行时常量池、<br>堆和栈区别<br>Java 中的对象一定在堆上分配吗？</p><p><strong>→ Java 内存模型</strong><br>计算机内存模型、缓存一致性、MESI 协议<br>可见性、原子性、顺序性、happens-before、<br>内存屏障、synchronized、volatile、final、锁<br><strong>→ 垃圾回收</strong><br>GC 算法：标记清除、引用计数、复制、标记压缩、分代回收、增量式回收<br>GC 参数、对象存活的判定、垃圾收集器（CMS、G1、ZGC、Epsilon）<br><strong>→ JVM 参数及调优</strong><br>-Xmx、-Xmn、-Xms、Xss、-XX:SurvivorRatio、<br>-XX:PermSize、-XX:MaxPermSize、-XX:MaxTenuringThreshold<br><strong>→ Java 对象模型</strong><br>oop-klass、对象头<br><strong>→ HotSpot</strong><br>即时编译器、编译优化<br><strong>→ 虚拟机性能监控与故障处理工具</strong><br>jps, jstack, jmap, jstat, jconsole, jinfo, jhat, javap, btrace, TProfiler<br>Arthas</p><h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>classLoader、类加载过程、双亲委派（破坏双亲委派）、模块化（jboss modules、osgi、jigsaw）</p><h3 id="编译与反编译"><a href="#编译与反编译" class="headerlink" title="编译与反编译"></a>编译与反编译</h3><p>什么是编译（前端编译、后端编译）、什么是反编译<br>JIT、JIT 优化（逃逸分析、栈上分配、标量替换、锁优化）<br>编译工具：javac<br>反编译工具：javap 、jad 、CRF</p><h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a><font color="red">进阶篇</font></h2><h3 id="Java-底层知识"><a href="#Java-底层知识" class="headerlink" title="Java 底层知识"></a>Java 底层知识</h3><p><strong>→ 字节码、class 文件格式</strong><br><strong>→ CPU 缓存，L1，L2，L3 和伪共享</strong><br><strong>→ 尾递归</strong><br><strong>→ 位运算</strong><br>用位运算实现加、减、乘、除、取余</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>设计模式的六大原则：<br>开闭原则（Open Close Principle）、里氏代换原则（Liskov Substitution Principle）、依赖倒转原则（Dependence Inversion Principle）<br>接口隔离原则（Interface Segregation Principle）、迪米特法则（最少知道原则）（Demeter Principle）、合成复用原则（Composite Reuse Principle）<br><strong>→ 了解 23 种设计模式</strong><br>创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。<br>结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。<br>行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter 模式）、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。<br><strong>→ 会使用常用设计模式</strong><br>单例的七种写法：懒汉——线程不安全、懒汉——线程安全、饿汉、饿汉——变种、静态内部类、枚举、双重校验锁<br>工厂模式、适配器模式、策略模式、模板方法模式、观察者模式、外观模式、代理模式等必会<br><strong>→ 不用 synchronized 和 lock，实现线程安全的单例模式</strong><br><strong>→ 实现 AOP</strong><br><strong>→ 实现 IOC</strong><br><strong>→ nio 和 reactor 设计模式</strong></p><h3 id="网络编程知识"><a href="#网络编程知识" class="headerlink" title="网络编程知识"></a>网络编程知识</h3><p><strong>→ tcp、udp、http、https 等常用协议</strong><br>三次握手与四次关闭、流量控制和拥塞控制、OSI 七层模型、tcp 粘包与拆包<br><strong>→ http/1.0 http/1.1 http/2 之前的区别</strong><br>http 中 get 和 post 区别<br>常见的 web 请求返回的状态码<br>404、302、301、500分别代表什么<br><strong>→ http/3</strong><br><strong>→ Java RMI，Socket，HttpClient</strong><br><strong>→ cookie 与 session</strong><br>cookie 被禁用，如何实现 session<br><strong>→ 用 Java 写一个简单的静态文件的 HTTP 服务器</strong><br><strong>→ 了解 nginx 和 apache 服务器的特性并搭建一个对应的服务器</strong><br><strong>→ 用 Java 实现 FTP、SMTP 协议</strong><br><strong>→ 进程间通讯的方式</strong><br><strong>→ 什么是 CDN？如果实现？</strong><br><strong>→ DNS</strong><br>什么是 DNS 、记录类型: A 记录、CNAME 记录、AAAA 记录等<br>域名解析、根域名服务器<br>DNS 污染、DNS 劫持、公共 DNS：114 DNS、Google DNS、OpenDNS<br><strong>→ 反向代理</strong><br>正向代理、反向代理<br>反向代理服务器</p><h3 id="框架知识"><a href="#框架知识" class="headerlink" title="框架知识"></a>框架知识</h3><p><strong>→ Servlet</strong><br>生命周期<br>线程安全问题<br>filter 和 listener<br>web.xml 中常用配置及作用<br><strong>→ Hibernate</strong><br>什么是 OR Mapping<br>Hibernate 的懒加载<br>Hibernate 的缓存机制<br>Hibernate / Ibatis / MyBatis 之间的区别<br><strong>→ Spring</strong><br>Bean 的初始化<br>AOP 原理<br>实现 Spring 的IOC<br>Spring 四种依赖注入方式<br><strong>→ Spring MVC</strong><br>什么是 MVC<br>Spring mvc 与 Struts mvc 的区别<br><strong>→ Spring Boot</strong><br>Spring Boot 2.0、起步依赖、自动配置、<br>Spring Boot 的 starter 原理，自己实现一个 starter<br><strong>→ Spring Security</strong><br><strong>→ Spring Cloud</strong><br>服务发现与注册：Eureka、Zookeeper、Consul<br>负载均衡：Feign、Spring Cloud Loadbalance<br>服务配置：Spring Cloud Config<br>服务限流与熔断：Hystrix<br>服务链路追踪：Dapper<br>服务网关、安全、消息</p><h3 id="应用服务器知识"><a href="#应用服务器知识" class="headerlink" title="应用服务器知识"></a>应用服务器知识</h3><p><strong>→ JBoss<br>→ tomcat<br>→ jetty<br>→ Weblogic</strong></p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p><strong>→ git &amp; svn</strong><br><strong>→ maven &amp; gradle</strong><br><strong>→ Intellij IDEA</strong><br>常用插件：Maven Helper 、FindBugs-IDEA、阿里巴巴代码规约检测、GsonFormat<br>Lombok plugin、.ignore、Mybatis plugin</p><h2 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a><font color="red">高级篇</font></h2><h3 id="新技术"><a href="#新技术" class="headerlink" title="新技术"></a>新技术</h3><p><strong>→ Java 8</strong><br>lambda 表达式、Stream API、时间 API<br><strong>→ Java 9</strong><br>Jigsaw、Jshell、Reactive Streams<br><strong>→ Java 10</strong><br>局部变量类型推断、G1 的并行 Full GC、ThreadLocal 握手机制<br><strong>→ Java 11</strong><br>ZGC、Epsilon、增强 var<br><strong>→ Spring 5</strong><br>响应式编程<br><strong>→ Spring Boot 2.0</strong><br><strong>→ HTTP/2</strong><br><strong>→ HTTP/3</strong>    </p><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>使用单例、使用 Future 模式、使用线程池<br>选择就绪、减少上下文切换、减少锁粒度、数据压缩、结果缓存</p><h3 id="线上问题分析"><a href="#线上问题分析" class="headerlink" title="线上问题分析"></a>线上问题分析</h3><p><strong>→ dump 获取</strong><br>线程 Dump、内存 Dump、gc 情况<br><strong>→ dump 分析</strong><br>分析死锁、分析内存泄露<br><strong>→ dump 分析及获取工具</strong><br>jstack、jstat、jmap、jhat、Arthas<br><strong>→ 自己编写各种 outofmemory，stackoverflow 程序</strong><br>HeapOutOfMemory、 Young OutOfMemory、<br>MethodArea OutOfMemory、ConstantPool OutOfMemory、<br>DirectMemory OutOfMemory、Stack OutOfMemory Stack OverFlow<br><strong>→ Arthas</strong><br>jvm 相关、class/classloader 相关、monitor/watch/trace 相关、<br>options、管道、后台异步任务<br>文档：<a href="https://alibaba.github.io/arthas/advanced-use.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/advanced-use.html</a><br><strong>→ 常见问题解决思路</strong><br>内存溢出、线程死锁、类加载冲突<br><strong>→ 使用工具尝试解决以下问题，并写下总结</strong><br>当一个 Java 程序响应很慢时如何查找问题<br>当一个 Java 程序频繁 FullGC 时如何解决问题<br>如何查看垃圾回收日志<br>当一个 Java 应用发生 OutOfMemory 时该如何解决<br>如何判断是否出现死锁<br>如何判断是否存在内存泄露<br>使用 Arthas 快速排查 Spring Boot 应用404/401问题<br>使用 Arthas 排查线上应用日志打满问题<br>利用 Arthas 排查 Spring Boot 应用 NoSuchMethodError</p><h3 id="编译原理知识"><a href="#编译原理知识" class="headerlink" title="编译原理知识"></a>编译原理知识</h3><p><strong>→ 编译与反编译</strong><br><strong>→ Java 代码的编译与反编译</strong><br><strong>→ Java 的反编译工具</strong><br>javap 、jad 、CRF<br><strong>→ 即时编译器</strong><br><strong>→ 编译过程</strong><br>词法分析，语法分析（LL 算法，递归下降算法，LR 算法）<br>语义分析，运行时环境，中间代码，代码生成，代码优化</p><h3 id="操作系统知识"><a href="#操作系统知识" class="headerlink" title="操作系统知识"></a>操作系统知识</h3><p><strong>→ Linux 的常用命令<br>→ 进程间通信<br>→ 进程同步<br>生产者消费者问题、哲学家就餐问题、读者写者问题<br>→ 缓冲区溢出<br>→ 分段和分页<br>→ 虚拟内存与主存<br>→ 虚拟内存管理<br>→ 换页算法</strong></p><h3 id="数据库知识"><a href="#数据库知识" class="headerlink" title="数据库知识"></a>数据库知识</h3><p><strong>→ MySQL 执行引擎<br>→ MySQL 执行计划</strong><br>如何查看执行计划，如何根据执行计划进行 SQL 优化<br><strong>→ 索引</strong><br>Hash 索引、B 树索引（B+树、和B树、R树）<br>普通索引、唯一索引<br>覆盖索引、最左前缀原则、索引下推<br><strong>→ SQL 优化</strong><br><strong>→ 数据库事务和隔离级别</strong><br>事务的隔离级别、事务能不能实现锁的功能<br><strong>→ 数据库锁</strong><br>行锁、表锁、使用数据库锁实现乐观锁、<br><strong>→ 连接</strong><br>内连接，左连接，右连接<br><strong>→ 数据库主备搭建</strong><br><strong>→ binlog<br>→ redolog<br>→ 内存数据库</strong><br>h2<br><strong>→ 分库分表<br>→ 读写分离<br>→ 常用的 NoSql 数据库</strong><br>redis、memcached<br><strong>→ 分别使用数据库锁、NoSql 实现分布式锁<br>→ 性能调优<br>→ 数据库连接池</strong></p><h3 id="数据结构与算法知识"><a href="#数据结构与算法知识" class="headerlink" title="数据结构与算法知识"></a>数据结构与算法知识</h3><p><strong>→ 简单的数据结构</strong><br>栈、队列、链表、数组、哈希表、<br>栈和队列的相同和不同之处<br>栈通常采用的两种存储结构<br><strong>→ 树</strong><br>二叉树、字典树、平衡树、排序树、<br>B 树、B+ 树、R 树、多路树、红黑树<br><strong>→ 堆</strong><br>大根堆、小根堆<br><strong>→ 图</strong><br>有向图、无向图、拓扑<br><strong>→ 排序算法</strong><br>稳定的排序：冒泡排序、插入排序、鸡尾酒排序、桶排序、计数排序、归并排序、原地归并排序、二叉排序树排序、鸽巢排序、基数排序、侏儒排序、图书馆排序、块排序<br>不稳定的排序：选择排序、希尔排序、Clover 排序算法、梳排序、堆排序、平滑排序、快速排序、内省排序、耐心排序<br>各种排序算法和时间复杂度<br><strong>→ 两个栈实现队列，和两个队列实现栈<br>→ 深度优先和广度优先搜索<br>→ 全排列、贪心算法、KMP 算法、hash 算法<br>→ 海量数据处理</strong><br>分治，hash 映射，堆排序，双层桶划分，Bloom Filter，bitmap，数据库索引，mapreduce 等。</p><h3 id="大数据知识"><a href="#大数据知识" class="headerlink" title="大数据知识"></a>大数据知识</h3><p><strong>→ Zookeeper</strong><br>基本概念、常见用法<br><strong>→ Solr，Lucene，ElasticSearch</strong><br>在 linux 上部署 solr，solrcloud，新增、删除、查询索引<br><strong>→ Storm，流式计算，了解 Spark，S4</strong><br>在 linux 上部署 storm，用 zookeeper 做协调，运行 storm hello world，local 和 remote 模式运行调试 storm topology。<br><strong>→ Hadoop，离线计算</strong><br>HDFS、MapReduce<br><strong>→ 分布式日志收集 flume，kafka，logstash</strong><br><strong>→ 数据挖掘，mahout</strong></p><h3 id="网络安全知识"><a href="#网络安全知识" class="headerlink" title="网络安全知识"></a>网络安全知识</h3><p><strong>→ XSS</strong><br>XSS 的防御<br><strong>→ CSRF</strong><br><strong>→ 注入攻击</strong><br>SQL 注入、XML 注入、CRLF 注入<br><strong>→ 文件上传漏洞<br>→ 加密与解密</strong><br>对称加密、非对称加密、哈希算法、加盐哈希算法<br>MD5，SHA1、DES、AES、RSA、DSA<br>彩虹表<br><strong>→ DDOS攻击</strong><br>DOS 攻击、DDOS 攻击<br>memcached 为什么可以导致 DDos 攻击、什么是反射型 DDoS<br>如何通过 Hash 碰撞进行 DOS 攻击<br><strong>→ SSL、TLS，HTTPS<br>→ 用 openssl 签一个证书部署到 apache 或 nginx</strong></p><h2 id="架构篇"><a href="#架构篇" class="headerlink" title="架构篇"></a><font color="red">架构篇</font></h2><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>数据一致性、服务治理、服务降级<br><strong>→ 分布式事务</strong><br>2PC、3PC、CAP、BASE、 可靠消息最终一致性、最大努力通知、TCC<br><strong>→ Dubbo</strong><br>服务注册、服务发现，服务治理<br><a href="http://dubbo.apache.org/zh-cn/" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/</a><br><strong>→ 分布式数据库</strong><br>怎样打造一个分布式数据库、什么时候需要分布式数据库、<br>mycat、otter、HBase<br><strong>→ 分布式文件系统</strong><br>mfs、fastdfs<br><strong>→ 分布式缓存</strong><br>缓存一致性、缓存命中率、缓存冗余<br><strong>→ 限流降级</strong><br>Hystrix、Sentinal<br><strong>→ 算法</strong><br>共识算法、Raft 协议、Paxos 算法与 Raft 算法、<br>拜占庭问题与算法、2PC、3PC</p><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>SOA、康威定律<br><strong>→ ServiceMesh</strong><br>sidecar<br><strong>→ Docker &amp; Kubernets<br>→ Spring Boot<br>→ Spring Cloud</strong></p><h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><p><strong>→ 分库分表<br>→ CDN 技术<br>→ 消息队列</strong><br>ActiveMQ</p><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p><strong>→ 监控什么</strong><br>CPU、内存、磁盘 I/O、网络 I/O 等<br><strong>→ 监控手段</strong><br>进程监控、语义监控、机器资源监控、数据波动<br><strong>→ 监控数据采集</strong><br>日志、埋点<br><strong>→ Dapper</strong></p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>tomcat 负载均衡、Nginx 负载均衡<br>四层负载均衡、七层负载均衡</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS 原理、DNS 的设计</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>数据一致性</p><h2 id="扩展篇"><a href="#扩展篇" class="headerlink" title="扩展篇"></a><font color="red">扩展篇</font></h2><h3 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h3><p>IaaS、SaaS、PaaS、虚拟化技术、openstack、Serverlsess</p><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><p>Solr、Lucene、Nutch、Elasticsearch</p><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><p>Shiro</p><h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><p>哈希算法、Merkle 树、公钥密码算法、共识算法、<br>Raft 协议、Paxos 算法与 Raft 算法、拜占庭问题与算法、消息认证码与数字签名<br><strong>→ 比特币</strong><br>挖矿、共识机制、闪电网络、侧链、热点问题、分叉<br><strong>→ 以太坊<br>→ 超级账本</strong></p><h3 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h3><p>数学基础、机器学习、人工神经网络、深度学习、应用场景。<br><strong>→ 常用框架</strong><br>TensorFlow、DeepLearning4J</p><h3 id="loT"><a href="#loT" class="headerlink" title="loT"></a>loT</h3><h3 id="量子计算"><a href="#量子计算" class="headerlink" title="量子计算"></a>量子计算</h3><h3 id="AR-amp-VR"><a href="#AR-amp-VR" class="headerlink" title="AR &amp; VR"></a>AR &amp; VR</h3><h3 id="其他语言"><a href="#其他语言" class="headerlink" title="其他语言"></a>其他语言</h3><p>Groovy、Python、Go、NodeJs、Swift、Rust</p><h2 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a><font color="red">推荐书籍</font></h2><p>《深入理解 Java 虚拟机》<br>《Effective Java》<br>《深入分析 Java Web 技术内幕》<br>《大型网站技术架构》<br>《代码整洁之道》<br>《架构整洁之道》<br>《Head First 设计模式》<br>《maven 实战》<br>《区块链原理、设计与应用》<br>《Java 并发编程实战》<br>《鸟哥的 Linux 私房菜》<br>《从Paxos 到 Zookeeper》<br>《架构即未来》</p><p><strong><a href="https://mp.weixin.qq.com/s/zYJTLOpCkYuMR1HMCJOt-A" target="_blank" rel="noopener">转载自公众号：Hollis</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1551345094255&amp;amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;amp;imgtype=0&amp;amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;当学Java迷茫的时候，不妨看看，激励一下自己！&lt;br&gt;
    
    </summary>
    
      <category term="Languages" scheme="https://yoursite.com/categories/Languages/"/>
    
    
      <category term="Java" scheme="https://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="https://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java的艺术-类和接口的多继承</title>
    <link href="https://yoursite.com/2018/12/05/Java%E7%9A%84%E8%89%BA%E6%9C%AF-%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF/"/>
    <id>https://yoursite.com/2018/12/05/Java的艺术-类和接口的多继承/</id>
    <published>2018-12-05T10:48:20.000Z</published>
    <updated>2019-03-07T07:42:42.367Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551345094255&amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;imgtype=0&amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png" alt="此处输入图片的描述"><br>Java也有多继承？来看看JDK8的这个新特性！<br><a id="more"></a></p><h2 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a><font color="red"><strong>接口（Interface）</strong></font></h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。</p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><blockquote><p><strong>(JDK8以前)</strong>接口中可以含有 变量和方法。但是要注意，接口中的变量会被隐式地指定为<strong>public static final</strong>变量（并且只能是public static final变量，用private修饰会报编译错误），而方法会被隐式地指定为<strong>public abstract</strong>方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误）</p></blockquote><blockquote><p>并且<strong>接口中所有的方法不能有具体的实现</strong>，也就是说，<font color="red"><strong>接口中的方法必须都是抽象方法</strong></font>。从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。</p></blockquote><h3 id="Java8-新特性"><a href="#Java8-新特性" class="headerlink" title="Java8 新特性"></a>Java8 新特性</h3><blockquote><p><font color="red"><strong>但是，自从Java 8发布后，接口中也可以自定义方法了（default method）</strong></font>。这样如果为很多继承了同一个接口的类增加功能，不必对这些类重新设计。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface Test &#123;</span><br><span class="line">    //default关键字不能省略，否则提示Interface abstract methods cannot have body</span><br><span class="line">    default String test(String str)&#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">    //默认为public,abstract的</span><br><span class="line">    int test2();</span><br><span class="line">    //default关键字不能与abstact同时修饰接口方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同时，接口方法也可以被<strong>static</strong>修饰。</p></blockquote><blockquote><p>但是这也给Java带来了新问题——<font color="red"><strong>Java多继承的冲突</strong></font>。</p></blockquote><h3 id="接口中被default与static修饰的方法"><a href="#接口中被default与static修饰的方法" class="headerlink" title="接口中被default与static修饰的方法"></a>接口中被default与static修饰的方法</h3><ul><li><p>非default、static方法不能有实现，否则编译错误：Abstract methods do not specify a body</p></li><li><p>default、static方法必须有具体的实现，否则编译错误：This method requires a body instead of a semicolon</p></li><li><p>可以拥有多个default方法</p></li><li><p>可以拥有多个static方法</p></li><li><p>使用接口中类型时，仅仅需要实现抽象方法，default、static方法不需要强制自己新实现</p></li></ul><h2 id="Java多继承"><a href="#Java多继承" class="headerlink" title="Java多继承"></a><font color="red"><strong>Java多继承</strong></font></h2><h3 id="接口多继承冲突"><a href="#接口多继承冲突" class="headerlink" title="接口多继承冲突"></a>接口多继承冲突</h3><blockquote><p>比如有三个接口，Interface Test1,Interface Test2,Interface Test3。其中，Interface Test3继承自Test1和Test2。</p></blockquote><blockquote><p>如果Test1和Test2有相同签名的默认(default)方法，并且Test3没有override，则编译会出错。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Test1 &#123;</span><br><span class="line">     default String test(String str)&#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Test2 &#123;</span><br><span class="line">     default String test(String str)&#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface Test3 extends Test1,Test2 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multiextends.Test3 inherits unrelated defaults for test(String) from types multiextends.Test1 and multiextends.Test2</span><br></pre></td></tr></table></figure></p><p>需要在子接口中覆盖这个方法，让子类知道默认调用哪个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Test3 extends Test1,Test2 &#123;</span><br><span class="line">     default String test(String str)&#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意判断是否签名相同是根据传入的参数，而不是返回的参数。此时接口会根据传入的参数选择不同的default方法执行。</strong><br>比如下面的会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Test1 &#123;</span><br><span class="line"></span><br><span class="line">     default int test(String str)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Test2 &#123;</span><br><span class="line">//传入相同的String，返回不同的类型</span><br><span class="line">     default String test(String str)&#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//编译通过，不需要覆盖</span><br><span class="line">interface Test3 extends Test1,Test2 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是下面的编译通过：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Test1 &#123;</span><br><span class="line">     default String test(int a)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Test2 &#123;</span><br><span class="line">//传入不同类型的参数，返回相同的类型</span><br><span class="line">     default String test(String str)&#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//报错，需要覆盖</span><br><span class="line">//interface Test3 extends Test1,Test2 &#123;</span><br><span class="line">//&#125;</span><br></pre></td></tr></table></figure></p><h3 id="超类多继承冲突"><a href="#超类多继承冲突" class="headerlink" title="超类多继承冲突"></a>超类多继承冲突</h3><blockquote><p>如果比如有两个接口，Interface Test1,Interface Test2，一个超类Class Test3，一个子类Class Test4其中，Class Test4实现Interface Test1和Interface Test2，继承Class Test3。</p></blockquote><blockquote><p>如果方法有冲突会怎么样？<br>直接看代码：（注意注释中对静态方法和静态属性的 ）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">interface Test1 &#123;</span><br><span class="line">     default String test(int a)&#123;</span><br><span class="line">        return &quot;test&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Test2 &#123;</span><br><span class="line">//传入不同类型的参数，返回相同的类型</span><br><span class="line">     default String test(String str)&#123;</span><br><span class="line">        return &quot;test2&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Test3&#123;</span><br><span class="line">//如果public换成static会报错</span><br><span class="line">//但是如果只和一个Interface冲突，则可以用static修饰。</span><br><span class="line">//因为静态方法和属性可以被继承，但是不能被重写，而是被&quot;隐藏&quot;，直接通过父类名称调用。</span><br><span class="line">    public String test(String str)&#123;</span><br><span class="line">        return &quot;test3&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Test4 extends Test3 implements Test1,Test2&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test4 test = new Test4();</span><br><span class="line">        System.out.println(test.test(&quot;str&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//执行结果</span><br><span class="line">//test3</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><font color="red"><strong>总结</strong></font></h2><blockquote><p><strong>接口冲突：</strong>如果一个类同时实现了具有相同方法签名的接口，则该类必须覆盖该抽象方法。</p></blockquote><blockquote><p><strong>超类冲突</strong>：超类和接口提供相同方法签名的方法，此时子类要是不覆盖，则默认调用超类方法。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1551345094255&amp;amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;amp;imgtype=0&amp;amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;Java也有多继承？来看看JDK8的这个新特性！&lt;br&gt;
    
    </summary>
    
      <category term="Languages" scheme="https://yoursite.com/categories/Languages/"/>
    
    
      <category term="Java" scheme="https://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>搭建博客时候问题小记</title>
    <link href="https://yoursite.com/2018/12/01/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%97%B6%E5%80%99%E9%97%AE%E9%A2%98%E5%B0%8F%E8%AE%B0/"/>
    <id>https://yoursite.com/2018/12/01/搭建博客时候问题小记/</id>
    <published>2018-12-01T06:48:20.000Z</published>
    <updated>2019-03-06T11:39:24.864Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong>汇总搭建博客遇见的几个问题（持续更新。。。）<br><a id="more"></a></p><h2 id="nothing-added-to-commit-but-untracked-files-present"><a href="#nothing-added-to-commit-but-untracked-files-present" class="headerlink" title="nothing added to commit but untracked files present"></a>nothing added to commit but untracked files present</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;first commit&quot;</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">        .gitignore</span><br><span class="line">        _config.yml</span><br><span class="line">        git</span><br><span class="line">        git.pub</span><br><span class="line">        package-lock.json</span><br><span class="line">        package.json</span><br><span class="line">        scaffolds/</span><br><span class="line">        source/</span><br><span class="line">        themes/</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present</span><br></pre></td></tr></table></figure><p>这个错误原因有两个：</p><ol><li>已经存在的项目？</li><li>没有把需要提交的文件加载进来，所以需要用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add （文件名）</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="fatal-remote-origin-already-exists"><a href="#fatal-remote-origin-already-exists" class="headerlink" title="fatal: remote origin already exists."></a>fatal: remote origin already exists.</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: remote origin already exists.</span><br></pre></td></tr></table></figure><p>用到的解决办法：</p><ol><li><p>删除远程仓库，再添加远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$git remote rm origin</span><br><span class="line"></span><br><span class="line">$git remote add origin git@github.com:wufans/wufans.github.io.git</span><br></pre></td></tr></table></figure></li><li><p>修改git的config文件的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$vi .git/config</span><br></pre></td></tr></table></figure></li></ol><p>删除[remote “origin”]</p><hr><h2 id="github-rejected"><a href="#github-rejected" class="headerlink" title="github rejected"></a>github rejected</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">To github.com:wufans/wufans.github.io.git</span><br><span class="line"> ! [rejected]        master -&gt; master (non-fast-forward)</span><br><span class="line"> &apos;git@github.com:wufans/wufans.github.io.git&apos;</span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: &apos;git pull ...&apos;) before pushing again.</span><br></pre></td></tr></table></figure><p>这个方法就是因为本地仓库和github上面仓库的内容有冲突导致的<br>我用的解决办法是删除了原来的repository，重新建立了一个仓库，问题解决。</p><hr><h2 id="创建流量统计功能的方法"><a href="#创建流量统计功能的方法" class="headerlink" title="创建流量统计功能的方法"></a>创建流量统计功能的方法</h2><p><a href="https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="noopener">参考博客</a></p><hr><h2 id="附加功能的添加"><a href="#附加功能的添加" class="headerlink" title="附加功能的添加"></a>附加功能的添加</h2><p><a href="https://blog.csdn.net/linshuhe1/article/details/52424573" target="_blank" rel="noopener">参考博客</a></p><hr><h2 id="解决公式显示不正常的问题"><a href="#解决公式显示不正常的问题" class="headerlink" title="解决公式显示不正常的问题"></a>解决公式显示不正常的问题</h2><p><a href="https://blog.csdn.net/emptyset110/article/details/50123231" target="_blank" rel="noopener">参考博客</a></p><hr><h2 id="hexo设置侧边栏头像"><a href="#hexo设置侧边栏头像" class="headerlink" title="hexo设置侧边栏头像"></a>hexo设置侧边栏头像</h2><p>编辑站点的 _config.yml，新增字段 avatar， 值设置成头像的链接地址。</p><p>其中，头像的链接地址可以是：</p><p>完整的互联网 URL，例如：<a href="https://avatars1.githubusercontent.com/u/32269?v=3&amp;s=460" target="_blank" rel="noopener">https://avatars1.githubusercontent.com/u/32269?v=3&amp;s=460</a></p><p>站点内的地址，例如：</p><p>/uploads/avatar.jpg 需要将你的头像图片放置在 站点的 source/uploads/（可能需要新建uploads目录）<br>/images/avatar.jpg 需要将你的头像图片放置在 主题的 source/images/ 目录下。</p><hr><h2 id="hexo部署失败，不能连接github的解决"><a href="#hexo部署失败，不能连接github的解决" class="headerlink" title="hexo部署失败，不能连接github的解决"></a>hexo部署失败，不能连接github的解决</h2><p>一直在解决这个问题，修改了本地文件的几个配置之后，突然发现生成的博客不能直接push到github上了，显示错误<br><img src="https://s1.ax1x.com/2018/12/27/F2IkYd.jpg" alt="此处输入图片的描述"><br>但是用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure></p><p>部署到本地的时候是没有问题的。<br>然后用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@gihub.com</span><br></pre></td></tr></table></figure></p><p>测试连接也出现了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh_exchange_identification: read:Connection reset by peer</span><br></pre></td></tr></table></figure></p><p>和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection reset by 192.30.253.112 port 22</span><br></pre></td></tr></table></figure></p><p>这样的错误<br>尝试了以下解决办法：</p><ol><li>因为前几次修改了hosts文件解决github不能加载CSS的问题，让电脑解析github的域名时用的是自定义的IP，所以可能有这个原因，因此在hosts里面注释掉了修改的部分，然后刷新DNS缓存<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /flushdns</span><br><span class="line">#这里还遇到了ipconfig和ping不是一个命令的错误，需要配置环境变量path</span><br><span class="line">#%SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem</span><br></pre></td></tr></table></figure></li></ol><p>最后发现没用。</p><ol><li>删除了github上面的ssh配置，重新配置了github服务器端与本地的ssh秘钥，然后再使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@gihub.com</span><br></pre></td></tr></table></figure></li></ol><p>结果能连上了，但是再用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p><p>之后，又报了刚才的错误，而且再测试与github上面的连接居然也出错了~</p><ol><li>俗话说，重启治百病，于是重启了一下————是的，没用</li><li>用网上的解决办法，可能是网络防火墙设置的原因，用手机给电脑开热点再测试连接，结果也没用<br>最后打算第二天重新部署博客了，然后奇迹发生了，起床之后再测试链接，work~</li></ol><hr><h2 id="Github不能访问、不能正常加载CSS的解决"><a href="#Github不能访问、不能正常加载CSS的解决" class="headerlink" title="Github不能访问、不能正常加载CSS的解决"></a>Github不能访问、不能正常加载CSS的解决</h2><p>修改了windows的hosts文件之后，经常会出现github访问异常，页面的CSS样式无法加载等的情况。<br><strong>解决办法</strong><br>给hosts文件增加github的CDN fastly.net,跳过域名解析，直接通过IP访问github。<br>在hosts文件下增加一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">185.31.17.184 github.global.ssl.fastly.net</span><br></pre></td></tr></table></figure></p><font color="red"><strong>问题</strong></font><p>使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p><p>部署博客时，出现下列错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fatal: TaskCanceledException encountered.</span><br><span class="line">   ▒▒ȡ▒▒һ▒▒▒▒▒▒</span><br><span class="line">bash: /dev/tty: No such device or address</span><br><span class="line">error: failed to execute prompt script (exit code 1)</span><br><span class="line">fatal: could not read Username for &apos;https://github.com&apos;: No error</span><br><span class="line">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="line">Error: fatal: TaskCanceledException encountered.</span><br><span class="line">   ��ȡ��һ������</span><br><span class="line">bash: /dev/tty: No such device or address</span><br><span class="line">error: failed to execute prompt script (exit code 1)</span><br><span class="line">fatal: could not read Username for &apos;https://github.com&apos;: No error</span><br><span class="line"></span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (D:\blog\GIT\hexo\node_modules\hexo-util\lib\spawn.js:37:17)</span><br><span class="line">    at emitTwo (events.js:125:13)</span><br><span class="line">    at ChildProcess.emit (events.js:213:7)</span><br><span class="line">    at ChildProcess.cp.emit (D:\blog\GIT\hexo\node_modules\cross-spawn\lib\enoent.js:40:29)</span><br><span class="line">    at maybeClose (internal/child_process.js:927:16)</span><br><span class="line">    at Process.ChildProcess._handle.onexit (internal/child_process.js:211:5)</span><br></pre></td></tr></table></figure></p><font color="red"><strong>解决</strong></font><p>如果开启了本地预览，先关闭<br>然后用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure></p><p>清空缓存，再重新生成静态文件并部署，问题解决~</p><p><font color="red">另外</font><br>用了上面的方法之后还出现了这个问题的话，<big><font color="red">重启</font></big>一下电脑~~</p><h2 id="添加版权声明"><a href="#添加版权声明" class="headerlink" title="添加版权声明"></a>添加版权声明</h2><p>添加版权声明</p><p>在Github上，Next主题的issues上有设置 Creative Commons 协议，这个就是设置版权声明，但是配置了以后图标比较小，没有文字说明（就是没逼格），而且还会出现在它不该出现的地方。</p><h3 id="新建-passage-end-tag-swig-文件"><a href="#新建-passage-end-tag-swig-文件" class="headerlink" title="新建 passage-end-tag.swig 文件"></a>新建 passage-end-tag.swig 文件</h3><p>在路径\themes\next\layout_macro中添加passage-end-tag.swig文件，其内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.passage_end_tag.enabled %&#125;</span><br><span class="line">&lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;</span><br><span class="line">------ 本文结束 ------&lt;/div&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;div style=&quot;border: 1px solid black&quot;&gt;</span><br><span class="line">&lt;div style=&quot;margin-left:10px&quot;&gt;</span><br><span class="line">&lt;span style=&quot;font-weight:blod&quot;&gt;版权声明&lt;/span&gt;</span><br><span class="line">&lt;img src=&quot;http://creativecommons.org/images/deed/logo_deed.gif&quot;&gt;&lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;Fan Wu&apos;s Blog&lt;/a&gt; by &lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;Fan Wu&lt;/a&gt; is licensed under a &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; style=&quot;color:#258FC6&quot;&gt;Creative Commons BY-NC-ND 4.0 International License&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">由&lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;Fan Wu&lt;/a&gt;创作并维护的&lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;Fan Wu&apos;s Blog&lt;/a&gt;博客采用&lt;a href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; style=&quot;color:#258FC6&quot;&gt;创作共用保留署名-非商业-禁止演绎4.0国际许可证&lt;/a&gt;。&lt;br/&gt;</span><br><span class="line">本文首发于&lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;Fan Wu&apos;s Blog&lt;/a&gt; 博客（ &lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;http://wufan.site/&lt;/a&gt; ），版权所有，侵权必究。&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>如果觉得上面的样式不好看，也可以引用下面的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.passage_end_tag.enabled %&#125;</span><br><span class="line">&lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;</span><br><span class="line">-------------本文结束&lt;i class=&quot;fa fa-heart&quot;&gt;&lt;/i&gt;感谢阅读-------------&lt;/div&gt;</span><br><span class="line">&lt;ul class=&quot;post-copyright&quot;&gt;</span><br><span class="line">  &lt;li class=&quot;post-copyright-author&quot;&gt;</span><br><span class="line">      &lt;strong&gt;本文作者:&lt;/strong&gt;&#123;&#123; theme.author &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">  &lt;li class=&quot;post-copyright-link&quot;&gt;</span><br><span class="line">    &lt;strong&gt;本文链接:&lt;/strong&gt;</span><br><span class="line">    &lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.path &#125;&#125;&lt;/a&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">  &lt;li class=&quot;post-copyright-license&quot;&gt;</span><br><span class="line">    &lt;strong&gt;许可协议:&lt;/strong&gt;</span><br><span class="line">    除特殊声明外，本站博文均采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-sa/3.0/cn/&quot; rel=&quot;external nofollow&quot; target=&quot;_blank&quot;&gt;CC BY-NC-SA 4.0 CN&lt;/a&gt; 许可协议，转载请注明出处！</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><h3 id="修改-post-swig-文件"><a href="#修改-post-swig-文件" class="headerlink" title="修改 post.swig 文件"></a>修改 post.swig 文件</h3><p>在\themes\next\layout_macro\post.swig中，post-body之后，post-footer之前添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% if not is_index %&#125;</span><br><span class="line">    &#123;% include &apos;passage-end-tag.swig&apos; %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h3 id="在主题配置文件中添加字段"><a href="#在主题配置文件中添加字段" class="headerlink" title="在主题配置文件中添加字段"></a>在主题配置文件中添加字段</h3><p>在主题配置文件”_config.yml”中添加以下字段开启此功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#文章末尾添加“本文结束”标记</span><br><span class="line">passage_end_tag:</span><br><span class="line">  enabled: true</span><br></pre></td></tr></table></figure><p>完成以上设置之后，在每篇文章之后都会添加“版权声明”标记。</p><h2 id="添加动画效果"><a href="#添加动画效果" class="headerlink" title="添加动画效果"></a>添加动画效果</h2><p>背景动画基于canvas，添加到博客上也比较简单，在\themes\next\layout_layout.swig的上面添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.canvas_nest %&#125;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>在\themes\next_config.yml中添加以下字段开启此功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># background settings</span><br><span class="line"># add canvas-nest effect</span><br><span class="line"># see detail from https://github.com/hustcc/canvas-nest.js</span><br><span class="line">canvas_nest: true</span><br></pre></td></tr></table></figure></p><p>添加完了，发现博客背景是白色，会遮住动画，只留下两边一点点的位置看到动画效果，这时候可以去设置一下背景颜色，在\themes\next\source\css_schemes\Pisces_layout.styl中，把.content-wrap中的background修改为none。</p><p>这时候如果用手机打开，也能看到动画效果，但是带来的体验不好，显得页面比较乱，这是可以把.content-wrap的+mobile()中的background修改为white，这样手机端的体验就好很多，却又不影响电脑端的炫酷动画。</p><h2 id="解决博客浏览统计功能突然失效的方法（hexo-theme-next-busuanzi-count）"><a href="#解决博客浏览统计功能突然失效的方法（hexo-theme-next-busuanzi-count）" class="headerlink" title="解决博客浏览统计功能突然失效的方法（hexo-theme-next-busuanzi_count）"></a>解决博客浏览统计功能突然失效的方法（hexo-theme-next-busuanzi_count）</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>我这里是使用的hexo-theme-next主题，主题版本为：3.8.0(更新于10-31日)</p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>由于定位到是不蒜子统计功能突然有问题了，所以前往不蒜子官网进行查看，发现官网有一段很重要的提示：<br><strong>“因七牛强制过期『dn-lbstatics.qbox.me』域名，与客服沟通无果，只能更换域名到『busuanzi.ibruce.info』！”</strong><br>所以定位到问题，原来是不蒜子使用的七牛的域名被强制过期。<br>需要把 dn-lbstatics.qbox.me 域名更换为 busuanzi.ibruce.info</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>hexo-theme-next主题中使用了dn-lbstatics.qbox.me域名的文件位置为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">themes\next\layout\_third-party\analytics\busuanzi-counter.swig</span><br></pre></td></tr></table></figure><p>修改busuanzi-counter.swig</p><p>找到如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>重新预览，即可看到不蒜子统计功能已经生效<br><a href="https://blog.csdn.net/qijian2003122/article/details/82987577" target="_blank" rel="noopener">原文</a></p><h2 id="恢复你的博客，只需要三步"><a href="#恢复你的博客，只需要三步" class="headerlink" title="恢复你的博客，只需要三步"></a>恢复你的博客，只需要三步</h2><p><strong>如果你重装了系统或者更换了新电脑/新平台，怎么才能快速恢复原来的博客呢？</strong><br>如果你保留了原来博客文件夹下所有文件，那么恢复博客只需要三步：</p><h3 id="安装必备组件"><a href="#安装必备组件" class="headerlink" title="安装必备组件"></a>安装必备组件</h3><p>包括：安装Git，安装Node.js</p><h3 id="Github配对"><a href="#Github配对" class="headerlink" title="Github配对"></a>Github配对</h3><p>打开git bash，在用户主目录下运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure></p><p>把其中的邮件地址换成自己的邮件地址，然后一路回车,在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥<br>登陆GitHub，打开「Settings」-&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容），最后点击「Add SSH Key」<br>测试是否配对成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>打开git bash客户端，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure></p><p>，开始安装hexo<br>安装成功后，进入你原来的博客目录，就可以用hexo命令进行博客生成和部署啦~</p><h2 id="给博客自定义域名开启Https"><a href="#给博客自定义域名开启Https" class="headerlink" title="给博客自定义域名开启Https"></a>给博客自定义域名开启Https</h2><p><strong>HTTPS</strong>（全称：Hyper Text Transfer Protocol over Secure Socket Layer 或 Hypertext Transfer Protocol Secure，超文本传输安全协议），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。<br>GitHub官方在5月1号宣布，GitHub Pages的自定义域名获得对HTTPS的支持。但是因为自己的域名是自定义的，购于阿里云，因此不能直接在Setting中设置Enforce HTTPS:<br><img src="https://s1.ax1x.com/2018/12/26/F2rlvj.png" alt="此处输入图片的描述"><br>而Github pages不支持SSL证书上传，因此，开启HTTPS需要借助CloudFlare的CDN代理。即用户到CDN服务器的连接为https，而CDN服务器到GithubPage服务器的连接为http，就是在CDN服务器那里加上反向代理。<br><strong>步骤如下：</strong></p><ol><li>首先注册并登陆CloudFlare,在域名购买的地方修改name sever，修改DNS解析地址。（启用动态DNS加速）<br><img src="https://s1.ax1x.com/2018/12/26/F2r3Ks.png" alt="此处输入图片的描述"></li><li>与域名绑定并激活成功后，设置CloudFlare 的 DNS：<br><img src="https://s1.ax1x.com/2018/12/26/F2rdGF.png" alt="此处输入图片的描述"></li><li>设置CloudFlare 的 Crypto：<br><img src="https://s1.ax1x.com/2018/12/26/F2rDM9.png" alt="此处输入图片的描述"></li><li>设置路由规则Page Rules：<br><img src="https://s1.ax1x.com/2018/12/26/F2rsq1.png" alt="此处输入图片的描述"><br>至此，等待一段时间，就可以用https协议访问你的自定义域名<br>为了让博客完全开启Https，还需要修改文章内容中用http协议的链接，比如图片，这样，就能看到浏览器域名旁边的小绿锁啦！<br><img src="https://s1.ax1x.com/2018/12/27/F255Q0.png" alt="此处输入图片的描述"><br>同时，修改了DNS解析服务器后，网站响应速度也更快了！一举两得！</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;汇总搭建博客遇见的几个问题（持续更新。。。）&lt;br&gt;
    
    </summary>
    
      <category term="Guidances" scheme="https://yoursite.com/categories/Guidances/"/>
    
    
      <category term="hexo" scheme="https://yoursite.com/tags/hexo/"/>
    
      <category term="blog" scheme="https://yoursite.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Java的艺术-注解类型(Annotation)</title>
    <link href="https://yoursite.com/2018/11/28/Java%E7%9A%84%E8%89%BA%E6%9C%AF-%E6%B3%A8%E8%A7%A3%E7%B1%BB%E5%9E%8B(Annotation)/"/>
    <id>https://yoursite.com/2018/11/28/Java的艺术-注解类型(Annotation)/</id>
    <published>2018-11-28T03:08:02.000Z</published>
    <updated>2019-03-12T07:41:08.792Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551345094255&amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;imgtype=0&amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png" alt="此处输入图片的描述"><br>使用注解来进行开发，可以免去写XML配置。那么注解到底是什么呢？</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a><font color="red"><strong>概念</strong></font></h2><p><strong>注解（Annotation）</strong></p><blockquote><p>也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。<br>这些标记和注释可以在编译、类加载、运行时被读取，并执行响应的处理。<br><strong>通俗地讲，注解相当于给类、属性或者方法贴上一个标签。</strong></p></blockquote><p><strong>注解的元注解</strong></p><blockquote><p>元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。<br>元注解有五种：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>、<span class="meta">@Documented</span>、<span class="meta">@Target</span>、<span class="meta">@Inherited</span>、<span class="meta">@Repeatable</span></span><br></pre></td></tr></table></figure></p></blockquote><h2 id="注解的基本用法"><a href="#注解的基本用法" class="headerlink" title="注解的基本用法"></a><font color="red"><strong>注解的基本用法</strong></font></h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>注解通过@interface 关键字定义。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个名为AnnotationTest的注解。</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationTest&#123;&#125;</span><br></pre></td></tr></table></figure></p><h3 id="注解的属性"><a href="#注解的属性" class="headerlink" title="注解的属性"></a>注解的属性</h3><p>注解的属性类似于类的成员变量。并且注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“<strong>无形参的方法</strong>”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。<br>可以通过<font color="red"><strong>default</strong></font>关键字给出默认值。<br>举例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationTest&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "Hello World"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在使用的时候，赋值的方式是在注解的括号内以 <font color="red"><strong>value=””</strong></font>形式，多个属性之间用<font color="red"><strong>“,”</strong></font>隔开。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AnnotationTest</span>(id=<span class="number">0</span>,message=<span class="string">"God"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为属性message有默认值，也可以不赋值</span></span><br><span class="line"><span class="meta">@AnnotationTest</span>(id=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当所有属性都有默认值，括号内为空</span></span><br></pre></td></tr></table></figure></p><p>甚至当注解没有属性时，可以不用括号：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Check &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有属性的注解，不用括号</span></span><br><span class="line"><span class="meta">@Check</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h3><blockquote><p>注解中所有方法（也就是属性）没有方法体，且只允许public和abstract修饰。缺省默认为public，且注解方法不允许有throws子句。</p></blockquote><blockquote><p>注解中方法的返回值只能为：基本数据类型，String，Class，美剧类型，注解和他们的一维数组。</p></blockquote><blockquote><p>注解的继承只能作用在类上，方法上的注解不会被继承，Interface中的所有注解不会被继承。</p></blockquote><h2 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a><font color="red"><strong>常见注解</strong></font></h2><h3 id="五种元注解"><a href="#五种元注解" class="headerlink" title="五种元注解"></a>五种元注解</h3><p>前面我们提到，Java中有五种元注解。</p><ul><li><p><strong>@Retention</strong></p><blockquote><p>解释说明一个注解的存活时间。取值如下：</p></blockquote><ul><li><strong>RetentionPolicy.SOURCE</strong>        注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。</li><li><strong>RetentionPolicy.CLASS</strong> 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。</li><li><strong>RetentionPolicy.RUNTIME</strong> 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationTest &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>@Documented</strong></p></li></ul><blockquote><p>能够将注解中的元素包含到 Javadoc 中去。</p></blockquote><ul><li><p><strong>@Target</strong></p><blockquote><p>限定注解运用的场景。取值如下：</p></blockquote><ul><li><strong>ElementType.ANNOTATION_TYPE</strong> 可以给一个注解进行注解</li><li><strong>ElementType.CONSTRUCTOR</strong> 可以给构造方法进行注解</li><li><strong>ElementType.FIELD</strong> 可以给属性进行注解</li><li><strong>ElementType.LOCAL_VARIABLE</strong> 可以给局部变量进行注解</li><li><strong>ElementType.METHOD</strong> 可以给方法进行注解</li><li><strong>ElementType.PACKAGE</strong> 可以给一个包进行注解</li><li><strong>ElementType.PARAMETER</strong> 可以给一个方法内的参数进行注解</li><li><strong>ElementType.TYPE</strong> 可以给一个类型进行注解，比如类、接口、枚举</li></ul></li><li><p><strong>@Inherited</strong></p><blockquote><p>如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> Test &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为Test注解被@Inherited注解，所以继承了注解了Test的A类后的B类，也拥有Test这个注解。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>@Repeatable</strong></p><blockquote><p>Repeatable 是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> Persons &#123;</span><br><span class="line">Person[]  value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repeatable</span>(Persons.class)</span><br><span class="line"><span class="meta">@interface</span> Person&#123;</span><br><span class="line">String role <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"artist"</span>)</span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"coder"</span>)</span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"PM"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>@Repeatable 注解了 Person。而 @Repeatable 后面括号中的类相当于一个容器注解。</p><p>什么是<strong>容器注解</strong>呢？就是用来存放其它注解的地方。它本身也是一个注解。</p><p>我们再看看代码中的相关容器注解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> Persons &#123;</span><br><span class="line">Person[]  value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>按照规定，它里面必须要有一个 value 的属性，属性类型是一个被 @Repeatable 注解过的注解数组，注意它是数组。</p><p>可以这样理解。Persons 是一张总的标签，上面贴满了 Person 这种同类型但内容不一样的标签。把 Persons 给一个 SuperMan 贴上，相当于同时给他贴了程序员、产品经理、画家的标签。</p><h3 id="Java预置注解"><a href="#Java预置注解" class="headerlink" title="Java预置注解"></a>Java预置注解</h3><p>Java本身提供了现成的注解。</p><ul><li><p><strong>@Deprecated</strong></p><blockquote><p>用来标记过时的元素。</p></blockquote></li><li><p><strong>@Override</strong></p><blockquote><p>提示子类要复写父类中被@Override 修饰的方法</p></blockquote></li><li><p><strong>@SuppressWarnings</strong></p><blockquote><p>阻止警告。调用被 @Deprecated 注解的方法后，编译器会警告提醒，而有时候开发者会忽略这种警告，他们可以在调用的地方通过 @SuppressWarnings 达到目的。</p></blockquote></li><li><p><strong>@SafeVarargs</strong></p><blockquote><p>参数安全类型注解。它的目的是提醒开发者不要用参数做一些不安全的操作,它的存在会阻止编译器产生 unchecked 这样的警告。它是在 Java 1.7 的版本中加入的。</p></blockquote></li><li><p><strong>@FunctionalInterface</strong></p><blockquote><p>函数式接口注解，这个是 Java 1.8 版本引入的新特性。线程开发中常用的 Runnable 就是一个典型的函数式接口。函数式接口可以很容易转换为 Lambda 表达式。</p></blockquote></li></ul><h2 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a><font color="red"><strong>注解的作用</strong></font></h2><blockquote><p><strong>编译检查</strong> 编译器可以利用注解来探测错误和警告信息；通过代码里标识的元数据让编译器能够实现基本的编译检查【Override】</p></blockquote><blockquote><p><strong>编写文档</strong> 软件工具可以用来利用注解信息来生成代码、Html文档或者做其它相应处理。通过代码里标识的元数据生成文档【生成文档doc文档】</p></blockquote><blockquote><p><strong>代码分析</strong> 某些注解可以在程序运行的时候接受代码的提取；通过代码里标识的元数据对代码进行分析【使用反射】</p></blockquote><p>总之，当开发者使用了Annotation 修饰了类、方法、Field 等成员之后，这些 Annotation 不会自己生效，必须由开发者提供相应的代码来提取并处理 Annotation 信息。这些处理提取和处理 Annotation 的代码统称为 APT（Annotation Processing Tool)。<br><strong>而注解主要就是给编译器或者APT用的。</strong></p><p>注解也就是代码添加元数据，描述信息。</p><p>相比使用单独的XML来描述这些元数据，使用注解要简单些，和代码在一起也更好维护。相比使用继承（如TesCase）或者方法前缀的约定（如testXXX是测试方法）要灵活些。</p><p></p><p>一些插件机制就是通过注解提供插件的元数据，在加载类后扫描所以带该注解的类就可以找到插件，减少了配置的麻烦。</p><p></p><h2 id="注解的解析-反射"><a href="#注解的解析-反射" class="headerlink" title="注解的解析-反射"></a><font color="red"><strong>注解的解析-反射</strong></font></h2><p>注解的提取（解析）需要借助于 Java 的反射技术，反射比较慢，所以注解使用时也需要谨慎计较时间成本。</p><h3 id="类的注解的解析"><a href="#类的注解的解析" class="headerlink" title="类的注解的解析"></a>类的注解的解析</h3><blockquote><p>首先通过Class对象的isAnnotationPresent()方法判断他是否应用了某个注解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnnotationPresent</span><span class="params">(Class&lt;? extends Annotation&gt; annotationClass)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>然后通过getAnnotation()方法获取Annotation对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;A extends Annotation&gt; <span class="function">A <span class="title">getAnnotation</span><span class="params">(Class&lt;A&gt; annotationClass)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>或者getAnnotations()方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Annotation[] getAnnotations() &#123;&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>如果获取到的 Annotation 如果不为 null，则就可以调用它们的属性方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AnnotationTest</span>()</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> hasAnnotation = Test.class.isAnnotationPresent(TestAnnotation.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( hasAnnotation ) &#123;</span><br><span class="line">TestAnnotation testAnnotation = Test.class.getAnnotation(TestAnnotation.class);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"id:"</span>+testAnnotation.id());</span><br><span class="line">System.out.println(<span class="string">"message:"</span>+testAnnotation.message());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>也可以使用forName()方法加载类，使用isAnnotation(Annotation.class)判定对象是否存在注解，并使用getAnnotation(Description.class)得到带有@Description注解的类。</p><h3 id="方法的注解的解析"><a href="#方法的注解的解析" class="headerlink" title="方法的注解的解析"></a>方法的注解的解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@AnnotationTest</span>()</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_method</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        Test my_test = <span class="keyword">new</span> Test();</span><br><span class="line">        Class test_class = Test.class;</span><br><span class="line">        Method method = test_class.getDeclaredMethod(<span class="string">"test_method"</span>,String.class);</span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(AnnotationTest.class)) &#123;</span><br><span class="line">            <span class="comment">//执行方法</span></span><br><span class="line">            method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            method.invoke(my_test, <span class="string">"hello"</span>);</span><br><span class="line">            <span class="comment">//解析注解元素</span></span><br><span class="line">            AnnotationTest a = method.getAnnotation(AnnotationTest.class);</span><br><span class="line">            System.out.println(a.test());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的属性的注解的解析"><a href="#类的属性的注解的解析" class="headerlink" title="类的属性的注解的解析"></a>类的属性的注解的解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@AnnotationTest</span>()</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_method</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        Test my_test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="comment">//利用反射，通过class对象的getDeclaredField(String str)获得元素Field对象</span></span><br><span class="line">        Field test_field = Test.class.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">        <span class="comment">//判断元素是否是注解的对象</span></span><br><span class="line">        <span class="keyword">if</span>(test_field.isAnnotationPresent(AnnotationTest.class))&#123;</span><br><span class="line">            <span class="comment">//修改权限（同一个类内部其实没有必要，肯定有访问权限。）</span></span><br><span class="line">            test_field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//利用Field对象的getXXX()获取实例的值。</span></span><br><span class="line">            System.out.println(test_field.getInt(my_test));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><blockquote><p>一定要用@Retention元注解表示出注解的存活时间，不然在动态执行时可能判定某个类并没有受到注解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationTest &#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">default</span> 2019</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p><a href="https://www.cnblogs.com/Qian123/p/5256084.html" target="_blank" rel="noopener">参考1</a><br><a href="https://blog.csdn.net/briblue/article/details/73824058" target="_blank" rel="noopener">参考2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1551345094255&amp;amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;amp;imgtype=0&amp;amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;使用注解来进行开发，可以免去写XML配置。那么注解到底是什么呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Languages" scheme="https://yoursite.com/categories/Languages/"/>
    
    
      <category term="Java" scheme="https://yoursite.com/tags/Java/"/>
    
      <category term="注解" scheme="https://yoursite.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
      <category term="反射" scheme="https://yoursite.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Java的艺术-浅谈反射机制</title>
    <link href="https://yoursite.com/2018/11/25/Java%E7%9A%84%E8%89%BA%E6%9C%AF-%E6%B5%85%E6%9E%90%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>https://yoursite.com/2018/11/25/Java的艺术-浅析反射机制/</id>
    <published>2018-11-25T13:08:02.000Z</published>
    <updated>2019-03-12T07:42:16.658Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551345094255&amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;imgtype=0&amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png" alt="此处输入图片的描述"><br>在运行时发现和使用类的信息 - <strong>Java反射</strong>。</p><a id="more"></a><h2 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h2><p>通俗的解释是：JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p><h2 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h2><p>动态语言，是指程序在运行时可以改变其结构：新的函数可以被引进，已有的函数可以被删除等在结构上的变化。</p><h2 id="反射的作用"><a href="#反射的作用" class="headerlink" title="反射的作用"></a>反射的作用</h2><p><a href="https://zhuanlan.zhihu.com/p/32259566" target="_blank" rel="noopener">参考</a><br>假设我们有很多食材需要处理，猪肉，牛肉，羊肉；每一样食材对应一个类，这个类里面有处理食材的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pork</span></span>&#123;     <span class="comment">//猪肉</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"cook pork"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Beef</span></span>&#123;     <span class="comment">//牛肉</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"cook beef"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mutton</span></span>&#123;    <span class="comment">//羊肉</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"cook mutton"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当我们在程序中需要根据食材的不同来实例化对应类的对象，再调用对应的方法要怎么做呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       String food=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(food.equals(<span class="string">"Pork"</span>))&#123;</span><br><span class="line">                Pork pork=<span class="keyword">new</span> Pork();</span><br><span class="line">                pork.cook();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(food.equals(<span class="string">"Beef"</span>))&#123;</span><br><span class="line">Beef beef=<span class="keyword">new</span> Beef();</span><br><span class="line">beef.cook();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(food.equals(<span class="string">"Mutton"</span>))&#123;</span><br><span class="line">Mutton mutton=<span class="keyword">new</span> Mutton();</span><br><span class="line">mutton.cook();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上的做法是很容易想到的，很直观，但是当我们的食材有几十种甚至上百种时，我们要怎么写上百个if else 来判断食材，再实例化对应的类，调用对应的方法。</p><p>有没有更简单的方法？答案是肯定的，我们可以利用反射机制来完成这一工作，在程序运行时根据类名实例化对应的对象，并调用对应的方法</p><p>步骤如下：</p><p>1、首先我们需要用到接口:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFood</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、所有的食材类实现这一接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pork</span> <span class="keyword">implements</span> <span class="title">IFood</span></span>&#123;     <span class="comment">//猪肉</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"cook pork"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Beef</span> <span class="keyword">implements</span> <span class="title">IFood</span></span>&#123;     <span class="comment">//牛肉</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"cook beef"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mutton</span> <span class="keyword">implements</span> <span class="title">IFood</span></span>&#123;    <span class="comment">//羊肉</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"cook mutton"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3、接下来我们看看怎么使程序更为简单<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">         String food=<span class="string">"Pork"</span>;                 <span class="comment">//字符串food代表食物的类</span></span><br><span class="line">         Class c=Class.forName(food);        <span class="comment">//根据字符串food来载入类对象</span></span><br><span class="line">         Object object=c.newInstance();      <span class="comment">//生成对象</span></span><br><span class="line">         IFood Ifood=(IFood)object;          <span class="comment">//强制转型</span></span><br><span class="line">         Ifood.cook();                       <span class="comment">//调用方法</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如此一来我们不需要写冗杂的if else 嵌套了</p><p>只需要利用 Class.forName()方法根据字符串来实例化对应的类，并调用其方法即可。</p><p>当我们需要处理其他的食材的时候只需要添加对应的类即可，而主程序中可以不改变一行代码。</p><h2 id="反射的应用"><a href="#反射的应用" class="headerlink" title="反射的应用"></a>反射的应用</h2><h3 id="Class对象的获取"><a href="#Class对象的获取" class="headerlink" title="Class对象的获取"></a>Class对象的获取</h3><p>加载完类之后, 在堆内存中会产生一个Class类型的对象(一个类只有一个Class对象), 这个对象包含了完整的类的结构信息,而且这个Class对象就像一面镜子,透过这个镜子看到类的结构,所以被称之为:<strong>反射。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line">--java.lang.Class&lt;T&gt;</span><br></pre></td></tr></table></figure></p><p>获取Class对象的方法一般有三种方法：</p><blockquote><p>调用<strong>对象</strong>的getClass()方法;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"test"</span>);</span><br><span class="line">Class&lt;?&gt; class1 = sb.getClass();</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p><strong>类名</strong>的.class(最安全/性能最好)属性，或者TYPE属性(继承自Object类);<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; class1 = <span class="keyword">int</span>.class;</span><br><span class="line">Class&lt;?&gt; class2 = Integer.class;</span><br><span class="line">Class&lt;?&gt; class3 = Integer.TYPE;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>运用<strong>Class.forName(String className)</strong>动态加载类,className需要是类的全限定名(最常用)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; class1 = Class.forName(<span class="string">"Integer"</span>);</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="创建实例化对象"><a href="#创建实例化对象" class="headerlink" title="创建实例化对象"></a>创建实例化对象</h3><p>得到了对应java.lang.Class对象，有两种方法通过反射生成对象：[<strong>都需要抛出异常</strong>]</p><blockquote><p>使用Class对象的newInstance()方法来创建该Class对象对应类的实例(这种方式要求该Class对象的对应类有默认构造器)；<strong>相当于无参构造</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; class1 = String.class;</span><br><span class="line">Object str = c.newInstance();</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>先使用Class对象获取指定的Constructor对象, 再调用Constructor对象的newInstance()方法来创建该Class对象对应类的实例(通过这种方式可以选择指定的构造器来创建实例).<strong>适用于无参和有参的构造方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span></span></span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取String所对应的Class对象</span></span><br><span class="line">Class&lt;?&gt; c = String.class;</span><br><span class="line"><span class="comment">//获取String类带一个String参数的构造器</span></span><br><span class="line">Constructor constructor = c.getConstructor(String.class);</span><br><span class="line"><span class="comment">//根据构造器创建实例</span></span><br><span class="line">Object obj = constructor.newInstance(<span class="string">"test"</span>);</span><br></pre></td></tr></table></figure><p>另外可以用getConstructors()方法返回Constructor对象的一个数组。这些对象反映此 Class 对象所表示的类的所有公共构造方法。如果该类没有公共构造方法，或者该类是一个数组类，或者该类反映一个基本类型或 void，则返回一个长度为 0 的数组。 注意，此方法返回 Constructor<t> 对象的数组（即取自此类构造方法的数组）时，此方法的返回类型是 Constructor&lt;?&gt;[]，不是预期的 Constructor<t>[]。此少量信息的返回类型是必需的，因为从此方法返回之后，该数组可能被修改以保存不同类的 Constructor 对象，而这将违反 Constructor<t>[] 的类型保证。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = String.class;<span class="comment">//获取Class对象</span></span><br><span class="line">Constructor&lt;?&gt; cons[] = c.getConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor&lt;?&gt; constructor : cons) &#123;</span><br><span class="line">    System.out.println(constructor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></t></t></p><p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">byte</span>[],<span class="keyword">int</span>,<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">byte</span>[],java.nio.charset.Charset)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">byte</span>[],java.lang.String) <span class="keyword">throws</span> java.io.UnsupportedEncodingException</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">byte</span>[],<span class="keyword">int</span>,<span class="keyword">int</span>,java.nio.charset.Charset)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">byte</span>[],<span class="keyword">int</span>,<span class="keyword">int</span>,java.lang.String) <span class="keyword">throws</span> java.io.UnsupportedEncodingException</span><br><span class="line"><span class="keyword">public</span> java.lang.String(java.lang.StringBuilder)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(java.lang.StringBuffer)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">byte</span>[])</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">int</span>[],<span class="keyword">int</span>,<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> java.lang.String()</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">char</span>[])</span><br><span class="line"><span class="keyword">public</span> java.lang.String(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">char</span>[],<span class="keyword">int</span>,<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">byte</span>[],<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">byte</span>[],<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure></p><p>此外，还可以用getDeclaredConstructors()方法获取所有的构造方法。</p><blockquote><p><strong>getConstructor()和getDeclaredConstructor()区别:</strong></p></blockquote><blockquote><p>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)<br>这个方法会返回制定参数类型的所有构造器，包括public的和非public的，当然也包括private的。<br>getDeclaredConstructors()的返回结果就没有参数类型的过滤了。</p></blockquote><blockquote><p>getConstructor(Class&lt;?&gt;… parameterTypes)<br>这个方法返回的是getDeclaredConstructor()方法返回结果的子集，只返回制定参数类型访问权限是public的构造器。<br>getConstructors()的返回结果同样也没有参数类型的过滤。</p></blockquote><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><p>获取某个Class对象的方法集合，主要有以下几种方法：</p><blockquote><p>getDeclaredMethods方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>getMethods方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method[] getMethods() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>getMethod 方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为<font color="red"><strong>方法的参数对应Class的对象</strong></font>。<br>注意：如果不带方法参数对应的class对象，则无法根据方法名获取对应的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></span><br></pre></td></tr></table></figure></p></blockquote><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><blockquote><p>当我们从类中获取了一个方法后，我们就可以用 invoke() 方法来调用这个方法。invoke 方法的原型为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span> <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException</span></span><br></pre></td></tr></table></figure></p></blockquote><p><strong>invoke回调流程示例：</strong></p><ul><li><p>由Class对象动态构造对应类型对象；</p></li><li><p>利用Class对象的getMethod()、getMethods()、getDeclaredMethod()、getDeclaredMethods()等方法构造method对象；</p></li><li><p>类型对象，使其执行对应形参的方法（也就是需要传入一个<strong>动态执行方法的对象</strong>，以及<strong>对应方法的形参</strong>）。</p></li></ul><p>举例：(利用反射调用String对象的toString()方法)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class test = String.class;</span><br><span class="line">Object ob = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">Method me = test.getDeclaredMethod(<span class="string">"toString"</span>);</span><br><span class="line">System.out.println(me.invoke(ob,<span class="keyword">null</span>));</span><br></pre></td></tr></table></figure></p><p><strong>invoke()的缺点:</strong></p><ul><li><p>invoke的参数和返回值必需时Object类型的，这意味着必须进行多次的类型转换（特别是基本数据类型），而这将导致编译器错过检查代码的机会，有类型安全的风险，只有到了测试阶段才会发现这些错误，此时找到并改正他们将会更加困难。</p></li><li><p>使用反射获得方法指针的代码要比仅仅直接调用方法明显慢一些。</p></li><li><p>因此仅在必要时才使用Method对象，而最好使用<strong>接口和内部类</strong>，不建议Java开发者使用Method对象的回调功能，使用接口进行回调不仅会使代码的运行速度更快，还更易于维护。</p></li></ul><h3 id="访问成员变量"><a href="#访问成员变量" class="headerlink" title="访问成员变量"></a>访问成员变量</h3><p>通过Class对象的的getField()方法可以获取该类所包含的全部或指定的成员变量Field,Filed提供了如下两组方法来读取和设置成员变量值：<br><strong>getFiled：</strong>访问公有的成员变量<br><strong>getDeclaredField：</strong>所有已声明的成员变量，但不能得到其父类的成员变量</p><blockquote><p>getXxx(Object obj): 获取obj对象的该成员变量的值, 此处的Xxx对应8中基本类型,如果该成员变量的类型是引用类型, 则取消get后面的Xxx;<br>setXxx(Object obj, Xxx val): 将obj对象的该成员变量值设置成val值.此处的Xxx对应8种基本类型, 如果该成员类型是引用类型, 则取消set后面的Xxx;</p></blockquote><p><font color="red">注: getDeclaredXxx方法可以获取所有的成员变量,无论private/public</font>;</p><h2 id="反射与Spring框架设计"><a href="#反射与Spring框架设计" class="headerlink" title="反射与Spring框架设计"></a>反射与Spring框架设计</h2><p>反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射，运行时动态加载需要加载的对象。</p><p>Spring内部采用了很多反射机制。<br>很多web框架的前端，实现URI请求映射到Action方法，也可以简单的通过反射来做。<br>这部分内容后面再单独补充。</p><h2 id="反射存在的问题"><a href="#反射存在的问题" class="headerlink" title="反射存在的问题"></a><a href="https://www.sczyh30.com/posts/Java/java-reflection-1/" target="_blank" rel="noopener">反射存在的问题</a></h2><ol><li>由于反射会<strong>额外消耗一定的系统资源</strong>，因此如果不需要动态地创建一个对象，那么就不需要用反射。</li><li>另外，反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致<strong>安全问题</strong>。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1551345094255&amp;amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;amp;imgtype=0&amp;amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;在运行时发现和使用类的信息 - &lt;strong&gt;Java反射&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Languages" scheme="https://yoursite.com/categories/Languages/"/>
    
    
      <category term="Java" scheme="https://yoursite.com/tags/Java/"/>
    
      <category term="注解" scheme="https://yoursite.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
      <category term="反射" scheme="https://yoursite.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Java的艺术-数据类型详解</title>
    <link href="https://yoursite.com/2018/10/07/Java%E7%9A%84%E8%89%BA%E6%9C%AF-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://yoursite.com/2018/10/07/Java的艺术-数据类型/</id>
    <published>2018-10-07T06:48:20.000Z</published>
    <updated>2019-03-12T07:40:16.320Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551345094255&amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;imgtype=0&amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png" alt="此处输入图片的描述"></p><p><strong>一文道尽Java数据类型怎么用。</strong><br><a id="more"></a></p><h2 id="什么是数据类型"><a href="#什么是数据类型" class="headerlink" title="什么是数据类型"></a><font color="red">什么是数据类型</font></h2><p>　　数据类型在计算机语言里面，是对内存位置的一个抽象表达方式，可以理解为针对内存的一种抽象的表达方式。<br>　　Java是强类型语言，所以Java对于数据类型的规范会相对严格。数据类型是语言的抽象原子概念，可以说是语言中最基本的单元定义，在Java里面，本质上讲将数据类型分为两种：基本类型和引用数据类型。</p><blockquote><p>基本类型：简单数据类型是不能简化的、内置的数据类型、由编程语言本身定义，它表示了真实的数字、字符和整数。</p></blockquote><blockquote><p>引用数据类型：Java语言本身不支持C++中的结构（struct）或联合（union）数据类型，它的复合数据类型一般都是通过类或接口进行构造，类提供了捆绑数据和方法的方式，同时可以针对程序外部进行信息隐藏。</p></blockquote><p>　　不同数据类型的变量在内存中分配的字节数不同，同时存储方式也是不同的。所以Java给变量赋值前需要先确定变量的类型，确定了变量的类型，即确定了数据需分配内存空间的大小，数据在内存的存储方式。</p><h2 id="Java基本类型和对应的包装类型"><a href="#Java基本类型和对应的包装类型" class="headerlink" title="Java基本类型和对应的包装类型"></a><font color="red">Java基本类型和对应的包装类型</font></h2><p>为了方便对基本类型进行操作，Java为每个基本类型提供了对应的包装类型（引用类型）。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><strong>byte</strong>：Java中最小的数据类型，在内存中占8位(bit)，即1个字节，取值范围-128~127，默认值0</p><p><strong>short</strong>：短整型，在内存中占16位，即2个字节，取值范围-32768~32717，默认值0</p><p><strong>int</strong>：整型，用于存储整数，在内在中占32位，即4个字节，取值范围-2147483648~2147483647，默认值0</p><p><strong>long</strong>：长整型，在内存中占64位，即8个字节-2^63~2^63-1，默认值0L</p><p><strong>float</strong>：浮点型，在内存中占32位，即4个字节，用于存储带小数点的数字（与double的区别在于float类型有效小数点只有6~7位），默认值0</p><p><strong>double</strong>：双精度浮点型，用于存储带有小数点的数字，在内存中占64位，即8个字节，默认值0</p><p><strong>char</strong>：字符型，用于存储单个字符，占16位，即2个字节，取值范围0~65535，默认值为空</p><p><strong>boolean</strong>：布尔类型，占<a href="https://www.jianshu.com/p/2f663dc820d0" target="_blank" rel="noopener">1位，1个字节或者四个字节(存在不同解释角度)</a>，用于判断真或假（仅有两个值，即true、false），默认值false。</p><p>Java中基本类型的存储是固定字节的，具体大小与对应的包装类型如下：</p><table><thead><tr><th style="text-align:center">基本类型</th><th style="text-align:center">存储位数</th><th style="text-align:center">包装类型</th></tr></thead><tbody><tr><td style="text-align:center">boolean</td><td style="text-align:center"><a href="https://www.jianshu.com/p/2f663dc820d0" target="_blank" rel="noopener">1,8,32</a></td><td style="text-align:center">Boolean</td></tr><tr><td style="text-align:center">byte</td><td style="text-align:center">8</td><td style="text-align:center">Byte</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">16</td><td style="text-align:center">Character</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">16</td><td style="text-align:center">Short</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">32</td><td style="text-align:center">Integer</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">64</td><td style="text-align:center">Long</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">32</td><td style="text-align:center">Float</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">64</td><td style="text-align:center">Double</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">BigInteger</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">BigDecimal</td></tr></tbody></table><h3 id="封装类型特征"><a href="#封装类型特征" class="headerlink" title="封装类型特征"></a>封装类型特征</h3><blockquote><p>每个基本类型都有一个包装类，这些包装类包含在<strong>java.lang</strong>包中。继承关系如下：</p></blockquote><ul><li>Object<ul><li>Boolean</li><li>Number<ul><li>Byte</li><li>Short</li><li>Integer</li><li>Long</li><li>Float</li><li>Double</li><li>BigInteger</li><li>BigDecimal</li></ul></li><li>Character</li></ul></li></ul><blockquote><p><strong>BigInteger、BigDecimal</strong>没有相对应的基本类型，主要应用于高精度的运算，<strong>BigInteger</strong> 支持任意精度的整数，<strong>BigDecimal</strong>支持任意精度带小数点的运算。</p></blockquote><blockquote><p>当整数类型的数据使用字面量赋值的时候，默认值为int类型，就是直接使用0或者其他数字的时候，<strong>默认值的类型为int类型</strong>，所以当使用 long a = 0这种赋值方式的时候，JVM内部存在数据转换。</p></blockquote><blockquote><p>浮点类型的数据使用字面量赋值的时候，<strong>默认值为double类型</strong>，就是当小数字面量出现的时候，JVM会使用double类型的数据类型。</p></blockquote><blockquote><p>从JDK 5.0开始，Java包含<strong>自动拆箱装箱</strong>的特性.</p></blockquote><h2 id="在内存中的存储方式"><a href="#在内存中的存储方式" class="headerlink" title="在内存中的存储方式"></a><font color="red">在内存中的存储方式</font></h2><blockquote><p><strong>基本数据类型：</strong>所有的简单数据类型不存在“引用”的概念，基本数据类型都是直接存储在内存中的堆、栈上；</p></blockquote><blockquote><p><strong>引用类型：</strong>引用类型继承于Object类（也是引用类型）都是按照Java里面存储对象的内存模型来进行数据存储的，使用Java内存堆和内存栈来进行这种类型的数据存储，简单地讲，“引用”是存储在有序的内存栈上的，而对象本身的值存储在内存堆上的；</p></blockquote><h3 id="关于基本数据类型存放的位置"><a href="#关于基本数据类型存放的位置" class="headerlink" title="关于基本数据类型存放的位置"></a><strong>关于基本数据类型存放的位置</strong></h3><p>取决于基本类型声明的位置：</p><blockquote><p><strong>在方法中声明的变量</strong>，即该变量是局部变量，每当程序调用方法时，系统都会为该方法建立一个方法栈，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，其对应在该方法中声明的变量随着栈的销毁而结束，这就局部变量只能在方法中有效的原因。方法中声明的变量可以是基本类型的变量，也可以是引用类型的变量。<br>（1）当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在方法栈中<br>（2）当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在方法的栈中，该变量所指向的对象是放在堆类存中的。</p></blockquote><blockquote><p><strong>在类中声明的变量</strong>是成员变量，也叫全局变量，放在堆中的（因为全局变量不会随着某个方法执行结束而销毁）。同样在类中声明的变量即可是基本类型的变量 也可是引用类型的变量。<br>（1）当声明的是基本类型的变量其变量名及其值放在堆内存中的<br>（2）引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中</p></blockquote><h3 id="基本类型和封装类型异同"><a href="#基本类型和封装类型异同" class="headerlink" title="基本类型和封装类型异同"></a>基本类型和封装类型异同</h3><blockquote><p>基本类型不是对象</p></blockquote><blockquote><p>声明方式不同：包装类型需要用new。</p></blockquote><blockquote><p>存储方式和存储位置不同</p></blockquote><blockquote><p>初始值不同：boolean初始为false,int为0，而Boolean和Integer都为null。</p></blockquote><blockquote><p>使用方式和场景不同：基本类型数据存储相对简单，运算效率比较高。使用包装类型会牺牲一些转换效率，但可以避免持久化数据时产生的一些异常。同时，集合的元素必须是对象类型，满足了java一切皆是对象的思想。</p></blockquote><blockquote><p>销毁效率不同：基本类型定义的变量创建和销毁很快，而类定义的变量还需要JVM去销毁。</p></blockquote><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a><font color="red"><strong>类型转换</strong></font></h2><h3 id="基本类型之自动类型转换"><a href="#基本类型之自动类型转换" class="headerlink" title="基本类型之自动类型转换"></a>基本类型之自动类型转换</h3><p>注意，只能低精度转向高精度。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> char1 = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> char2 = <span class="string">'b'</span>;</span><br><span class="line"><span class="keyword">int</span> int1 = char1 + <span class="number">1</span>;<span class="comment">//这里即自动类型转换。</span></span><br><span class="line"><span class="keyword">int</span> int2 = char1 +char2;<span class="comment">//这里也完成了自动类型转换。</span></span><br><span class="line"><span class="comment">//char2 = int1;//出错</span></span><br></pre></td></tr></table></figure></p><h3 id="基本类型之强制类型转换"><a href="#基本类型之强制类型转换" class="headerlink" title="基本类型之强制类型转换"></a>基本类型之强制类型转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> char1 = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> char2 = <span class="string">'b'</span>;</span><br><span class="line"><span class="keyword">int</span> int1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> char3 =(<span class="keyword">char</span>)int1;</span><br><span class="line"><span class="keyword">char</span> char4 = (<span class="keyword">char</span>)(char1 + char2);<span class="comment">//这里也完成了强制类型转换。</span></span><br></pre></td></tr></table></figure><h3 id="基本类型→包装类型"><a href="#基本类型→包装类型" class="headerlink" title="基本类型→包装类型"></a>基本类型→包装类型</h3><p>这主要是包括构造方法和装箱操作。<br>还有valauOf()方法。</p><h4 id="（1）拆箱与装箱"><a href="#（1）拆箱与装箱" class="headerlink" title="（1）拆箱与装箱"></a>（1）拆箱与装箱</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">8</span>;</span><br><span class="line">System.out.println(a == b);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>注意区分拆箱和装箱，以及对象比较：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> int1 = <span class="number">9</span>;</span><br><span class="line">Integer a = <span class="number">9</span>;</span><br><span class="line">Integer c = <span class="keyword">new</span> Integer(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(int1 == c);<span class="comment">//true，比较值</span></span><br><span class="line">System.out.println(a == int1);<span class="comment">//true，比较值</span></span><br><span class="line">System.out.println(a == c);<span class="comment">//false，比较引用</span></span><br></pre></td></tr></table></figure></p><h4 id="（2）构造方法"><a href="#（2）构造方法" class="headerlink" title="（2）构造方法"></a>（2）构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//char</span></span><br><span class="line">Character(<span class="keyword">char</span> value)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//boolean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Boolean</span><span class="params">(<span class="keyword">boolean</span> value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Boolean</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function"><span class="comment">//注意，这个构造方法是输入的字符串是忽略大小写，相见源码：</span></span></span><br><span class="line"><span class="function"><span class="title">return</span> <span class="params">((s != <span class="keyword">null</span>)</span> &amp;&amp; s.<span class="title">equalsIgnoreCase</span><span class="params">(<span class="string">"true"</span>)</span>)</span>;</span><br></pre></td></tr></table></figure><p>其余的Byte、Int、Double、Long、Short都包含两个构造方法，一个传入本身的基本类型，一个传入一个String类型。</p><p>注意，Float包含三个构造函数，除了上述两个，还可以传入double基本类型的值，源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Float</span><span class="params">(<span class="keyword">double</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = (<span class="keyword">float</span>)value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="（3）valueOf-使用上等价于构造方法"><a href="#（3）valueOf-使用上等价于构造方法" class="headerlink" title="（3）valueOf():使用上等价于构造方法"></a>（3）<strong>valueOf()</strong>:使用上等价于构造方法</h4><p><strong>valueOf()</strong>方法等价于构造方法，能用构造方法得到的包装对象也可以用同样的方法通过<strong>valueOf()</strong>得到。</p><h4 id="（4）String-→基本类型的其他方法"><a href="#（4）String-→基本类型的其他方法" class="headerlink" title="（4）String →基本类型的其他方法"></a>（4）String →基本类型的其他方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer to String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s)</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parseInt(s,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s, <span class="keyword">int</span> radix)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> NumberFormatException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * WARNING: This method may be invoked early during VM initialization</span></span><br><span class="line"><span class="comment">         * before IntegerCache is initialized. Care must be taken to not use</span></span><br><span class="line"><span class="comment">         * the valueOf method.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (radix &lt; Character.MIN_RADIX) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"radix "</span> + radix +</span><br><span class="line">                                            <span class="string">" less than Character.MIN_RADIX"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (radix &gt; Character.MAX_RADIX) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"radix "</span> + radix +</span><br><span class="line">                                            <span class="string">" greater than Character.MAX_RADIX"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> negative = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, len = s.length();</span><br><span class="line">        <span class="keyword">int</span> limit = -Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> multmin;</span><br><span class="line">        <span class="keyword">int</span> digit;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> firstChar = s.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (firstChar &lt; <span class="string">'0'</span>) &#123; <span class="comment">// Possible leading "+" or "-"</span></span><br><span class="line">                <span class="keyword">if</span> (firstChar == <span class="string">'-'</span>) &#123;</span><br><span class="line">                    negative = <span class="keyword">true</span>;</span><br><span class="line">                    limit = Integer.MIN_VALUE;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstChar != <span class="string">'+'</span>)</span><br><span class="line">                    <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="comment">// Cannot have lone "+" or "-"</span></span><br><span class="line">                    <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            multmin = limit / radix;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">                <span class="comment">// Accumulating negatively avoids surprises near MAX_VALUE</span></span><br><span class="line">                digit = Character.digit(s.charAt(i++),radix);</span><br><span class="line">                <span class="keyword">if</span> (digit &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (result &lt; multmin) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">                &#125;</span><br><span class="line">                result *= radix;</span><br><span class="line">                <span class="keyword">if</span> (result &lt; limit + digit) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">                &#125;</span><br><span class="line">                result -= digit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> negative ? result : -result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其他类包括了<strong>parseByte(),parseDouble()</strong>等。</p><h3 id="包装类型→基本类型"><a href="#包装类型→基本类型" class="headerlink" title="包装类型→基本类型"></a>包装类型→基本类型</h3><h4 id="（1）包装类型到对应基本类型"><a href="#（1）包装类型到对应基本类型" class="headerlink" title="（1）包装类型到对应基本类型"></a>（1）包装类型到对应基本类型</h4><p>根据继承关系，继承自java.lang.Number的包装类型都包含了Number类的如下公共无参方法，源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">longValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">floatValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">doubleValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">byteValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">byte</span>)intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">shortValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">short</span>)intValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>类似的，对于Charcter类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>对于Boolean类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">booleanValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="（2）包装类型→String类型"><a href="#（2）包装类型→String类型" class="headerlink" title="（2）包装类型→String类型"></a>（2）包装类型→String类型</h4><blockquote><p>除此外，所有的包装类型都可以用<strong>toString()</strong>方法得到字符串类型的对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Character</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[] = &#123;value&#125;;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(buf);<span class="comment">//实际上调用String类的valueOf()方法。</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Boolean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value ? <span class="string">"true"</span> : <span class="string">"false"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Float</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Float.toString(value);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FloatingDecimal.toJavaFormatString(f);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Double</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString(value);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FloatingDecimal.toJavaFormatString(d);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString(value);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//注意看这里，java是如何把int类型的数转换成String的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == Integer.MIN_VALUE)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"-2147483648"</span>;</span><br><span class="line">        <span class="keyword">int</span> size = (i &lt; <span class="number">0</span>) ? stringSize(-i) + <span class="number">1</span> : stringSize(i);<span class="comment">//得到i的字符数</span></span><br><span class="line">        <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[size];<span class="comment">//buf存储字符</span></span><br><span class="line">        getChars(i, size, buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> index, <span class="keyword">char</span>[] buf)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q, r;</span><br><span class="line">        <span class="keyword">int</span> charPos = index;</span><br><span class="line">        <span class="keyword">char</span> sign = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sign = <span class="string">'-'</span>;</span><br><span class="line">            i = -i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate two digits per iteration</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">65536</span>) &#123;</span><br><span class="line">            q = i / <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// really: r = i - (q * 100);</span></span><br><span class="line">            r = i - ((q &lt;&lt; <span class="number">6</span>) + (q &lt;&lt; <span class="number">5</span>) + (q &lt;&lt; <span class="number">2</span>));</span><br><span class="line">            i = q;</span><br><span class="line">            buf [--charPos] = DigitOnes[r];</span><br><span class="line">            buf [--charPos] = DigitTens[r];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fall thru to fast mode for smaller numbers</span></span><br><span class="line">        <span class="comment">// assert(i &lt;= 65536, i);</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            q = (i * <span class="number">52429</span>) &gt;&gt;&gt; (<span class="number">16</span>+<span class="number">3</span>);</span><br><span class="line">            r = i - ((q &lt;&lt; <span class="number">3</span>) + (q &lt;&lt; <span class="number">1</span>));  <span class="comment">// r = i-(q*10) ...</span></span><br><span class="line">            buf [--charPos] = digits [r];</span><br><span class="line">            i = q;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sign != <span class="number">0</span>) &#123;</span><br><span class="line">            buf [--charPos] = sign;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Long，与Integer类似的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString(value);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">long</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == Long.MIN_VALUE)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"-9223372036854775808"</span>;</span><br><span class="line">        <span class="keyword">int</span> size = (i &lt; <span class="number">0</span>) ? stringSize(-i) + <span class="number">1</span> : stringSize(i);</span><br><span class="line">        <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[size];</span><br><span class="line">        getChars(i, size, buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Short</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.toString((<span class="keyword">int</span>)value);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//所以也调用了Integer的这个静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == Integer.MIN_VALUE)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"-2147483648"</span>;</span><br><span class="line">        <span class="keyword">int</span> size = (i &lt; <span class="number">0</span>) ? stringSize(-i) + <span class="number">1</span> : stringSize(i);<span class="comment">//得到i的字符数</span></span><br><span class="line">        <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[size];<span class="comment">//buf存储字符</span></span><br><span class="line">        getChars(i, size, buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Byte</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.toString((<span class="keyword">int</span>)value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>常见的类型转换，以Integer为例：</p><h4 id="int-→-String"><a href="#int-→-String" class="headerlink" title="int → String"></a>int → String</h4><blockquote><p>(1)int后直接+””<br>(2)s = String.valueOf(i);<br>(3)Integer.toString(i);</p></blockquote><h4 id="String→int"><a href="#String→int" class="headerlink" title="String→int"></a>String→int</h4><blockquote><p>(1) i = Integer.parseInt(s);<br>(2) i = Integer.valueOf(s).intValue();<br>(3) i = new Integer(s).intValue();</p></blockquote><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>Java 5.0版本之后引入的除泛型之外的另外一个强大特性：枚举(Enums)。性能远高于静态类。解决一些固定常量集合的问题上枚举成为唯一首选和推荐的一种方式。<br><a href="https://blog.csdn.net/zyhlwzy/article/details/79045066" target="_blank" rel="noopener">枚举类解析</a></p><blockquote><p>enum 不能使用 extends 关键字继承其他类，因为 enum 已经继承了 java.lang.Enum（java是单一继承）。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1551345094255&amp;amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;amp;imgtype=0&amp;amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一文道尽Java数据类型怎么用。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Languages" scheme="https://yoursite.com/categories/Languages/"/>
    
    
      <category term="Java" scheme="https://yoursite.com/tags/Java/"/>
    
      <category term="源码" scheme="https://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="数据类型" scheme="https://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java的艺术-多线程(1)</title>
    <link href="https://yoursite.com/2018/10/05/Java%E7%9A%84%E8%89%BA%E6%9C%AF-%E5%A4%9A%E7%BA%BF%E7%A8%8B(1)/"/>
    <id>https://yoursite.com/2018/10/05/Java的艺术-多线程(1)/</id>
    <published>2018-10-05T06:48:20.000Z</published>
    <updated>2019-03-12T07:37:46.659Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551345094255&amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;imgtype=0&amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png" alt="此处输入图片的描述"><br>详解Java的多线程编程。<br><a id="more"></a></p><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a><font color="red">进程与线程</font></h2><p><strong>进程（Thread）：</strong>进程指正在运行的程序。当一个程序进入内存运行，即变成一个进程，进程是处于运行过程中的程序，并且具有一定独立功能，包括由操作系统分配的内存空间。<br><strong>线程(Process)：</strong>线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为<strong>多线程程序</strong>。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。<br><strong>并行（Parallen）与并发(Concurrent)：</strong><br>并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。<br>并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。<br><strong>并发不一定是并行的，并行一定是并发的。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果某个系统支持两个或者多个动作（Action）同时存在，那么这个系统就是一个并发系统。如果某个系统支持两个或者多个动作同时执行，那么这个系统就是一个并行系统。并发系统与并行系统这两个定义之间的关键差异在于“存在”这个词。</span><br><span class="line">在并发程序中可以同时拥有两个或者多个线程。这意味着，如果程序在单核处理器上运行，那么这两个线程将交替地换入或者换出内存。这些线程是同时“存在”的——每个线程都处于执行过程中的某个状态。如果程序能够并行执行，那么就一定是运行在多核处理器上。此时，程序中的每个线程都将分配到一个独立的处理器核上，因此可以同时运行。</span><br><span class="line">“并行”概念是“并发”概念的一个子集。也就是说，你可以编写一个拥有多个线程或者进程的并发程序，但如果没有多核处理器来执行这个程序，那么就不能以并行方式来运行代码。因此，凡是在求解单个问题时涉及多个执行流程的编程模式或者执行行为，都属于并发编程的范畴。</span><br></pre></td></tr></table></figure></p><p><strong>其他概念：</strong></p><ul><li><p>线程同步（synchronized）</p><pre><code>可以同步方法，也可以同步代码块；对于同步方法来说，每个方法只有获取到所属类实例的锁才可以被执行，一旦该方法被执行，则独占锁，知道方法返回时或者异常退出时才会释放掉锁；同步代码块也是一样，当两个并发线程访问同一个对象中的这个synchronized（this）代码块的时候，一个时间内只有一个线程得到执行，另一个线程只有在这个线程执行完成之后才可以执行；</code></pre></li><li>线程间通信</li><li>线程死锁</li><li>线程控制：挂起、停止和恢复</li></ul><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a><a href="http://www.runoob.com/java/java-multithreading.html" target="_blank" rel="noopener"><font color="red">线程的生命周期</font></a></h2><p><strong>新建状态:</strong><br>使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。</p><p><strong>就绪状态:</strong><br>当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</p><p><strong>运行状态:</strong><br>如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p><p><strong>阻塞状态:</strong><br>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：</p><p>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</p><p>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</p><p>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。</p><p><strong>死亡状态:</strong><br>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。<br><img src="https://upload-images.jianshu.io/upload_images/1689841-383f7101e6588094.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt="此处输入图片的描述"></p><p>线程在Running的过程中可能会遇到阻塞(Blocked)情况：</p><ul><li>调用join()和sleep()方法，sleep()时间结束或被打断，join()中断,IO完成都会回到Runnable状态，等待JVM的调度。</li><li>调用wait()，使该线程处于等待池(wait blocked pool),直到notify()/notifyAll()，线程被唤醒被放到锁定池(lock blocked pool )，释放同步锁使线程回到可运行状态（Runnable）</li><li>对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。<br>此外，在runnable状态的线程是处于被调度的线程，此时的调度顺序是不一定的。Thread类中的yield方法可以让一个running状态的线程转入runnable。</li></ul><h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a><font color="red">线程的优先级</font></h2><p>每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。</p><p>Java 线程的优先级是一个整数，其取值范围是 <strong>1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）</strong>。</p><p>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</p><p>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。</p><h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a><font color="red">线程的实现</font></h2><p>Java提供了三种创建线程的方法：</p><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><ul><li>声明实现 Runnable 接口的类。该类然后实现 run 方法。然后创建Runnable的子类对象，传入到某个线程的构造方法中，开启线程。</li><li>将线程的任务从线程的子类中分离出来，进行了单独的封装。按照面向对象的思想将任务的封装成对象。</li><li>避免了java单继承的局限性。<br><strong>步骤：</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、定义类实现Runnable接口。</span><br><span class="line">2、覆盖接口中的run方法。。</span><br><span class="line">3、创建Thread类的对象</span><br><span class="line">4、将Runnable接口的子类对象作为参数传递给Thread类的构造函数。</span><br><span class="line">5、调用Thread类的start方法开启线程。</span><br></pre></td></tr></table></figure></li></ul><p><strong>示例：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyThread2</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.num = num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i + num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="继承Thread类本身"><a href="#继承Thread类本身" class="headerlink" title="继承Thread类本身"></a>继承Thread类本身</h3><p>Thread是程序中的执行线程。Java 虚拟机允许应用程序并发地运行多个执行线程。<br>继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。<br>该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。<br><strong>步骤：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.定义一个类继承Thread。</span><br><span class="line">2.重写run方法。</span><br><span class="line">3.创建子类对象，就是创建线程对象。</span><br><span class="line">4.调用start方法，开启线程并让线程执行，同时还会告诉jvm去调用run方法</span><br></pre></td></tr></table></figure></p><p><strong>示例：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">":"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建线程实例</span></span><br><span class="line">MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line"><span class="comment">//修改线程名字</span></span><br><span class="line">mt.setName(<span class="string">"thread1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">mt.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程实例</span></span><br><span class="line">MyThread mt2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">mt2.setName(<span class="string">"thread2"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">mt2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="通过Callabel和Future创建线程（不常用）"><a href="#通过Callabel和Future创建线程（不常用）" class="headerlink" title="通过Callabel和Future创建线程（不常用）"></a>通过Callabel和Future创建线程（不常用）</h3><p><strong>步骤：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。</span><br><span class="line">2. 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。</span><br><span class="line">3. 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</span><br><span class="line">4. 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。</span><br></pre></td></tr></table></figure></p><p><strong>示例：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableThreadTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        CallableThreadTest ctt = <span class="keyword">new</span> CallableThreadTest();  <span class="comment">//创建Callable实现类的实例</span></span><br><span class="line">        FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(ctt);  <span class="comment">//用FutureTask类包装Callble对象，FutureTask对象封装了Callable对象call方法的返回值，因为它实现了Future()接口。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" 的循环变量i的值"</span>+i);  </span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">20</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">new</span> Thread(ft,<span class="string">"有返回值的线程"</span>).start();  <span class="comment">//使用FutureTask对象作为Thread对象的target创建并启动新线程</span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">try</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            System.out.println(<span class="string">"子线程的返回值："</span>+ft.get());  <span class="comment">//使用FutureTask的get方法来获得子线程结束后的返回值。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)  </span><br><span class="line">        &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e)  </span><br><span class="line">        &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception  <span class="comment">//线程执行体，有返回值</span></span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> i;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="三种方式对比"><a href="#三种方式对比" class="headerlink" title="三种方式对比"></a>三种方式对比</h2><ol><li><p>采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</p></li><li><p>使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</p></li></ol><h2 id="Thread的run-和start-方法的区别"><a href="#Thread的run-和start-方法的区别" class="headerlink" title="Thread的run()和start()方法的区别"></a>Thread的run()和start()方法的区别</h2><p>start()：该方法是在当前线程中启动一个新的线程，而新启动的线程会调用run()方法，同时该方法不能重复调用；<br>run()  ：该方法和普通的方法一样，可以重复执行，不会创建新的线程。</p><h2 id="终止线程的方法"><a href="#终止线程的方法" class="headerlink" title="终止线程的方法"></a>终止线程的方法</h2><p>1、当run方法执行完毕，自动终止；</p><p>2、使用stop方法，不过这个方法不推荐使用，会有意料不到的后果；</p><p>3、使用interrupt方法</p><h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><h3 id="安全问题产生的原因"><a href="#安全问题产生的原因" class="headerlink" title="安全问题产生的原因"></a>安全问题产生的原因</h3><ul><li><p>多个线程在操作共享的数据。</p></li><li><p>操作共享数据的线程代码有多条。</p></li><li><p>当一个线程在执行操作共享数据的多条代码过程中，其他线程参与了运算。就会导致线程安全问题的产生。</p></li></ul><h3 id="解决办法synchronized"><a href="#解决办法synchronized" class="headerlink" title="解决办法synchronized"></a>解决办法synchronized</h3><ul><li><p>修饰同步代码块</p><blockquote><p>将多条操作共享数据的线程代码封装起来，当有线程在执行这些代码的时候，其他线程时不可以参与运算的。必须要当前线程把这些代码都执行完毕后，其他线程才可以参与运算。在java中，用同步代码块就可以解决这个问题。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">synchronized</span>(对象)</span><br><span class="line">&#123;</span><br><span class="line">需要被同步的代码 ；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修饰同步函数(方法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 修饰符 <span class="keyword">synchronized</span> 返回值 方法名()&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>修饰一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；</p></blockquote><blockquote><p>修饰一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</p></blockquote><blockquote><p>Synchronized的作用主要有三个：<br>（1）确保线程互斥的访问同步代码<br>（2）保证共享变量的修改能够及时可见<br>（3）有效解决重排序问题。</p></blockquote><h3 id="好处和弊端"><a href="#好处和弊端" class="headerlink" title="好处和弊端"></a>好处和弊端</h3><p>同步的好处：解决了线程的安全问题。</p><p>同步的弊端：相对降低了效率，因为同步外的线程的都会判断同步锁。</p><p>同步的前提：同步中必须有多个线程并使用同一个锁。</p><h3 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a><a href="https://www.cnblogs.com/mudao/p/5867107.html" target="_blank" rel="noopener">死锁问题</a></h3><p>同步嵌套时，两个线程你拿了我的锁，我拿了你的锁，都不释放，造成死锁。<br>举例：<br>创建两个字符串a和b，再创建两个线程A和B，让每个线程都用synchronized锁住字符串（A先锁a，再去锁b；B先锁b，再锁a），如果A锁住a，B锁住b，A就没办法锁住b，B也没办法锁住a，这时就陷入了死锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String obj1 = <span class="string">"obj1"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String obj2 = <span class="string">"obj2"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread a = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Lock1());</span><br><span class="line">        Thread b = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Lock2());</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Lock1 running"</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(DeadLock.obj1)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Lock1 lock obj1"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);<span class="comment">//获取obj1后先等一会儿，让Lock2有足够的时间锁住obj2</span></span><br><span class="line">                    <span class="keyword">synchronized</span>(DeadLock.obj2)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"Lock1 lock obj2"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Lock2 running"</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(DeadLock.obj2)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Lock2 lock obj2"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span>(DeadLock.obj1)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"Lock2 lock obj1"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="多线程常见问题汇总"><a href="#多线程常见问题汇总" class="headerlink" title="多线程常见问题汇总"></a><font color="red">多线程常见问题汇总</font></h2><p><a href="https://zhuanlan.zhihu.com/p/26441926" target="_blank" rel="noopener">直达链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1551345094255&amp;amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;amp;imgtype=0&amp;amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;详解Java的多线程编程。&lt;br&gt;
    
    </summary>
    
      <category term="Languages" scheme="https://yoursite.com/categories/Languages/"/>
    
    
      <category term="Java" scheme="https://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="https://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CUDA安装问题解决</title>
    <link href="https://yoursite.com/2018/07/29/CUDA%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>https://yoursite.com/2018/07/29/CUDA安装问题解决/</id>
    <published>2018-07-29T06:38:20.000Z</published>
    <updated>2018-12-27T03:33:38.367Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>CUDA安装失败问题解决。</p><p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRkXxUeuvvVGryPwRjR_fSlc7YHFVRj7oq-475WcJFVBQ2zZII6" alt="此处输入图片的描述"><br><a id="more"></a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>CUDA安装失败都是由于其中Visual Studio(VS) Intergration无法安装导致：</li></ul><p><img src="https://s1.ax1x.com/2018/12/27/F2XPTx.png" alt="此处输入图片的描述"></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul><li>择自定义安装，并不要安装VS组件：</li></ul><p><img src="https://s1.ax1x.com/2018/12/27/F2XFk6.png" alt="此处输入图片的描述"></p><ul><li><p>将<strong>“CUDAVisualStudioIntegration\extras\visual_studio_integration\MSBuildExtensions”</strong>下的文件直接拷贝到<strong>“C:\Program Files (x86)\MSBuild\Microsoft.Cpp\v4.0\V140\BuildCustomizations”</strong>文件夹中。<br> <strong>“CUDAVisualStudioIntegration”</strong>这个可以在默认文件：<strong>“C:\Users\用户名\AppData\Local\Temp\CUDA”</strong>下找到，但是如果你把NVIDIA安装程序关闭了，那么这个默认文件就会消失的，所以可以等NVIDIA安装程序将数据解压完毕后再去找，肯定能找到。</p></li><li><p>复制解压后的cudnn文件到cuda对应目录下即可。最后验证安装成功：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\wufan&gt;nvcc -V</span><br><span class="line">nvcc: NVIDIA (R) Cuda compiler driver</span><br><span class="line">Copyright (c) 2005-2017 NVIDIA Corporation</span><br><span class="line">Built on Fri_Sep__1_21:08:32_Central_Daylight_Time_2017</span><br><span class="line">Cuda compilation tools, release 9.0, V9.0.176</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;CUDA安装失败问题解决。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRkXxUeuvvVGryPwRjR_fSlc7YHFVRj7oq-475WcJFVBQ2zZII6&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Tools" scheme="https://yoursite.com/categories/Tools/"/>
    
    
      <category term="cuda" scheme="https://yoursite.com/tags/cuda/"/>
    
  </entry>
  
  <entry>
    <title>Linux之路</title>
    <link href="https://yoursite.com/2018/07/22/Linux%E4%B9%8B%E8%B7%AF/"/>
    <id>https://yoursite.com/2018/07/22/Linux之路/</id>
    <published>2018-07-22T06:38:00.000Z</published>
    <updated>2019-02-21T13:15:03.747Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>记录使用Linux遇到的问题与解决办法。</p><p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRkXxUeuvvVGryPwRjR_fSlc7YHFVRj7oq-475WcJFVBQ2zZII6" alt="此处输入图片的描述"><br><a id="more"></a></p><h2 id="无法解析或打开软件包的列表或是状态文件问题的解决方案"><a href="#无法解析或打开软件包的列表或是状态文件问题的解决方案" class="headerlink" title="无法解析或打开软件包的列表或是状态文件问题的解决方案"></a>无法解析或打开软件包的列表或是状态文件问题的解决方案</h2><p>在通过sudo apt-get install安装软件的时候，可能会出现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">正在读取软件包列表... 有错误！</span><br><span class="line">E: Encountered a section with no Package: header</span><br><span class="line">E: Problem with MergeList /var/lib/apt/lists/??</span><br><span class="line">E: 无法解析或打开软件包的列表或是状态文件。</span><br></pre></td></tr></table></figure></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>执行下面两条语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /var/lib/apt/lists/* -vf #删掉apt下的lists文件下的内容</span><br><span class="line">sudo apt-get update # 更新软件源</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;记录使用Linux遇到的问题与解决办法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRkXxUeuvvVGryPwRjR_fSlc7YHFVRj7oq-475WcJFVBQ2zZII6&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Operating Systems" scheme="https://yoursite.com/categories/Operating-Systems/"/>
    
    
      <category term="linux" scheme="https://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>JupyterNotebook教程</title>
    <link href="https://yoursite.com/2018/07/15/JupyterNotebook%E6%95%99%E7%A8%8B/"/>
    <id>https://yoursite.com/2018/07/15/JupyterNotebook教程/</id>
    <published>2018-07-15T05:40:42.000Z</published>
    <updated>2018-12-27T04:07:35.966Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要</strong>：简单总结Jupyter Notebook的教程,方便以后使用。</p><p><img src="https://qiot.qnap.com/blog/wp-content/uploads/2018/08/JupyterHub-2.png" alt="此处输入图片的描述"><br><a id="more"></a></p><h2 id="notebook-界面组成"><a href="#notebook-界面组成" class="headerlink" title="notebook 界面组成"></a>notebook 界面组成</h2><ol><li>notebook 的名称</li><li>主工具栏，提供了保存、导出、重载 notebook，以及重启内核等选项</li><li>快捷键</li><li>notebook 主要区域，包含了 notebook 的内容编辑区</li></ol><h2 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h2><p>Command mode 和 Edit mode。 在一个cell中，按下Enter,进入Edit模式，按下Esc,进入Command 模式</p><p>运行当前cell，并移动到下一个Cell<br>在一个cell中（在command模式下）,  Shift + Enter  </p><h2 id="创建Cell"><a href="#创建Cell" class="headerlink" title="创建Cell"></a>创建Cell</h2><p>在一个cell中（在command模式下）</p><ol><li>按下 a ,即可在这个cell之前创建一个新的cell；</li><li>按下 b,即可在这个cell之后创建一个新的cell;</li></ol><h2 id="Cell中-Code-和-Markdown的切换"><a href="#Cell中-Code-和-Markdown的切换" class="headerlink" title="Cell中 Code 和 Markdown的切换"></a>Cell中 Code 和 Markdown的切换</h2><p>在一个cell中（在command模式下）</p><ol><li>按下y, 进入Code;</li><li>按下m, 进入Markdown;</li></ol><h2 id="显示Cell中的行数"><a href="#显示Cell中的行数" class="headerlink" title="显示Cell中的行数"></a>显示Cell中的行数</h2><p>在一个cell中（在command模式下），按下 l</p><h2 id="删除Cell"><a href="#删除Cell" class="headerlink" title="删除Cell"></a>删除Cell</h2><p>在一个cell中（在command模式下）, 按两次d</p><h2 id="保存Notebook"><a href="#保存Notebook" class="headerlink" title="保存Notebook"></a>保存Notebook</h2><p>在一个cell中（在command模式下）, 按下s</p><h2 id="启动命令面板"><a href="#启动命令面板" class="headerlink" title="启动命令面板"></a>启动命令面板</h2><p>在一个cell中（在command模式下）, 按下 Ctrl + Shift + P<br>界面中的小键盘图标也可以启动。</p><p>可以通过这个命令面板快速的执行命令。比如我这里将一个cell移动到它下一个cell的下面：在一个cell中（在command模式下），然后按下 Ctrl + Shift + P ，输入 move ，键盘方向键选择要执行的命令即可，然后按下回车即可执行。</p><h2 id="Matplotlib-集成"><a href="#Matplotlib-集成" class="headerlink" title="Matplotlib 集成"></a>Matplotlib 集成</h2><p>如果你用 Python 绘制过图形，那你肯定知道 matplotlib。Matplotlib 是一个用于创建漂亮图形的 Python 库，结合 Jupyter notebook 使用时体验更佳。</p><p>要想在 Jupyter notebook 中使用 matplotlib，需要告诉 Jupyter 获取 matplotlib 生成的所有图形，并将其嵌入 notebook 中。为此，需要计算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure></p><p>译注：要想执行成功，需要先<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install matplotlib。</span><br></pre></td></tr></table></figure></p><p>运行这个指令可能要花个几秒钟，但是在 notebook 中需要执行一次即可。接下来，我们来绘制一个图形，看看具体的集成效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">x = np.arange(20)</span><br><span class="line">y = x**2</span><br><span class="line"></span><br><span class="line">plt.plot(x, y)</span><br></pre></td></tr></table></figure><p>上面的代码将绘制方程式 y=x^2 。计算单元格后，会得到如下图形：<br><img src="https://www.packtpub.com/sites/default/files/new_blog_images/Extra_Blogs/Jupyter_01_11.png" alt="此处输入图片的描述"></p><h2 id="终极奥义"><a href="#终极奥义" class="headerlink" title="终极奥义"></a><font color="red">终极奥义</font></h2><p>按下键盘的 h。查看所有快捷键~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;：简单总结Jupyter Notebook的教程,方便以后使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://qiot.qnap.com/blog/wp-content/uploads/2018/08/JupyterHub-2.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Guidances" scheme="https://yoursite.com/categories/Guidances/"/>
    
    
      <category term="python" scheme="https://yoursite.com/tags/python/"/>
    
      <category term="jupyter notebook" scheme="https://yoursite.com/tags/jupyter-notebook/"/>
    
  </entry>
  
  <entry>
    <title>Donkeycar教程</title>
    <link href="https://yoursite.com/2018/07/13/Donkeycar%E6%95%99%E7%A8%8B/"/>
    <id>https://yoursite.com/2018/07/13/Donkeycar教程/</id>
    <published>2018-07-13T06:44:00.000Z</published>
    <updated>2019-03-14T03:01:06.601Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong>本教程是基于Donkeycar的智能小车教程。DonkeyCar小车是基于树莓派和Python，利用Keras深度学习框架实现的自动驾驶小车。</p><p><img src="https://ss0.baidu.com/73F1bjeh1BF3odCf/it/u=2559738123,4256387987&amp;fm=85&amp;s=752AB952CCB777A7958C48AE03007022" alt="此处输入图片的描述"></p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><font color="red">简介</font></h2><p>本教程是基于Donkeycar的智能小车教程。DonkeyCar小车是基于树莓派和Python，利用Keras深度学习框架实现的自动驾驶小车。<br>本文档参考和整合<a href="https://docs.donkeycar.com/" target="_blank" rel="noopener">Donkeycar文档</a>和<a href="https://www.ncnynl.com/archives/201804/2398.html" target="_blank" rel="noopener">创客智造</a>的中英文教程，以及安装可能碰到的问题，以“HSP无限94186 ——1比16有刷无控车型”为模型作详细演示，从硬件，软件，系统整合，模型修改等方面介绍Donkeycar智能小车的实现。<br><strong>整体框架：</strong><br><img src="https://s1.ax1x.com/2018/07/15/PMHIqf.png" alt="此处输入图片的描述"><br>1)    Vehicle - a container class to hold and manage all aspects of the vehicle.<br>2)    Parts - modular components of the vehicle that read/write to the memory. This includes sensors, actuators, remote controlers and a datastore.<br>3)    Memory - holds the state of the vehicle and is used to pass variables between parts.<br>4)    Drive loop - a function of the vehicle that runs ensures each part interacts with the memory.</p><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a><font color="red">硬件</font></h2><h3 id="硬件清单"><a href="#硬件清单" class="headerlink" title="硬件清单"></a>硬件清单</h3><h4 id="配件明细"><a href="#配件明细" class="headerlink" title="配件明细"></a>配件明细</h4><h5 id="模型要求："><a href="#模型要求：" class="headerlink" title="模型要求："></a>模型要求：</h5><p>我们需要选择：<br>①独立ESC（电子调速器）和接收机的RC小车<br>②选择三线连接器，三线舵机<br>③选择速度更慢的有刷小车模型更容易实现。</p><h5 id="推荐配置参考："><a href="#推荐配置参考：" class="headerlink" title="推荐配置参考："></a>推荐配置参考：</h5><p>1:16模型配置<br><img src="https://s1.ax1x.com/2018/07/15/PMH7dS.png" alt="此处输入图片的描述"></p><p>1:10模型配置<br><img src="https://s1.ax1x.com/2018/07/15/PMHHIg.png" alt="此处输入图片的描述"><br>参数解释：<br>motor是电机的参数，2040就是表示定子外径是20mm，定子高度是40mm，定子的外径和高度越多，定子的铁芯越大，线圈绕的匝数也越多，表现出来就是电机的功率越大。<br>无刷电机KV值定义为转速/V，意思为输入电压增加1伏特(V)，无刷电机空转转速（转/分钟）增加的转速值。<br>ESC的25A是指持续电流25A，这个峰值电流是85A，BEC输出5V，1A。<br>Tcaction：四驱，双差速器。<br>Groung Clearance：小车底部离地面的距离。</p><h5 id="购买配置清单（价格仅供参考，更新于2018-7-3）"><a href="#购买配置清单（价格仅供参考，更新于2018-7-3）" class="headerlink" title="购买配置清单（价格仅供参考，更新于2018-7-3）"></a>购买配置清单（价格仅供参考，更新于2018-7-3）</h5><table><thead><tr><th>名称</th><th style="text-align:center">淘宝地址</th><th style="text-align:center">价格（税点费+邮费）/元</th><th style="text-align:right">备注</th></tr></thead><tbody><tr><td>小车主体</td><td style="text-align:center"><a href="https://item.taobao.com/item.htm?spm=a1z10.1-c.w4004-10687857697.2.14566a1aBpsYGj&amp;id=524795742343" target="_blank" rel="noopener">https://item.taobao.com/item.htm?spm=a1z10.1-c.w4004-10687857697.2.14566a1aBpsYGj&amp;id=524795742343</a></td><td style="text-align:center">329.8(+20)</td><td style="text-align:right">无限94182——1比16有刷无控车架（有刷不要遥控）电调（已包含）舵机（已包含）</td></tr><tr><td>USB电池</td><td style="text-align:center"><a href="https://detail.tmall.com/item.htm?spm=a230r.1.14.9.2c9e646ctC49zM&amp;id=564303977283&amp;cm_id=140105335569ed55e27b&amp;abbucket=13&amp;skuId=3563362700791" target="_blank" rel="noopener">https://detail.tmall.com/item.htm?spm=a230r.1.14.9.2c9e646ctC49zM&amp;id=564303977283&amp;cm_id=140105335569ed55e27b&amp;abbucket=13&amp;skuId=3563362700791</a></td><td style="text-align:center">49(0.2)</td><td style="text-align:right">2A 5V输出，小米充电宝</td></tr><tr><td>树莓派3B+</td><td style="text-align:center"><a href="https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-14802299686.14.485c40da2EhCk5&amp;id=527630316715" target="_blank" rel="noopener">https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-14802299686.14.485c40da2EhCk5&amp;id=527630316715</a></td><td style="text-align:center">354(21.64)</td><td style="text-align:right">3B E14中国版  套餐16G，包括SD卡及配件</td></tr><tr><td>广角摄像头</td><td style="text-align:center"><a href="https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-14802299686.26.54ba6ae1HJKd7d&amp;id=537191521576" target="_blank" rel="noopener">https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-14802299686.26.54ba6ae1HJKd7d&amp;id=537191521576</a></td><td style="text-align:center">100(6.72)</td><td style="text-align:right">树莓派摄像头5MP</td></tr><tr><td>树莓派杜邦线</td><td style="text-align:center"><a href="https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-14802299686.23.2fd00909E38MRt&amp;id=18189793269" target="_blank" rel="noopener">https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-14802299686.23.2fd00909E38MRt&amp;id=18189793269</a></td><td style="text-align:center">2</td><td style="text-align:right">树莓派连接线</td></tr><tr><td>电机驱动芯片 PCA 9685</td><td style="text-align:center"><a href="https://detail.tmall.com/item.htm?spm=a230r.1.14.1.3bc5178b59bMmJ&amp;id=538283746663&amp;cm_id=140105335569ed55e27b&amp;abbucket=1" target="_blank" rel="noopener">https://detail.tmall.com/item.htm?spm=a230r.1.14.1.3bc5178b59bMmJ&amp;id=538283746663&amp;cm_id=140105335569ed55e27b&amp;abbucket=1</a></td><td style="text-align:center">15(+5.4)</td><td style="text-align:right">资料下载<a href="https://pan.baidu.com/s/1miRuKti" target="_blank" rel="noopener">https://pan.baidu.com/s/1miRuKti</a></td></tr><tr><td>3D打印架</td><td style="text-align:center">CAD Files: a360.co/2pf3Dam STL Files: thingiverse.com/thing:2260575</td><td style="text-align:center">x</td><td style="text-align:right">需要3D打印机</td></tr></tbody></table><h4 id="配件介绍"><a href="#配件介绍" class="headerlink" title="配件介绍"></a>配件介绍</h4><h5 id="HSP无限94182"><a href="#HSP无限94182" class="headerlink" title="HSP无限94182"></a>HSP无限94182</h5><p>模型参数：<br><img src="https://img.alicdn.com/imgextra/i4/13651274/TB2OMaChVXXXXbbXXXXXXXXXXXX_!!13651274.jpg" alt="此处输入图片的描述"><br>模型结构：<br> <img src="https://img.alicdn.com/imgextra/i3/13651274/TB2CqaihVXXXXbwXpXXXXXXXXXX_!!13651274.jpg" alt="此处输入图片的描述"></p><h5 id="电调（Electronic-Speed-Control，ESC）"><a href="#电调（Electronic-Speed-Control，ESC）" class="headerlink" title="电调（Electronic Speed Control，ESC）"></a>电调（Electronic Speed Control，ESC）</h5><p>电子调速器，主要有两个作用，一是将电池降压，适合接收机和其他舵机的工作电压；二是从接收机获得油门信号，控制马达的转速，从而改变飞机的速度。<br>❤连接方式为：<br>1、电调的输入线与电池连接；<br>2、电调的输出线（有刷两根、无刷三根）与电机连接；（在我们用到的有刷模型中，是红色和黑色的两根比较粗的线）<br>3、电调的信号线（三根红色，白色和黑色的较细的线）与接收机（PCA驱动芯片）连接。</p><h5 id="舵机"><a href="#舵机" class="headerlink" title="舵机"></a>舵机</h5><p>舵机的工作原理：舵机常用的控制信号是一个周期为20毫秒左右，宽度为1毫秒到2毫秒的脉冲信号。当舵机收到该信号后，会马上激发出一个与之相同的，宽度为1.5毫秒的负向标准的中位脉冲。之后二个脉冲在一个加法器中进行相加得到了所谓的差值脉冲。输入信号脉冲如果宽于负向的标准脉冲，得到的就是正的差值脉冲。如果输入脉冲比标准脉冲窄，相加后得到的肯定是负的脉冲。此差值脉冲放大后就是驱动舵机正反转动的动力信号。舵机电机的转动，通过齿轮组减速后，同时驱动转盘和标准脉冲宽度调节电位器转动。直到标准脉冲与输入脉冲宽度完全相同时，差值脉冲消失时才会停止转动。<br>❤连接方式：将输出的三线与对应的PCA驱动板引脚连接。电调和舵机都是标准3线母插头连接只要按照对应的引脚插入驱动板就可以了。(地线一般为黑色或棕色、信号线一般为黄色或白色)。</p><h5 id="树莓派-miscro-SD存储卡："><a href="#树莓派-miscro-SD存储卡：" class="headerlink" title="树莓派+miscro SD存储卡："></a>树莓派+miscro SD存储卡：</h5><p>Raspberry Pi(中文名为“树莓派”,简写为RPi，(或者RasPi / RPI) <a href="https://docs.donkeycar.com/" target="_blank" rel="noopener">1</a>  是为学习计算机编程教育而设计，只有信用卡大小的微型电脑，其系统基于Linux。<br>关于树莓派的详细教程参考<a href="https://img.alicdn.com/imgextra/i4/13651274/TB2OMaChVXXXXbbXXXXXXXXXXXX_!!13651274.jpg" target="_blank" rel="noopener">7</a>。<br>Raspberry Pi 3B+主板图解：<br><img src="https://s1.ax1x.com/2018/07/15/PMHqiQ.png" alt="此处输入图片的描述"><br>树莓派主板图解<br><img src="https://s1.ax1x.com/2018/07/15/PMHORs.jpg" alt="此处输入图片的描述"></p><p>树莓派引脚GPIO定义<br>❤连接方式：<br>1、USB电源接口接入充电宝电源<br>2、摄像头接口连接摄像头<br>3、树莓派和PCA9685连接：只连四根线，3.3v，两根 I2C 引脚 (SDA 和 SCL)，地线 ground。</p><h5 id="PCA电机驱动芯片9685（舵机驱动板）"><a href="#PCA电机驱动芯片9685（舵机驱动板）" class="headerlink" title="PCA电机驱动芯片9685（舵机驱动板）"></a>PCA电机驱动芯片9685（舵机驱动板）</h5><p>资料下载：<a href="https://pan.baidu.com/s/1miRuKti" target="_blank" rel="noopener">https://pan.baidu.com/s/1miRuKti</a><br>详细教程参考<a href="https://s1.ax1x.com/2018/07/15/PMHqiQ.png" target="_blank" rel="noopener">9</a>。</p><p>PCA9685是一款基于IIC总线通信的12位精度16通道PWM波输出的芯片, 可用于控制舵机、led、电机等设备，i2c通信，节省主机资源。<br>❤连接和使用方式：<br>1、    连接树莓派：<br>GND -&gt; RPi GND（9脚）<br>SCL -&gt; RPi SCL1（5脚）<br>SDA -&gt; RPi SDA1（3脚）<br>VCC -&gt; RPi 3.3V （1脚）<br>V+ -&gt; RPi 5V（本实验中PCA上的V+接口不需要接入电源）</p><p>树莓派和PCA9685连接图<br><img src="https://s1.ax1x.com/2018/07/15/PMHXzn.png" alt="此处输入图片的描述"><br>2、    连接舵机和电调：电调和舵机都是标准3线母插头连接只要按照对应的引脚插入驱动板就可以了。(地线一般为黑色或棕色、信号线一般为黄色或白色，所以对应黑色的线要插在GND对应的针头)。</p><p>PCA9685连接图<br>在上图中，两股标准3线母插头分别连接舵机与电调。</p><h5 id="广角摄像头"><a href="#广角摄像头" class="headerlink" title="广角摄像头"></a>广角摄像头</h5><p>WARNING：不要在树莓派开机时插拔摄像头！<br>摄像头需要满足的参数：<br><img src="https://s1.ax1x.com/2018/07/15/PMHvMq.png" alt="此处输入图片的描述"><br>购买的Camera 5MP广角摄像头参数：<br><img src="https://s1.ax1x.com/2018/07/15/PMHxs0.png" alt="此处输入图片的描述"></p><h5 id="充电宝"><a href="#充电宝" class="headerlink" title="充电宝"></a>充电宝</h5><p>提供5v2A的usb输出和12V输出，主要给树莓派供电<br>❤连接方式：将充电宝的输出microusb输出连接到树莓派的电源输入端。</p><h5 id="3D打印架"><a href="#3D打印架" class="headerlink" title="3D打印架"></a>3D打印架</h5><p><img src="https://s1.ax1x.com/2018/07/15/PMHzLV.png" alt="此处输入图片的描述"><br>❤用螺丝和销钉固定在小车车架上。</p><h5 id="杜邦线"><a href="#杜邦线" class="headerlink" title="杜邦线"></a>杜邦线</h5><p>杜邦线可用于实验板的引脚扩展，增加实验项目等。可以非常牢靠地和插针连接,无需焊接,可以快速进行电路试验。<br>本实验中，用来连接树莓派与PCA驱动芯片的对应引脚。<br><img src="https://s1.ax1x.com/2018/07/15/PMbpZT.jpg" alt="此处输入图片的描述"></p><h3 id="硬件组装"><a href="#硬件组装" class="headerlink" title="硬件组装"></a>硬件组装</h3><h4 id="组装流程"><a href="#组装流程" class="headerlink" title="组装流程"></a>组装流程</h4><p>1)，2)两步为3D打印步骤，如果不适用3D打印，可以用纸板和小刀手工完成顶部结构。<br>1)    打印部件（3D打印）<br>用黑色PLA打印零件，层高2毫米，没有支撑。顶部翻转杆设计成倒置打印。<br>用黑色PLA打印零件，0.3mm层高，一个0.5mm喷嘴，没有支撑。顶部翻转杆设计成倒置打印。<br>打印的结构图：<br><img src="https://s1.ax1x.com/2018/07/15/PMHzLV.png" alt="此处输入图片的描述"><br>2)    清理零件（手工修正）<br>几乎所有3D打印部件都需要清理。重新钻孔，并清理多余的塑料。</p><p><img src="http://images.ncnynl.com/ros/2018/hardware_ass_2a.png" alt="此处输入图片的描述"><br><img src="http://images.ncnynl.com/ros/2018/hardware_ass_2b.png" alt="此处输入图片的描述"></p><p>3)    组装顶板结构，树莓派电源充电宝<br>顶部结构手工完成后的图片：</p><p>4)    将PCA驱动板连接到树莓派<br>利用杜邦线连接，对应的针脚如下：<br>GND -&gt; RPi GND（9脚）<br>SCL -&gt; RPi SCL1（5脚）<br>SDA -&gt; RPi SDA1（3脚）<br>VCC -&gt; RPi 3.3V （1脚）<br>V+ -&gt; RPi 5V（本实验中PCA上的V+接口不需要接入电源）<br>本实验只需要连接四个针脚即可。</p><p>5)    将树莓派和PCA驱动板附加到3D打印的底板上。</p><p>6)    安装摄像头<br>使用摄像头前，取下相机镜头上的塑料薄膜。<br>安装方式：将树莓派上摄像头插销扒开，插入相机电缆，注意触点的位置，随后按入插销即可。<br><img src="http://images.ncnynl.com/ros/2018/hardware_ass_6a.png" alt="此处输入图片的描述"><br><img src="http://images.ncnynl.com/ros/2018/hardware_ass_6b.png" alt="此处输入图片的描述"></p><p>7)    硬件整合<br>舵机与电调已经在小车上固定好，所以接下来只需用三线母插头把PCA驱动板连接舵机与电调。因为电调和舵机都是标准3线母插头连接只要按照对应的引脚插入驱动板就好。(地线一般为黑色或棕色、信号线一般为黄色或白色，所以对应黑色的线要插在GND对应的针头)。</p><h4 id="组装完成"><a href="#组装完成" class="headerlink" title="组装完成"></a>组装完成</h4><p>几种不同形态智能小车的完成体：<br><img src="http://images.ncnynl.com/ros/2018/donkey.png" alt="此处输入图片的描述"><br><img src="https://s1.ax1x.com/2018/07/15/PMb9dU.jpg" alt="此处输入图片的描述"><br><img src="https://s1.ax1x.com/2018/07/15/PMbCoF.jpg" alt="此处输入图片的描述"></p><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a><font color="red">软件</font></h2><h3 id="软件清单"><a href="#软件清单" class="headerlink" title="软件清单"></a>软件清单</h3><p>❤系统：<br>树莓派系统<br>Ubuntu系统<br>❤在linux下安装donkeycar<br>安装依赖：virtualenv build-essential python3-dev gfortran libhdf5-dev<br><a href="https://github.com/wroscoe/donkey" target="_blank" rel="noopener">https://github.com/wroscoe/donkey</a><br>❤在Windows下安装donkeycar<br><a href="https://conda.io/miniconda.html" target="_blank" rel="noopener">https://conda.io/miniconda.html</a><br><a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a><br>git库<a href="https://github.com/wroscoe/donkey" target="_blank" rel="noopener">https://github.com/wroscoe/donkey</a><br>❤在MAC下安装donkeycar<br><a href="https://conda.io/miniconda.html" target="_blank" rel="noopener">https://conda.io/miniconda.html</a><br><a href="https://www.atlassian.com/git/tutorials/install-git" target="_blank" rel="noopener">https://www.atlassian.com/git/tutorials/install-git</a><br>xcode-select –install<br>pip install <a href="https://storage.googleapis.com/tensorflow/mac/cpu/tensorflow-1.3.0-py3-none-any.whl" target="_blank" rel="noopener">https://storage.googleapis.com/tensorflow/mac/cpu/tensorflow-1.3.0-py3-none-any.whl</a><br>开源机器学习框架：<br>❤pip install keras==2.0.6<br>❤pip install tensorflow==1.3.0</p><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><h4 id="安装树莓派系统"><a href="#安装树莓派系统" class="headerlink" title="安装树莓派系统"></a>安装树莓派系统</h4><p>将SD卡用读卡器连接到本地PC。<br>首先为树莓派安装固件，下载地址：<br><a href="https://www.dropbox.com/s/wiudnm2dcsvoquu/donkey_v22.img.zip?dl=0" target="_blank" rel="noopener">https://www.dropbox.com/s/wiudnm2dcsvoquu/donkey_v22.img.zip?dl=0</a><br>安装步骤：<br>方法1：使用<a href="https://s1.ax1x.com/2018/07/15/PMHHIg.png" target="_blank" rel="noopener">6</a>中的推荐步骤<br><img src="https://s1.ax1x.com/2018/07/15/PMbFJJ.png" alt="此处输入图片的描述"><br>方法2：利用安装软件Etcher。<br>    安装方法参考教程<a href="https://bbs.pediy.com/thread-221193.htm" target="_blank" rel="noopener">（For ubuntu）</a>,<a href="http://www.xue51.com/soft/2044.html" target="_blank" rel="noopener">（For windows）</a>。</p><h4 id="设置wifi连接"><a href="#设置wifi连接" class="headerlink" title="设置wifi连接"></a>设置wifi连接</h4><p>我们需要让树莓派连接wifi热点，从而可以无线操控小车。方法有两种：<br>方法1：SD卡插入树莓派，显示屏，键盘和鼠标连入树莓派，开机后通过界面链接wifi。<br>方法2：（没有显示屏和键鼠条件下）<br>首先，新建一个无线热点。可以使用本地PC新建wifi热点。记录ssid和password。<br>接下来修改树莓派的系统文件：<br>在boot部分的根目录下，新建文件名为wpa_supplicant.conf的文件，文件内容为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">country=US</span><br><span class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line">update_config=1</span><br><span class="line">network=&#123;</span><br><span class="line">   ssid=&quot;&lt;your network name&gt;&quot;</span><br><span class="line">    psk=&quot;&lt;your password&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分别在ssid和psk设置自己的WiFi用户名和密码，注意不能有&lt;&gt;，</p><h4 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h4><p>如果网络中有多个树莓派，还需要修改本树莓派的用户名,以下命令需要将sd卡挂载到Linux上运行，由于创建本文档时只有一个树莓派，所以并没有修改用户名，本文档的所有用户名均为pi，若读者对树莓派的用户名有修改，登录时需要改成自己的用户名和密码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /media/userID/UUID/etc/hostname</span><br><span class="line">sudo vi /media/userID/UUID/etc/hosts</span><br></pre></td></tr></table></figure></p><p>注意用户名只能是小写。<br>然后把SD卡插进树莓派里，给树莓派上电。</p><h4 id="设置SSH远程登录"><a href="#设置SSH远程登录" class="headerlink" title="设置SSH远程登录"></a>设置SSH远程登录</h4><p>首先查看网络环境，树莓派连接的网络是本地连接13创建的共享热点：<br><img src="https://s1.ax1x.com/2018/07/15/PMbudO.png" alt="此处输入图片的描述"><br>用抓包工具或者nmap扫描工具查找树莓派的ip地址：<br><img src="https://s1.ax1x.com/2018/07/15/PMbAzR.png" alt="此处输入图片的描述"><br>或者可以用cmd自带的ARP命令查看相应地址的ARP缓存也可以找到小车地址，arp -a<br>从上图可以找到树莓派的ip地址是192.168.155.2，接着通过ssh登录树莓派，用户名pi,密码asdfasdf ，登录进去之后界面如图所示：<br><img src="https://s1.ax1x.com/2018/07/15/PMbZsx.png" alt="此处输入图片的描述"><br>另外，可以通过win10自带的移动热点看到连接设备的IP地址：<br><img src="https://s1.ax1x.com/2018/07/15/PMbeL6.png" alt="此处输入图片的描述"><br>推荐使用的ssh客户端登录软件比如Xshell。</p><h4 id="在树莓派镜像安装，升级donkeycar"><a href="#在树莓派镜像安装，升级donkeycar" class="headerlink" title="在树莓派镜像安装，升级donkeycar"></a>在树莓派镜像安装，升级donkeycar</h4><p>存储卡图像上的donkeycar Python代码可能比Github repo上的要早，所以一旦你运行了Pi，需要更新，在ssh客户端连接树莓派后，键入命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/donkeycar</span><br><span class="line">git pull</span><br><span class="line">pip install -e .</span><br></pre></td></tr></table></figure></p><h4 id="在本地PC安装donkeycar并创建本地工作目录"><a href="#在本地PC安装donkeycar并创建本地工作目录" class="headerlink" title="在本地PC安装donkeycar并创建本地工作目录"></a>在本地PC安装donkeycar并创建本地工作目录</h4><p>接下来是在本地笔记本电脑或服务器上设置相同的代码库，以便测试和训练智能小车。安装因平台而异。有如下三种方法，仅给出了windows上的安装结果。</p><h5 id="Windows系统"><a href="#Windows系统" class="headerlink" title="Windows系统"></a>Windows系统</h5><p>❤安装miniconda Python 3.6 64 bit. <a href="https://conda.io/miniconda.html" target="_blank" rel="noopener">https://conda.io/miniconda.html</a><br>❤确保选中该框以允许它修改您的系统路径变量以添加conda。<br>❤安装git 64 bit，<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a><br>❤从开始菜单启动Anaconda<br>❤更改为您希望用作项目主管的目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir projects</span><br><span class="line">cd projects</span><br></pre></td></tr></table></figure></p><p>❤安装donkeycar<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/wroscoe/donkey</span><br><span class="line">cd donkey</span><br></pre></td></tr></table></figure></p><p>❤创建Python Anaconda环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda env create -n donkeycar -f install\envs\windows.yml</span><br><span class="line">activate donkey</span><br></pre></td></tr></table></figure></p><p>❤安装代码源并创建您的本地工作目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install -e .</span><br><span class="line">donkey createcar --path ~/d2 #本地工作目录名称设置为d2，可以自己定义</span><br></pre></td></tr></table></figure></p><p>安装结果：<br><img src="https://s1.ax1x.com/2018/07/15/PMbkW9.png" alt="此处输入图片的描述"><br>注意：在关闭Anaconda提示符后，当再次打开它时，您需要键入activate donkey以重新启用映射到特定于donkey的Python库。（关于anaconda的使用，可以参考<a href="https://s1.ax1x.com/2018/07/15/PMHORs.jpg" target="_blank" rel="noopener">10</a>）<br>项目主管目录示例：<br><img src="https://s1.ax1x.com/2018/07/15/PMbVQ1.png" alt="此处输入图片的描述"><br>创建的本地工作目录示例：<br><img src="https://s1.ax1x.com/2018/07/15/PMbneK.png" alt="此处输入图片的描述"></p><h5 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h5><p>❤安装依赖和python环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install virtualenv build-essential python3-dev gfortran libhdf5-dev</span><br><span class="line">virtualenv env -p python3</span><br><span class="line">source env/bin/activate</span><br><span class="line">pip install keras==2.0.6</span><br><span class="line">pip install tensorflow==1.3.0</span><br></pre></td></tr></table></figure></p><p>❤安装donkeycar<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/wroscoe/donkey donkeycar</span><br><span class="line">pip install -e donkeycar</span><br></pre></td></tr></table></figure></p><h5 id="Mac系统"><a href="#Mac系统" class="headerlink" title="Mac系统"></a>Mac系统</h5><p>❤安装miniconda Python 3.6 64 bit. <a href="https://conda.io/miniconda.html" target="_blank" rel="noopener">https://conda.io/miniconda.html</a><br>❤安装git 64 bit，<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a><br>❤启动终端<br>❤如果Xcode or gcc 没安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure></p><p>❤创建项目根目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir projects</span><br><span class="line">cd projects</span><br></pre></td></tr></table></figure></p><p>❤下载donkeycar<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/wroscoe/donkey</span><br><span class="line">cd donkey</span><br></pre></td></tr></table></figure></p><p>❤创建Python Anaconda环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda env create -f envs/mac.yml</span><br><span class="line">source activate donkey</span><br></pre></td></tr></table></figure></p><p>❤安装Tensorflow<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install https://storage.googleapis.com/tensorflow/mac/cpu/tensorflow-1.3.0-py3-none-any.whl</span><br></pre></td></tr></table></figure></p><p>❤安装donkey<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install -e .</span><br><span class="line">donkey createcar --path ~/d2</span><br></pre></td></tr></table></figure></p><p>注意：关闭终端后，当您再次打开终端时，您需要键入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source activate donkey</span><br></pre></td></tr></table></figure></p><p>来重新启用映射到特定于donkey的Python库。</p><h2 id="运行智能小车"><a href="#运行智能小车" class="headerlink" title="运行智能小车"></a><font color="red">运行智能小车</font></h2><p>WARNING：先放置到安全地方并让轮子离地！</p><h3 id="Windows系统-1"><a href="#Windows系统-1" class="headerlink" title="Windows系统"></a>Windows系统</h3><p>-打开Anaconda<br>-激活映射到donkey的Python设置：<br><figure class="highlight plain"><figcaption><span>donkey</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">-进入管理donkey的本地目录：</span><br><span class="line">```cd ~/d2</span><br></pre></td></tr></table></figure></p><h3 id="远程登录树莓派"><a href="#远程登录树莓派" class="headerlink" title="远程登录树莓派"></a>远程登录树莓派</h3><p>-用Xshell登录，详细见3.2.4节。</p><h3 id="启动和控制小车"><a href="#启动和控制小车" class="headerlink" title="启动和控制小车"></a>启动和控制小车</h3><p>-在Xshell连接成功后，打开你小车目录，并开启小车<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/d2</span><br><span class="line">python manage.py drive</span><br></pre></td></tr></table></figure></p><p>-这个脚本将启动你的小车，其中包括一个作为Web服务器的部件，以便控制你的小车。<br>-现在可以通过以下网址从网络浏览器控制您的汽车：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;your car&apos;s IP&apos;s address&gt;:8887</span><br></pre></td></tr></table></figure></p><p>接下来在本地PC通过浏览器（推荐Chrome浏览器）登录上述网址，在web端控制智能小车：<br><img src="https://s1.ax1x.com/2018/07/15/PMbYOP.png" alt="此处输入图片的描述"></p><h3 id="校准小车"><a href="#校准小车" class="headerlink" title="校准小车"></a>校准小车</h3><p>小车的配置信息是存在config.py脚本中的，这个脚本会在运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">donkey createcar --path ~/d2</span><br></pre></td></tr></table></figure></p><p>这个命令之后出现在”./d2”这个目录下，如下所示：<br><img src="https://s1.ax1x.com/2018/07/15/PMbwFg.png" alt="此处输入图片的描述"><br>其内容是各个部件的参数配置：<br><img src="https://s1.ax1x.com/2018/07/15/PMb8SA.png" alt="此处输入图片的描述"><br>校准小车的目的就是将上述参数调整到合适的值，这样才能顺利的驾驶小车，以及共享同款小车的校准数据。</p><h4 id="舵机校准（转向校准）"><a href="#舵机校准（转向校准）" class="headerlink" title="舵机校准（转向校准）"></a>舵机校准（转向校准）</h4><p>要填的数据有：<br><img src="https://s1.ax1x.com/2018/07/15/PMbJyt.png" alt="此处输入图片的描述"><br>注意，此时应让小车离开地面，避免乱跑<br>1、    打开小车，找到舵机伺服电缆插到了PCA的那个通道上了，应该是1或者0.<br>2、    运行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">donkey calibrate --channel &lt;your_steering_channel&gt;</span><br></pre></td></tr></table></figure></p><p>3、    输入 360’会看到小车的轮子轻微转动，如果没有的话就输入400或者300<br>4、    左右调整 +/- 10，一直到轮子完全转向左边或者右边，记录此时的值，并填入config.py</p><h4 id="马力校准（电机控制）"><a href="#马力校准（电机控制）" class="headerlink" title="马力校准（电机控制）"></a>马力校准（电机控制）</h4><p>需要校准的参数：<br><img src="https://s1.ax1x.com/2018/07/15/PMb0YQ.png" alt="此处输入图片的描述"><br>1、    找到ESC的电缆，看看它插到PCA的哪个位置，这就是马力通道。<br>2、    运行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">donkey calibrate --channel &lt;your_throttle_channel&gt;</span><br></pre></td></tr></table></figure></p><p>当提示输入PWM值的时候输入370，此时应该能听到ESC发出哔哔声，表示已经经过校准。<br>3、    输入400，这时小车应该就能往前走了，如果不能往前，则有可能是反向的，此时应该输入330<br>4、    多尝试几次，直到找到你认为比较合适的最大速度，记下此时的PWM值。</p><h4 id="校准微调"><a href="#校准微调" class="headerlink" title="校准微调"></a>校准微调</h4><p>现在小车已经校准过了，可以开动小车查看是否按照预期运行：<br>1、    运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py drive</span><br></pre></td></tr></table></figure></p><p>命令启动小车<br>2、    在浏览器中访问<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;your_cars_ip_address&gt;:8887</span><br></pre></td></tr></table></figure></p><p>3、    按j，一直到小车的方向完全转向右边<br>4、    按i，一直到小车的方向完全朝向前方<br>5、    测量转弯直径，并将它记录在表格中<br>6、    在不同的转向值下重复同样的测量<br>7、    绘制表格看看小车在各个方向的转向是否相同（角度相同时）<br>如果你的转向在80%PWM和100%PWM相同时，将PWM值变为80%PWM,<br>如果你的车往一边偏，改变另一边的PWM值<br>经过微调之后你的表格大概会是这个样子<br><img src="https://s1.ax1x.com/2018/07/15/PMbUw8.png" alt="此处输入图片的描述"></p><h2 id="训练智能小车"><a href="#训练智能小车" class="headerlink" title="训练智能小车"></a><font color="red">训练智能小车</font></h2><h3 id="赛道设置"><a href="#赛道设置" class="headerlink" title="赛道设置"></a>赛道设置</h3><p>可以用带颜色的胶带、丝带或者绳子，赛道最好宽4英尺，并且有2英寸的白色边框和黄色虚线中线。</p><h3 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h3><p>①    先不记录数据，在跑道上跑几圈，当熟练跑道之后（10圈以上不出错）点击按钮Start Recording<br><img src="https://s1.ax1x.com/2018/07/15/PMbBWj.png" alt="此处输入图片的描述"><br>②    如果出错或者有意外发生时马上点击Stop Car停止记录<br>③    至少收集10-20圈好的数据之后即可以停止收集，Ctrl-c即可，收集的数据在data文件夹里</p><p>需要注意的细节：<br>1，    清除d2/data目录下的之前的数据<br>2，    回到d2目录下 python namage.py drive启动小车<br>3，    到浏览器中model选择user，然后用电脑控制小车在场景下跑几圈<br>4，    等到操作小车在场景下基本不出错之后点击start recording开始记录数据<br>5，    记录大约半个小时的数据就可以了<br>注意在记录数据的过程中，可能会出现小车没电的情况，解决的办法就是，刚开始在config.py文件中把THROTTLE_FORWARD_PWM设置的小一点，本车是335或者330，过一会感觉小车跑的变慢了，停止记录，停下小车，关闭程序。调整THROTTLE_FORWARD_PWM变大一点到440，重启程序，记得保持小车的运行速度以及Throttle差不多一致。同理慢慢可以变为445和450<br>6，    记录完数据，筛选数据。手动删除数据中撞墙等不好的数据<br>7，    将数据考到电脑上装的donkey的d2/data目录下（小文件太多，速度会特别慢）<br>8，    进入d2目录，运行命令 python manage.py train –model ~/d2/models/mypilot<br>9，    等待训练结束，到到d2/models下将mypilot文件发送到小车的对应目录下<br>10，    用命令python manage.py drive –model ~/d2/models/mypilot启动小车，然后到浏览器中选择local pilot模式启动自动驾驶</p><h3 id="拷贝数据至本地PC"><a href="#拷贝数据至本地PC" class="headerlink" title="拷贝数据至本地PC"></a>拷贝数据至本地PC</h3><p>由于树莓派计算能力有限，需要将数据迁移到电脑上进行模型的训练，有两种方法：<br>方法1：新开一个SSH窗口用rsync命令从树莓派复制数据。命令如下：<br>rsync -r pi@&lt;your_pi_ip_address&gt;:~/d2/data/  ~/d2/data/<br>方法2：利用Xshell里面的新建文件传输直接复制粘贴。<br><img src="https://s1.ax1x.com/2018/07/15/PMbaTS.md.png" alt="此处输入图片的描述"></p><h3 id="利用keras训练模型"><a href="#利用keras训练模型" class="headerlink" title="利用keras训练模型"></a>利用keras训练模型</h3><p>复制好数据之后就可以运行训练脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python ~/d2/manage.py train --tub &lt;tub folder names comma separated&gt; --model ./models/mypilot</span><br></pre></td></tr></table></figure></p><p>或者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python ~/d2/manage.py train --model ~/d2/models/mypilot</span><br></pre></td></tr></table></figure></p><p><img src="https://s1.ax1x.com/2018/07/15/PMbrSs.png" alt="此处输入图片的描述"></p><h3 id="拷贝模型至树莓派"><a href="#拷贝模型至树莓派" class="headerlink" title="拷贝模型至树莓派"></a>拷贝模型至树莓派</h3><p>训练好之后再讲pilot迁移回树莓派：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -r ~/d2/models/ pi@&lt;your_ip_address&gt;:~/d2/models/</span><br></pre></td></tr></table></figure></p><h3 id="用自动驾驶模型启动小车"><a href="#用自动驾驶模型启动小车" class="headerlink" title="用自动驾驶模型启动小车"></a>用自动驾驶模型启动小车</h3><p>重新启动小车，将训练好的模型穿进去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py drive --model ~/d2/models/mypilot</span><br></pre></td></tr></table></figure></p><h3 id="用模拟器训练小车"><a href="#用模拟器训练小车" class="headerlink" title="用模拟器训练小车*"></a>用模拟器训练小车*</h3><p>用于生成训练用的图片，测试自动驾驶仪等。当然你也可以不用这种方法，根据网页【<a href="http://docs.donkeycar.com/guide/build_hardware/】的描述，你也可以先用手机控制小车在赛道上开10-20次来收集训练数据。" target="_blank" rel="noopener">http://docs.donkeycar.com/guide/build_hardware/】的描述，你也可以先用手机控制小车在赛道上开10-20次来收集训练数据。</a><br>下载之后直接双击EXE文件运行，你可以在input里面看到控制按钮信息。<br><img src="https://s1.ax1x.com/2018/07/15/PMbRTU.png" alt="此处输入图片的描述"><br><img src="https://s1.ax1x.com/2018/07/15/PMb2wT.png" alt="此处输入图片的描述"><br>模拟器中共有三个场景，但是网站【<a href="http://docs.donkeycar.com/guide/simulator/】中只给了前两种的描述，第三种是sparkfun" target="_blank" rel="noopener">http://docs.donkeycar.com/guide/simulator/】中只给了前两种的描述，第三种是sparkfun</a> AVC机器人大赛的场景：<br>Generated Road Scene：通用场景<br>The purpose of this is to create a randomly generated road so that you can have miles of curves on different road surfaces. You can train on one road and test on something similar, or a totally different surface.<br>Warehouse Scene：专用场景<br>The purpose of this is to create a specific track that is somewhat similar to an actual course in use as the primary track for the Oakland DIYRobocars Meetup.<br><img src="https://s1.ax1x.com/2018/07/15/PMbfkF.md.png" alt="此处输入图片的描述"></p><p>进入模拟器，右上角可以选择操作选项，根据网站【<a href="http://docs.donkeycar.com/guide/simulator/】的介绍，Joystick/Keyboard" target="_blank" rel="noopener">http://docs.donkeycar.com/guide/simulator/】的介绍，Joystick/Keyboard</a> No Rec的意思就是摇杆或者键盘控制，但是数据不记录，其他选项意思类推。Next Track：在生成的道路场景中，这将改变路面和轨道宽度。Regen Track：使用当前的表面类型，但生成一个新的随机路径和路径。<br>下图为我用键盘控制时的截图，在网站【<a href="http://docs.donkeycar.com/guide/simulator/】的介绍中，有一个注意事项是这样描述的：Note" target="_blank" rel="noopener">http://docs.donkeycar.com/guide/simulator/】的介绍中，有一个注意事项是这样描述的：Note</a>: Keyboard data produces steering information that is stepped (ie. -1, 0, +1) and may be difficult to train with. See below for joystick setup.大意是说由于键盘控制并不像摇杆可以产生连续的转向信息，而只能是间断的，所以并不适合用来训练。<br><img src="https://s1.ax1x.com/2018/07/15/PMbhY4.png" alt="此处输入图片的描述"><br>键盘控制页面<br>下图为自动驾驶页面，可以看到左下角一共有四个参数，目前并没有搞得很清楚这四个参数的具体含义，暂且先贴出网页【<a href="http://docs.donkeycar.com/guide/simulator/】上的解释：" target="_blank" rel="noopener">http://docs.donkeycar.com/guide/simulator/】上的解释：</a><br>Max Speed：这个应该就是决定了自动驾驶的最大速度<br>This setting determines the target speed during the PID auto drive. It will also affect the speed when driving by keyboard controls (not recommended).<br>Prop：转向角度<br>This is short for proportional. This is the P part of PID that attempts to adjust steering back to the path in proportion to the deviation.<br>Diff：为了防止角度调整过大<br>This is the D part of PID that attempts to limit steering back to the path as derivative to the trend of deviation, designed to limit overshoot.<br>Max Steering<br>Max steering can only be adjusted when using Auto Drive No Rec. It will also affect joystick and keyboard steering range, and should be saved and reloaded for you.<br>另外关于这个参数，原文中有一个注意事项： Max Steering is an important adjustment. This affects categorical training quite strongly. As the steering data is normalized when written, and multiplies after coming from Python, this angle should remain constant over training and simulation. Take care when changing this value. And separate data and models by max steering setting.<br><img src="https://s1.ax1x.com/2018/07/15/PMb4fJ.md.png" alt="此处输入图片的描述"><br>自动驾驶时的截图<br>训练结束后，在log目录中会有训练的图片，图片大小为160*120像素<br><img src="https://s1.ax1x.com/2018/07/15/PMbgmV.md.png" alt="此处输入图片的描述"><br>贴一个网页【<a href="http://docs.donkeycar.com/guide/simulator/】上给出的典型用法，方便以后使用。" target="_blank" rel="noopener">http://docs.donkeycar.com/guide/simulator/】上给出的典型用法，方便以后使用。</a><br><img src="https://s1.ax1x.com/2018/07/15/PMb6O0.png" alt="此处输入图片的描述"></p><h2 id="更新DonkeycarV2-5教程"><a href="#更新DonkeycarV2-5教程" class="headerlink" title="更新DonkeycarV2.5教程"></a>更新DonkeycarV2.5教程</h2><ol><li>用Etcher给SD卡写入树莓派系统<a href="https://drive.google.com/uc?id=1vr4nEXLEh4xByKAXik8KhK3o-XWgo2fQ&amp;export=download" target="_blank" rel="noopener">镜像文件名为：donkey_2.5.0_pi3.img</a>，新建并编辑boot目录下的wpa_supplicant.conf文件。</li><li><p>SSH连接树莓派并登陆。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户名：pi</span><br><span class="line">密码：raspberry</span><br></pre></td></tr></table></figure></li><li><p>在树莓派上安装Donkeycar V2.5.1环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a)pip install donkeycar[pi]</span><br><span class="line">b)donkey createcar ~/</span><br></pre></td></tr></table></figure></li><li><p>在windows上安装DonkeycarV2.5.1<br>（注意区分本地工作目录与本地代码目录）<br>a)    新建一个本地代码目录，存放代码库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir projects</span><br><span class="line">cd projects</span><br></pre></td></tr></table></figure></li></ol><p>b)    从github上clone最新的donkeycar代码库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/wroscoe/donkey</span><br><span class="line">cd donkey</span><br></pre></td></tr></table></figure></p><p>c)    安装donkeycar资源环境，新建本地工作目录（mycar）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install -e .</span><br><span class="line">donkey createcar C:\Users\WuFan\new_mycar(自己修改)</span><br></pre></td></tr></table></figure></p><ol><li>会遇到的问题：<br>a)    ModuleNotFoundError: No module named ‘controller’：<br>解决办法：<br>将文件<br>（可直接复制粘贴word中的这个文件）<br>拷贝至\donkey\donkeycar\parts对应的本地代码目录下。<br>修改本地工作目录中文件“manage.py”中第24行，修改为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from donkeycar.parts.controller import LocalWebController, JoystickController</span><br></pre></td></tr></table></figure></li></ol><p>b)    训练后的数据存放在树莓派tub文件夹下，而不是data</p><p>训练的时候，把tub文件夹下所有数据复制到本地工作目录下的data文件夹下。再开始训练。</p><p>c)  大家在用训练的模型驾驶的时候，切换到local pilot时，可能会遇到类似摄像头框消失，树莓派报错的情况。</p><p>这是因为树莓派上有的python文件版本和本地电脑从github上面clone的文件不一致。如果有报这种错误，可以把本地代码库上面的对应文件覆盖到树莓派上解决。</p><h2 id="参考创新方向"><a href="#参考创新方向" class="headerlink" title="参考创新方向"></a><font color="red">参考创新方向</font></h2><h3 id="无人驾驶车障碍竞速"><a href="#无人驾驶车障碍竞速" class="headerlink" title="无人驾驶车障碍竞速"></a>无人驾驶车障碍竞速</h3><h3 id="无人取件车-送餐车-领路车"><a href="#无人取件车-送餐车-领路车" class="headerlink" title="无人取件车/送餐车/领路车"></a>无人取件车/送餐车/领路车</h3><h3 id="无人捡球车"><a href="#无人捡球车" class="headerlink" title="无人捡球车"></a>无人捡球车</h3><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li style="list-style: none"><input type="checkbox"> <a href="https://docs.donkeycar.com/" target="_blank" rel="noopener">https://docs.donkeycar.com/</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.ncnynl.com/archives/201804/2398.html" target="_blank" rel="noopener">https://www.ncnynl.com/archives/201804/2398.html</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://github.com/OSSDC/donkey" target="_blank" rel="noopener">https://github.com/OSSDC/donkey</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://github.com/wroscoe/donkey\" target="_blank" rel="noopener">https://github.com/wroscoe/donkey\</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://docs.donkeycar.com/guide/build_hardware/" target="_blank" rel="noopener">https://docs.donkeycar.com/guide/build_hardware/</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.donkeycar.com/" target="_blank" rel="noopener">https://www.donkeycar.com/</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.makerspace.cn/thread-5681-1-1.html" target="_blank" rel="noopener">http://www.makerspace.cn/thread-5681-1-1.html</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.raspberrypi.org/blog/self-driving-car/" target="_blank" rel="noopener">https://www.raspberrypi.org/blog/self-driving-car/</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://blog.csdn.net/nicekwell/article/details/53616277" target="_blank" rel="noopener">https://blog.csdn.net/nicekwell/article/details/53616277</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://python.jobbole.com/87522/" target="_blank" rel="noopener">https://python.jobbole.com/87522/</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://bbs.pediy.com/thread-221193.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-221193.htm</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.xue51.com/soft/2044.html" target="_blank" rel="noopener">https://www.xue51.com/soft/2044.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;本教程是基于Donkeycar的智能小车教程。DonkeyCar小车是基于树莓派和Python，利用Keras深度学习框架实现的自动驾驶小车。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ss0.baidu.com/73F1bjeh1BF3odCf/it/u=2559738123,4256387987&amp;amp;fm=85&amp;amp;s=752AB952CCB777A7958C48AE03007022&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Guidances" scheme="https://yoursite.com/categories/Guidances/"/>
    
    
      <category term="donkeycar" scheme="https://yoursite.com/tags/donkeycar/"/>
    
  </entry>
  
  <entry>
    <title>Conda常用命令</title>
    <link href="https://yoursite.com/2018/05/02/Conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://yoursite.com/2018/05/02/Conda常用命令/</id>
    <published>2018-05-02T06:38:20.000Z</published>
    <updated>2018-12-27T03:22:38.972Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong>使用Anaconda管理python各种python环境和库，可以极大提高在不同项目切换的效率。</p><p><img src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=694027017,1634354710&amp;fm=58&amp;bpow=944&amp;bpoh=794" alt="此处输入图片的描述"></p><a id="more"></a><h2 id="帮助与版本"><a href="#帮助与版本" class="headerlink" title="帮助与版本"></a>帮助与版本</h2><ul><li><p>查看当前conda版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda -V</span><br><span class="line">conda -version</span><br></pre></td></tr></table></figure></li><li><p>更新conda</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda update conda</span><br><span class="line">conda update anaconda #更新anaconda</span><br></pre></td></tr></table></figure></li><li><p>某个命令的帮助信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install --help</span><br></pre></td></tr></table></figure></li></ul><h2 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h2><ul><li><p>查看当前环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info -e</span><br></pre></td></tr></table></figure></li><li><p>查看所有环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda info --envs</span><br><span class="line">conda env list</span><br></pre></td></tr></table></figure></li><li><p>创建新的环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">conda create --name environment_name</span><br><span class="line">#创建不同python版本的环境</span><br><span class="line">conda create --name environment_name python=3.6</span><br><span class="line">conda create --name environment_name python=2.7</span><br><span class="line">#创建时添加库的环境</span><br><span class="line">conda create --name environment_name numpy scipy</span><br></pre></td></tr></table></figure></li><li><p>切换环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#切换到新环境</span><br><span class="line">activate environment_name</span><br><span class="line">#在linux于macos系统中，激活环境的命令为：</span><br><span class="line">source active environment_name</span><br><span class="line">#退出环境</span><br><span class="line">deactivate environment_name</span><br></pre></td></tr></table></figure></li><li><p>移除环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#conda remove --name environment_name --all</span><br><span class="line">conda remove -n py36 --all</span><br></pre></td></tr></table></figure></li><li><p>复制某个环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name new_name --clone old_name</span><br></pre></td></tr></table></figure></li><li><p>保存环境配置信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env export &gt; environment.yml</span><br></pre></td></tr></table></figure></li><li><p>读取环境配置信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env create -f environment.yml</span><br></pre></td></tr></table></figure></li></ul><p><strong>Note:</strong> 当遇到错误”SpecNotFound: Can’t process without a name”时，因为导入环境时目录有问题，所以需要检查.yml文件的path是否有误。</p><h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><ul><li><p>列举当前环境下所有包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure></li><li><p>列举某个环境下所有包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list -n environment_name</span><br></pre></td></tr></table></figure></li><li><p>查找某个包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda search package_name</span><br></pre></td></tr></table></figure></li><li><p>为指定环境安装某个包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -n environment_name package_name</span><br></pre></td></tr></table></figure></li><li><p>更新包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update package_name</span><br></pre></td></tr></table></figure></li><li><p>卸载包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove package_name</span><br></pre></td></tr></table></figure></li></ul><h2 id="设置镜像"><a href="#设置镜像" class="headerlink" title="设置镜像"></a>设置镜像</h2><p>访问国外资源网速较低时，可以考虑改变源，使用国内镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;使用Anaconda管理python各种python环境和库，可以极大提高在不同项目切换的效率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=694027017,1634354710&amp;amp;fm=58&amp;amp;bpow=944&amp;amp;bpoh=794&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="https://yoursite.com/categories/Tools/"/>
    
    
      <category term="conda" scheme="https://yoursite.com/tags/conda/"/>
    
      <category term="python" scheme="https://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>对抗攻击防御策略一览</title>
    <link href="https://yoursite.com/2018/04/17/%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E9%98%B2%E5%BE%A1%E7%AD%96%E7%95%A5%E4%B8%80%E8%A7%88/"/>
    <id>https://yoursite.com/2018/04/17/对抗攻击防御策略一览/</id>
    <published>2018-04-17T07:46:27.000Z</published>
    <updated>2018-12-27T03:23:16.794Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要</strong>：根据最近的学习，按照自己的理解给不同对抗攻击的防御方法作简单总结。对抗防御从形式上看可以被分为三类：①对抗样本检测；②改变对抗样本；③增强模型。<br><a id="more"></a></p><hr><h2 id="①对抗样本检测："><a href="#①对抗样本检测：" class="headerlink" title="①对抗样本检测："></a>①对抗样本检测：</h2><p>指根据对抗样本与原始样本的分布差异，在模型Inference阶段将对抗样本区分出来。</p><p>检测对抗样本的方法有：</p><h3 id="1）-基于统计检验的检测（Sample-statistic）："><a href="#1）-基于统计检验的检测（Sample-statistic）：" class="headerlink" title="1）    基于统计检验的检测（Sample statistic）："></a>1）    基于统计检验的检测（Sample statistic）：</h3><p>这种方法比较直接，效果也比较差，并且因为是基于大量对抗样本的统计结论，因此需要大量对抗样本挖掘其统计规律，在检测的时候也不适于检测单个对抗样本。常见的统计检验方法如下：<br><strong>A．    Maximum mean discrepancy and energy distance.</strong><br>【Kathrin Grosse, Praveen Manoharan, Nicolas Papernot, Michael Backes, and Patrick McDaniel. On the (Statistical) Detection of Adversarial Examples. arXiv preprint arXiv:1702.06280, 2017.】<br>    但是这种方法不能对单个样本作出预测，只能揭示对抗样本与原始样本在平均偏差和距离的差异，不具有检测对抗样本的可行性。<br><strong>B．    Kernel density estimation</strong><br>【Reuben Feinman, Ryan R Curtin, Saurabh Shintre, and Andrew B Gardner. Detecting Adversarial Samples from Artifacts. arXiv preprint arXiv:1703.00410, 2017.】<br>这种方法即是在折叠的空间中计算一个测试样本和所有初始样本的距离，根据数据特征降维之后的差异区分对抗样本和真实样本。这种方法的缺陷是需要很大的计算资源，并且只能检测出对抗攻击时添加的对抗扰动比较大，让对抗样本和原始样本差异比较大的情况。<br><strong>C.    输入特征差异：</strong>包括JSMA攻击的论文中提到的，利用相邻像素间的平方差检测对抗样本。（这个方法前面的讨论中提到过，缺乏直观的合理性，所以也没什么价值）</p><h3 id="2）-训练检测器（Detector）："><a href="#2）-训练检测器（Detector）：" class="headerlink" title="2）    训练检测器（Detector）："></a>2）    训练检测器（Detector）：</h3><p>将对抗样本和原始样本作为训练集进行监督训练。<br>而检测器的训练包括两种：<br><strong>一种</strong>是直接将对抗样本和原始样本，打上label作为训练集训练一个分类器；<br><strong>另一种</strong>是将原始数据和对抗样本数据通过原始分类模型后，在输出层的值（或某一层神经网络层的输出值）打上label作为训练集训练一个分类器。</p><h3 id="3）-预测结果差异（Prediction-Inconsistency）"><a href="#3）-预测结果差异（Prediction-Inconsistency）" class="headerlink" title="3）    预测结果差异（Prediction Inconsistency）"></a>3）    预测结果差异（Prediction Inconsistency）</h3><p>根据预测结果差异来检测对抗样本主要有三种：<br><strong>(1)对抗样本和正常样本在原始模型的输出层差异。</strong><br>利用这种差异来检测对抗样本和原始样本，需要利用第2）点中构建一个检测器来实现；或者像我们前面的工作——根据模型输出层的统计差异来区分，但是这种方法不能对单个对抗样本做出判断。<br><strong>(2)对抗样本和原始样本经过特征处理之后，他们在输出层的变化不同。</strong><br>这种方法在前面的报告中提到了，这部分内容在后面的部分详细给出。<br><strong>(3)对抗样本在不同的模型下输出差异。</strong><br>这部分内容和前面和老师讨论的依据Byzantine Generals problem来设计系统相关联，让对抗样本经过多个分类模型，按照3t+1的原则，保证分类输出的正常。<br>其中，不同的模型获得方式有很多，一种是其他能应用于同一个任务的分类模型，比如在用VGG16分类时，用ResNet，WRN，DenseNet等同样能用作分类的网络模型作为参照，检测出对抗样本。另外一种就是基于原始模型的修改，包括结构的修改和训练过程的修改，不同的修改过程可以得到不同的子模型。比如在训练过程中，每次训练采用不同的dropout策略，可以得到几个类似功能的分类模型，只要测试样本在这几个分类模型上满足拜占庭问题的解，就可以判断为是原始样本。</p><hr><h2 id="②改变对抗样本："><a href="#②改变对抗样本：" class="headerlink" title="②改变对抗样本："></a>②改变对抗样本：</h2><p>1）用对抗攻击的方法处理对抗样本，让对抗样本重新被分类准确。<br>2）用特征处理的方法处理对抗样本，让对抗样本重新被分类准确。<br>3) Denoise the adversarial perturbation<br>4）添加去噪器，构建生成式模型，例如APE-GAN</p><hr><h2 id="③增强模型："><a href="#③增强模型：" class="headerlink" title="③增强模型："></a>③增强模型：</h2><p>1）    用更多数据训练，增强模型的泛化能力。包括对抗训练。<br>2）    修改模型的激活函数或者损失函数。<br>3）    使用network add-on，包括利用GAN，Defensive distillation。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;：根据最近的学习，按照自己的理解给不同对抗攻击的防御方法作简单总结。对抗防御从形式上看可以被分为三类：①对抗样本检测；②改变对抗样本；③增强模型。&lt;br&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="https://yoursite.com/categories/Machine-Learning/"/>
    
    
      <category term="papernotes" scheme="https://yoursite.com/tags/papernotes/"/>
    
      <category term="adversarial attack" scheme="https://yoursite.com/tags/adversarial-attack/"/>
    
  </entry>
  
  <entry>
    <title>Academic Writing Lessons</title>
    <link href="https://yoursite.com/2018/03/30/Academic%20Writing%20Lessons/"/>
    <id>https://yoursite.com/2018/03/30/Academic Writing Lessons/</id>
    <published>2018-03-30T15:48:00.000Z</published>
    <updated>2019-02-27T10:07:24.534Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Academic Writing Lessons</strong><br><img src="https://s2.ax1x.com/2019/02/27/kTBBNt.jpg" alt="此处输入图片的描述"></p><a id="more"></a><hr><h2 id="Use-Better-alternative-words"><a href="#Use-Better-alternative-words" class="headerlink" title="Use Better alternative words"></a>Use Better alternative words</h2><table><thead><tr><th>Original</th><th style="text-align:center">Better alternative</th></tr></thead><tbody><tr><td>consider</td><td style="text-align:center">evaluate,assess</td></tr><tr><td>check</td><td style="text-align:center">verify,confirm</td></tr><tr><td>different</td><td style="text-align:center">distinct,diverse,various,varied</td></tr><tr><td>little/few</td><td style="text-align:center">seldom,slightly</td></tr><tr><td>problem</td><td style="text-align:center">limitaion,restriction,obstacle,hindrance</td></tr><tr><td>need</td><td style="text-align:center">require,stipulate</td></tr><tr><td>affect</td><td style="text-align:center">influence,shape</td></tr><tr><td>carry out</td><td style="text-align:center">implement,execute,primulgate,conduct</td></tr><tr><td>change</td><td style="text-align:center">modify,adjust,alter,vary</td></tr><tr><td>complicated</td><td style="text-align:center">complex,cumbersome,intricate</td></tr><tr><td>correct/incorrect</td><td style="text-align:center">precise/imprecise,accurate/inaccurate</td></tr><tr><td>find</td><td style="text-align:center">determine,derive,attain,locate,identify</td></tr><tr><td>help</td><td style="text-align:center">assist,facilitate,guide,direct</td></tr><tr><td>important</td><td style="text-align:center">critical,crucial,essential,pertinent,relevant,significant,vital</td></tr><tr><td>improve</td><td style="text-align:center">enhance,upgrade,elevate</td></tr><tr><td>is made of</td><td style="text-align:center">consists of,comprises,is composed of</td></tr><tr><td>make clear</td><td style="text-align:center">elucidate,clarify</td></tr><tr><td>makesure</td><td style="text-align:center">ensure,assure</td></tr><tr><td>meet</td><td style="text-align:center">satisfy,fulfill,adhere to</td></tr><tr><td>much/strongly</td><td style="text-align:center">markedly,considerably,substantially</td></tr><tr><td>realize</td><td style="text-align:center">comprehend,preceive,understand</td></tr><tr><td>solve</td><td style="text-align:center">alleviate,modify,resolve,eliminate,eradicate</td></tr><tr><td>suitable</td><td style="text-align:center">appropriate,adequate</td></tr><tr><td>tries</td><td style="text-align:center">attempts,aims,aspires</td></tr><tr><td>usually</td><td style="text-align:center">normally,typically,generally</td></tr><tr><td>very</td><td style="text-align:center">highly,rather,quite,extremely</td></tr><tr><td>way</td><td style="text-align:center">method,means,approach,strategy</td></tr><tr><td>whole</td><td style="text-align:center">complete,entire,comprehensive</td></tr><tr><td>is found to be</td><td style="text-align:center">is</td></tr><tr><td>is capable of</td><td style="text-align:center">can</td></tr><tr><td>is view of the fact that</td><td style="text-align:center">because</td></tr><tr><td>in this case</td><td style="text-align:center">here</td></tr><tr><td>in some cases</td><td style="text-align:center">occasionally</td></tr><tr><td>in no case</td><td style="text-align:center">never</td></tr><tr><td>the question as to</td><td style="text-align:center">whether</td></tr><tr><td>subsequent to</td><td style="text-align:center">after,following</td></tr><tr><td>serves the function of</td><td style="text-align:center">is</td></tr><tr><td>reach a conclusion</td><td style="text-align:center">is</td></tr><tr><td>put an end to</td><td style="text-align:center">end</td></tr><tr><td>provided that</td><td style="text-align:center">if</td></tr><tr><td>come to a conclusion</td><td style="text-align:center">conclude</td></tr><tr><td>by means of</td><td style="text-align:center">by</td></tr><tr><td>in a position to</td><td style="text-align:center">can</td></tr><tr><td>be deficient in</td><td style="text-align:center">lack</td></tr><tr><td>at this point in time</td><td style="text-align:center">now</td></tr><tr><td>at the present time</td><td style="text-align:center">now</td></tr><tr><td>notwithstanding the fact that</td><td style="text-align:center">although</td></tr><tr><td>manner in which</td><td style="text-align:center">how</td></tr><tr><td>make inquiry regrading</td><td style="text-align:center">ask about,inquire about</td></tr><tr><td>it is possible that</td><td style="text-align:center">may,might,could,can</td></tr><tr><td>in most cases</td><td style="text-align:center">uaually</td></tr><tr><td>in many cases</td><td style="text-align:center">often</td></tr><tr><td>in large measure</td><td style="text-align:center">largely</td></tr><tr><td>is in excess of</td><td style="text-align:center">exceeds,surpasses</td></tr><tr><td>in proximity to</td><td style="text-align:center">near</td></tr><tr><td>in case</td><td style="text-align:center">if</td></tr><tr><td>in all cases</td><td style="text-align:center">always</td></tr><tr><td>a number of</td><td style="text-align:center">several,many,numerous</td></tr><tr><td>if conditions are such that</td><td style="text-align:center">if</td></tr><tr><td>happens to be</td><td style="text-align:center">am,is,are</td></tr><tr><td>give indication of</td><td style="text-align:center">indicate,suggest</td></tr><tr><td>give consideration to</td><td style="text-align:center">consider</td></tr><tr><td>for this reason</td><td style="text-align:center">because</td></tr><tr><td>for the reason that</td><td style="text-align:center">so</td></tr><tr><td>for the purpose of</td><td style="text-align:center">for/to</td></tr><tr><td>during the time that</td><td style="text-align:center">while</td></tr><tr><td>due to the fact that</td><td style="text-align:center">because</td></tr><tr><td>despite the fact that</td><td style="text-align:center">althought</td></tr><tr><td>at such time as</td><td style="text-align:center">when</td></tr><tr><td>ascertain the location of</td><td style="text-align:center">find</td></tr><tr><td>along the lines of</td><td style="text-align:center">such as</td></tr><tr><td>a majority of</td><td style="text-align:center">most</td></tr></tbody></table><hr><h2 id="Formal-Grammer-and-Style"><a href="#Formal-Grammer-and-Style" class="headerlink" title="Formal Grammer and Style"></a>Formal Grammer and Style</h2><ol><li><p>Avoid contracion</p><pre><code>Export figures will not improve until the economy is stronger.Export figures won&apos;t improve until the economy is stronger.</code></pre></li><li><p>Use the more appropriate formal negative forms.</p><pre><code>not...much -&gt; littlenot...any -&gt; nonot...many -&gt; few</code></pre></li><li><p>Limit the use of “run on” expressions, such as “and so forth” and “etc.”</p><pre><code>These semiconductors can be used in robots, CD players, etc. —&gt;These semiconductors can be used in robots, CD players, and other electronic devices.</code></pre></li><li><p>Avoid addressing the reader as “you”</p><pre><code>You can see the results in Table 1.The results can be seen in Table 1.</code></pre></li><li><p>Limit the use of direct questions.</p><pre><code>Instead, use &quot;we now need to consider...&quot;</code></pre></li><li><p>Place adverbs within the verb.</p><pre><code>Then the solution can be discarded.The solution can then be discarded.The blood is withdraw slowly.The blood is slowly withdraw.</code></pre></li><li>Do not be wordy.</li></ol><p><strong>(To be continued…)</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Academic Writing Lessons&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/02/27/kTBBNt.jpg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Guidances" scheme="https://yoursite.com/categories/Guidances/"/>
    
    
      <category term="lessons" scheme="https://yoursite.com/tags/lessons/"/>
    
      <category term="english" scheme="https://yoursite.com/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>python函数式编程</title>
    <link href="https://yoursite.com/2018/03/29/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://yoursite.com/2018/03/29/python函数式编程/</id>
    <published>2018-03-29T15:48:42.000Z</published>
    <updated>2018-12-27T03:22:50.851Z</updated>
    
    <content type="html"><![CDATA[<p><strong>python函数式编程</strong><br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1522348726856&amp;di=94ad6fe367916649eef70bb9303a9537&amp;imgtype=0&amp;src=http://file.digitaling.com/eImg/image/20140113/20140113145051_79090.jpg" alt="此处输入图片的描述"></p><a id="more"></a><hr><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a><font color="red">高阶函数</font></h2><h3 id="map-和reduce"><a href="#map-和reduce" class="headerlink" title="map()和reduce()"></a>map()和reduce()</h3><p>参考<a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf" target="_blank" rel="noopener">论文</a><br><strong>map():</strong> 这个函数接收两个参数，一个是<strong>函数</strong>，一个是<strong>Iterable</strong>（可迭代对象），map将传入的函数$f(x)$依次作用到序列的每个元素上，并把结果作为新的<strong>Iterator</strong>（迭代器）返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#实现将一个数字序列转化成字符序列</span><br><span class="line">list(map(str,[1,2,3,4,5]))</span><br></pre></td></tr></table></figure></p><p><strong>reduce()</strong>: 把一个函数作用在一个序列[x1, x2, x3, …]上，这个<strong>函数必须接收两个参数$f(x,y)$</strong>，reduce把结果继续和序列的下一个元素做累积计算。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#对一个序列求和</span><br><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line">&gt;&gt;&gt; def add(x, y):</span><br><span class="line">...     return x + y</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])</span><br><span class="line">25</span><br></pre></td></tr></table></figure></p><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>用于过滤序列，和map()类似，<strong>filter()</strong>也接收一个函数和一个序列。<br>和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是<strong>True还是False</strong>决定保留还是丢弃该元素。返回一个<strong>Iterator</strong>（这说明返回的依旧是一个惰性序列）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删掉一个序列中的空字符串</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">注意filter()给函数默认加bool()修正</span></span><br><span class="line"><span class="string">比如：</span></span><br><span class="line"><span class="string">bool(" a")=True</span></span><br><span class="line"><span class="string">bool("  ")=True</span></span><br><span class="line"><span class="string">bool("  ".Strip())=False</span></span><br><span class="line"><span class="string">bool(None)=False</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">not_empty</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> s <span class="keyword">and</span> s.strip()</span><br><span class="line">list(filter(not_empty, [<span class="string">'A'</span>, <span class="string">''</span>, <span class="string">'B'</span>, <span class="keyword">None</span>, <span class="string">'C'</span>, <span class="string">'  '</span>]))</span><br><span class="line"><span class="comment"># 结果: ['A', 'B', 'C']</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#用filter()求素数的方法——埃氏筛法</span><br><span class="line">#定义一个筛选函数</span><br><span class="line">def _not_divisible(n):</span><br><span class="line">    return lambda x: x % n &gt; 0</span><br><span class="line">#初始化自然数序列</span><br><span class="line">def _iter():</span><br><span class="line">    n = 1</span><br><span class="line">    while True:</span><br><span class="line">        n = n + 2</span><br><span class="line">        yield n</span><br><span class="line">def primes():</span><br><span class="line">    yield 2</span><br><span class="line">    it = _iter()</span><br><span class="line">    while True:</span><br><span class="line">        n = next(it)</span><br><span class="line">        yield n</span><br><span class="line">        it = filter(_not_divisible(n), it)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">def _iter():</span></span><br><span class="line"><span class="string">    n = 1</span></span><br><span class="line"><span class="string">    while True:</span></span><br><span class="line"><span class="string">        yield n</span></span><br><span class="line"><span class="string">        n = n + 1</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> str(n) == str(n)[::<span class="number">-1</span>]</span><br><span class="line">list(filter(is_palindrome),range(<span class="number">1000</span>))</span><br></pre></td></tr></table></figure><h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a>sorted()</h3><p>可以实现对list进行排序。<br>同时，可以接受一个key <strong>函数</strong>来实现自定义排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)</span><br><span class="line">[5, 9, -12, -21, 36]</span><br></pre></td></tr></table></figure></p><p>key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>])</span><br><span class="line">[<span class="string">'Credit'</span>, <span class="string">'Zoo'</span>, <span class="string">'about'</span>, <span class="string">'bob'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>], key=str.lower)</span><br><span class="line">[<span class="string">'about'</span>, <span class="string">'bob'</span>, <span class="string">'Credit'</span>, <span class="string">'Zoo'</span>]</span><br></pre></td></tr></table></figure></p><hr><h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a><font color="red">返回函数</font></h2><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazy_sum</span><span class="params">(*args)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">()</span>:</span></span><br><span class="line">        ax = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> args:</span><br><span class="line">            ax = ax + n</span><br><span class="line">        <span class="keyword">return</span> ax</span><br><span class="line">    <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure></p><p>&hearts;&hearts;&hearts;&hearts; <strong><font color="red">闭包</font></strong>&hearts;&hearts;&hearts;&hearts;<br>建议参考教程——<a href="https://zhuanlan.zhihu.com/p/22229197" target="_blank" rel="noopener">知乎专栏</a><br><strong>闭包概念</strong>：在一个内部函数中，对外部作用域的变量进行引用，(并且一般外部函数的返回值为内部函数)，那么内部函数就被认为是闭包。<br>&emsp;在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这称为“闭包（Closure）”的程序结构。<br>&emsp;需要<strong>注意的问题</strong>是，循环在python中没有域的概念，向列表中添加函数的时候并不会保存循环中变量的值。<font color="blue"><strong>返回的函数并没有立刻执行，而是直到调用了f()才执行。</strong></font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def count():</span><br><span class="line">    fs = []</span><br><span class="line">    for i in range(1, 4):</span><br><span class="line">        def f():</span><br><span class="line">             return i*i</span><br><span class="line">        fs.append(f)</span><br><span class="line">    return fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = count()</span><br></pre></td></tr></table></figure></p><p>你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1()</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2()</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f3()</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure></p><p><font color="red">返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</font><br><strong>原因</strong>：闭包函数调用外部循环变量时，并没有保存这个值，只保存了变量的地址，要等到调用闭包函数时才会取具体的值，然而此时函数值可能已经发生了变化。<br><strong>解决办法</strong>：再定义一个函数，将g()形成闭包。主要是要在函数内部，把可变的循环值i作为函数参数调用。简单来说，一定要有f(i),在调用过程中，i就会被传入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def count():</span><br><span class="line">    def f(j):</span><br><span class="line">        def g():</span><br><span class="line">            return j*j</span><br><span class="line">        return g</span><br><span class="line">    fs = []</span><br><span class="line">    for i in range(1, 4):</span><br><span class="line">        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()</span><br><span class="line">    return fs</span><br></pre></td></tr></table></figure></p><p>利用闭包返回一个计数器函数，每次调用它返回递增整数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def createCounter()</span><br><span class="line">    s=[0]</span><br><span class="line">    def conter():</span><br><span class="line">        s[0] += 1</span><br><span class="line">        return s[0]</span><br><span class="line"></span><br><span class="line">    return counter</span><br></pre></td></tr></table></figure></p><p><strong><a href="https://www.cnblogs.com/Lin-Yi/p/7305364.html" target="_blank" rel="noopener">外函数返回了内函数的引用</a>：</strong>当我们在python中定义一个函数def demo():  的时候，内存当中会开辟一些空间，存下这个函数的代码、内部的局部变量等等。这个demo只不过是一个变量名字，它里面存了这个函数所在位置的引用而已。我们还可以进行x = demo， y = demo， 这样的操作就相当于，把demo里存的东西赋值给x和y，这样x 和y 都指向了demo函数所在的引用，在这之后我们可以用x() 或者 y() 来调用我们自己创建的demo() ，调用的实际上根本就是一个函数，x、y和demo三个变量名存了同一个函数的引用。</p><p><strong>闭包中内函数修改外函数局部变量：</strong></p><p>  在闭包内函数中，我们可以随意使用外函数绑定来的临时变量，但是如果我们想修改外函数临时变量数值的时候发现出问题了！<br>  在基本的python语法当中，一个函数可以随意读取全局数据，但是要修改全局数据的时候有两种方法:1 global 声明全局变量 2 全局变量是可变类型数据的时候可以修改<br>  在闭包内函数也是类似的情况。在内函数中想修改闭包变量（外函数绑定给内函数的局部变量）的时候：</p><ol><li>在python3中，可以用nonlocal 关键字声明 一个变量， 表示这个变量不是局部变量空间的变量，需要向上一层变量空间找这个变量。</li><li>在python2中，没有nonlocal这个关键字，我们可以把闭包变量改成可变类型数据进行修改，比如列表。</li></ol><p><strong>闭包的作用：</strong></p><ol><li>装饰器！！！装饰器是做什么的？？其中一个应用就是，我们工作中写了一个登录功能，我们想统计这个功能执行花了多长时间，我们可以用装饰器装饰这个登录模块，装饰器帮我们完成登录函数执行之前和之后取时间。</li><li>面向对象！！！经历了上面的分析，我们发现外函数的临时变量送给了内函数。大家回想一下类对象的情况，对象有好多类似的属性和方法，所以我们创建类，用类创建出来的对象都具有相同的属性方法。闭包也是实现面向对象的方法之一。在python当中虽然我们不这样用，在其他编程语言入比如avaScript中，经常用闭包来实现面向对象编程</li><li>实现单利模式！！</li><li>闭包可以保存当前的运行环境，以一个类似棋盘游戏的例子来说明。假设棋盘大小为50*50，左上角为坐标系原点(0,0)，我需要一个函数，接收2个参数，分别为方向(direction)，步长(step)，该函数控制棋子的运动。 这里需要说明的是，每次运动的起点都是上次运动结束的终点。</li></ol><hr><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a><font color="red">匿名函数</font></h2><p>在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(<span class="keyword">lambda</span> x: x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]))</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">其中，lambda x: x * x相当于：</span></span><br><span class="line"><span class="string">def f(x):</span></span><br><span class="line"><span class="string">    return x * x</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>同时，匿名函数可以作为返回函数。</p><hr><h2 id="装饰器（decorator）"><a href="#装饰器（decorator）" class="headerlink" title="装饰器（decorator）"></a><font color="red">装饰器（decorator）</font></h2><p><strong>装饰器就是一个返回函数的高阶函数，基于闭包原理。</strong><br>定义一个打印日志的decorator:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        print(<span class="string">'call %s():'</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure></p><p>定义一个带参数的decorator:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">            print(<span class="string">'%s %s():'</span> % (text, func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure></p><p>函数也是对象，它有<strong>name</strong>等属性，但你去看经过decorator装饰之后的函数，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'2015-3-25'</span>)</span><br></pre></td></tr></table></figure></p><p>它们的<strong>name</strong>已经从原来的’now’变成了’wrapper’：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>now.__name__</span><br><span class="line"><span class="string">'wrapper'</span></span><br></pre></td></tr></table></figure></p><p>因为返回的那个wrapper()函数名字就是’wrapper’，所以，需要把原始函数的__name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。</p><p>不需要编写wrapper.__name__ = func.__name__这样的代码，Python内置的<font color="red"><strong>functools.wraps</strong></font>就是干这个事的，所以，一个完整的decorator的写法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def log(func):</span><br><span class="line">    @functools.wraps(func)#复制依赖函数</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        print(&apos;call %s():&apos; % func.__name__)</span><br><span class="line">        return func(*args, **kw)</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure></p><hr><h2 id="偏函数（Partial-function）"><a href="#偏函数（Partial-function）" class="headerlink" title="偏函数（Partial function）"></a><font color="red">偏函数（Partial function）</font></h2><p><strong>偏函数可以通过设定参数的默认值，降低函数调用的难度。由Python的functools模块提供。</strong><br>举例说明：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2 = functools.partial(int, base=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'1000000'</span>)</span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'1010101'</span>)</span><br><span class="line"><span class="number">85</span></span><br></pre></td></tr></table></figure></p><p>上面的新的int2函数，仅仅是把base参数重新设定默认值为2，但也可以在函数调用时传入其他值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; int2(&apos;1000000&apos;, base=10)</span><br><span class="line">1000000</span><br></pre></td></tr></table></figure></p><p>创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数，当传入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int2 = functools.partial(int, base=2)</span><br><span class="line">#相当于</span><br><span class="line">kw = &#123; &apos;base&apos;: 2 &#125;</span><br><span class="line">int(&apos;10010&apos;, **kw)</span><br></pre></td></tr></table></figure></p><hr><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a><font color="red">Reference</font></h2><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431843456408652233b88b424613aa8ec2fe032fd85a000" target="_blank" rel="noopener">教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;python函数式编程&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1522348726856&amp;amp;di=94ad6fe367916649eef70bb9303a9537&amp;amp;imgtype=0&amp;amp;src=http://file.digitaling.com/eImg/image/20140113/20140113145051_79090.jpg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Languages" scheme="https://yoursite.com/categories/Languages/"/>
    
    
      <category term="python" scheme="https://yoursite.com/tags/python/"/>
    
  </entry>
  
</feed>
