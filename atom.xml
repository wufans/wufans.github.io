<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fan Wu&#39;s Blog</title>
  
  <subtitle>Nothing is impossible!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yoursite.com/"/>
  <updated>2019-03-21T08:26:15.803Z</updated>
  <id>https://yoursite.com/</id>
  
  <author>
    <name>Fan Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法之美-剑指Offer题解(Java实现)</title>
    <link href="https://yoursite.com/2019/03/21/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3-Java%E5%AE%9E%E7%8E%B0/"/>
    <id>https://yoursite.com/2019/03/21/剑指offer题解-Java实现/</id>
    <published>2019-03-21T07:01:01.000Z</published>
    <updated>2019-03-21T08:26:15.803Z</updated>
    
    <content type="html"><![CDATA[<p>剑指Offer的所有题目和分类，<code>Solution</code>用<code>Java</code>语言实现。</p><a id="more"></a><h2 id="剑指Offer题解"><a href="#剑指Offer题解" class="headerlink" title="剑指Offer题解"></a><font color="red"><strong>剑指Offer题解</strong></font></h2><table><thead><tr><th style="text-align:center">#</th><th style="text-align:center">名称</th><th style="text-align:center">分类</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">左旋转字符串</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution1.java" target="_blank" rel="noopener">字符串</a></td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">实现 Singleton</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution2.java" target="_blank" rel="noopener">设计模式</a></td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">数组中重复的数字</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution3.java" target="_blank" rel="noopener">数组</a></td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">二维数组中的查找</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution4.java" target="_blank" rel="noopener">数组</a></td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">替换空格</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution5.java" target="_blank" rel="noopener">字符串</a></td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">从尾到头打印链表</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution6.java" target="_blank" rel="noopener">链表</a></td></tr><tr><td style="text-align:center">7</td><td style="text-align:center"><strong>重建二叉树</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution7.java" target="_blank" rel="noopener">树</a></td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">二叉树的下一个节点</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution8.java" target="_blank" rel="noopener">树</a></td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">用两个栈实现队列</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution9.java" target="_blank" rel="noopener">栈、队列</a></td></tr><tr><td style="text-align:center">10.1</td><td style="text-align:center">斐波那契数列</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution10_1.java" target="_blank" rel="noopener">动态规划、递归</a></td></tr><tr><td style="text-align:center">10.2</td><td style="text-align:center">（变态）跳台阶</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution10_2.java" target="_blank" rel="noopener">动态规划、递归</a></td></tr><tr><td style="text-align:center">10.3</td><td style="text-align:center">矩形覆盖</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution10_3.java" target="_blank" rel="noopener">动态规划、递归</a></td></tr><tr><td style="text-align:center">10.4</td><td style="text-align:center"><strong>背包问题详解</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution10_4.java" target="_blank" rel="noopener">动态规划、递归</a></td></tr><tr><td style="text-align:center">11</td><td style="text-align:center"><strong>旋转数组的最小数字</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution11.java" target="_blank" rel="noopener">数组</a></td></tr><tr><td style="text-align:center">12</td><td style="text-align:center"><strong>矩阵中的路径</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution12.java" target="_blank" rel="noopener">回溯</a></td></tr><tr><td style="text-align:center">13</td><td style="text-align:center"><strong>机器人的运动范围</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution13.java" target="_blank" rel="noopener">回溯</a></td></tr><tr><td style="text-align:center">14</td><td style="text-align:center"><strong>剪绳子</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution14.java" target="_blank" rel="noopener">动态规划、贪心算法</a></td></tr><tr><td style="text-align:center">15</td><td style="text-align:center"><strong>二进制中 1 的个数</strong>，附<a href="https://blog.csdn.net/zhouzipeng000/article/details/56676885" target="_blank" rel="noopener">源码解析</a></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution15.java" target="_blank" rel="noopener">位运算</a></td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">数值的整数次方</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution16.java" target="_blank" rel="noopener">递归</a></td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">打印从 1 到最大的 n 位数</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution17.java" target="_blank" rel="noopener">回溯</a></td></tr><tr><td style="text-align:center">18.1</td><td style="text-align:center">在 O(1) 时间内删除链表节点</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution18_1.java" target="_blank" rel="noopener">链表</a></td></tr><tr><td style="text-align:center">18.2</td><td style="text-align:center">删除链表中重复的结点</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution18_2.java" target="_blank" rel="noopener">链表,回溯</a></td></tr><tr><td style="text-align:center">19</td><td style="text-align:center"><strong>正则表达式匹配</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution19.java" target="_blank" rel="noopener">递归，动态规划</a></td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">表示数字的字符串</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution20.java" target="_blank" rel="noopener">正则</a></td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">调整数组顺序使奇数位于偶数前面</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution21.java" target="_blank" rel="noopener">数组</a></td></tr><tr><td style="text-align:center">22</td><td style="text-align:center">链表中倒数第 K 个结点</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution22.java" target="_blank" rel="noopener">链表，双指针</a></td></tr><tr><td style="text-align:center">23</td><td style="text-align:center"><strong>链表中环的入口结点</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution23.java" target="_blank" rel="noopener">双指针</a></td></tr><tr><td style="text-align:center">24</td><td style="text-align:center"><strong>反转链表</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution24.java" target="_blank" rel="noopener">递归，链表</a></td></tr><tr><td style="text-align:center">25</td><td style="text-align:center">合并两个排序的链表</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution25.java" target="_blank" rel="noopener">链表，递归</a></td></tr><tr><td style="text-align:center">26</td><td style="text-align:center"><strong>树的子结构</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution26.java" target="_blank" rel="noopener">递归，树</a></td></tr><tr><td style="text-align:center">27</td><td style="text-align:center">二叉树的镜像</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution27.java" target="_blank" rel="noopener">树，递归</a></td></tr><tr><td style="text-align:center">28</td><td style="text-align:center">对称的二叉树</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution28.java" target="_blank" rel="noopener">树，递归</a></td></tr><tr><td style="text-align:center">29</td><td style="text-align:center">顺时针打印矩阵</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution29.java" target="_blank" rel="noopener">逻辑能力</a></td></tr><tr><td style="text-align:center">30</td><td style="text-align:center">包含 min 函数的栈</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution30.java" target="_blank" rel="noopener">栈,类似9</a></td></tr><tr><td style="text-align:center">31</td><td style="text-align:center"><strong>栈的压入、弹出序</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution31.java" target="_blank" rel="noopener">栈</a></td></tr><tr><td style="text-align:center">32.1</td><td style="text-align:center"><strong>从上往下打印二叉树</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution32.java" target="_blank" rel="noopener">队列</a></td></tr><tr><td style="text-align:center">32.2</td><td style="text-align:center"><strong>分层打印二叉树</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution32_2.java" target="_blank" rel="noopener">队列</a></td></tr><tr><td style="text-align:center">32.3</td><td style="text-align:center">之字形打印二叉树</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution32_3.java" target="_blank" rel="noopener">队列</a></td></tr><tr><td style="text-align:center">33</td><td style="text-align:center">二叉搜索树的后序遍历序列</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution33.java" target="_blank" rel="noopener">树的遍历，递归</a></td></tr><tr><td style="text-align:center">34</td><td style="text-align:center"><strong>二叉树中和为某一值的路径</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution34.java" target="_blank" rel="noopener">树，递归</a></td></tr><tr><td style="text-align:center">35</td><td style="text-align:center"><strong>复杂链表的复制</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution35.java" target="_blank" rel="noopener">复杂链表</a></td></tr><tr><td style="text-align:center">36</td><td style="text-align:center"><strong>二叉搜索树与双向链表</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution36.java" target="_blank" rel="noopener">二叉树、链表</a></td></tr><tr><td style="text-align:center">37</td><td style="text-align:center"><strong>序列化二叉树</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution37.java" target="_blank" rel="noopener">二叉树、递归</a></td></tr><tr><td style="text-align:center">38</td><td style="text-align:center"><strong>字符串的排列</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution38.java" target="_blank" rel="noopener">回溯</a></td></tr><tr><td style="text-align:center">39</td><td style="text-align:center"><strong>数组中出现次数超过一半的数字</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution39.java" target="_blank" rel="noopener">多数投票问题</a></td></tr><tr><td style="text-align:center">40</td><td style="text-align:center"><strong>最小的 K 个数</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution40.java" target="_blank" rel="noopener">快排，大根堆小根堆</a></td></tr><tr><td style="text-align:center">41.1</td><td style="text-align:center">数据流中的中位数</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution41_1.java" target="_blank" rel="noopener">大根堆小根堆</a></td></tr><tr><td style="text-align:center">41.2</td><td style="text-align:center">字符流中第一个不重复的字符</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution41_2.java" target="_blank" rel="noopener">数据流</a></td></tr><tr><td style="text-align:center">42</td><td style="text-align:center">连续子数组的最大和</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution42.java" target="_blank" rel="noopener">数组</a></td></tr><tr><td style="text-align:center">43</td><td style="text-align:center"><strong>从 1 到 n 整数中 1 出现的次数</strong>，leetcode-233（Hard）</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution43.java" target="_blank" rel="noopener">逻辑</a></td></tr><tr><td style="text-align:center">44</td><td style="text-align:center">数字序列中的某一位数字</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution44.java" target="_blank" rel="noopener">逻辑</a></td></tr><tr><td style="text-align:center">45</td><td style="text-align:center"><strong>把数组排成最小的数</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution45.java" target="_blank" rel="noopener">排序，逻辑</a></td></tr><tr><td style="text-align:center">46</td><td style="text-align:center"><strong>把数字翻译成字符串</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution46.java" target="_blank" rel="noopener">动态规划</a></td></tr><tr><td style="text-align:center">47</td><td style="text-align:center">礼物的最大价值</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution47.java" target="_blank" rel="noopener">动态规划</a></td></tr><tr><td style="text-align:center">48</td><td style="text-align:center">最长不含重复字符的子字符串</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution48.java" target="_blank" rel="noopener">双指针</a></td></tr><tr><td style="text-align:center">49</td><td style="text-align:center"><strong>丑数</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution49.java" target="_blank" rel="noopener">动态规划，逻辑</a></td></tr><tr><td style="text-align:center">50</td><td style="text-align:center"><strong>第一个只出现一次的字符位置</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution50.java" target="_blank" rel="noopener">BitSet</a></td></tr><tr><td style="text-align:center">51</td><td style="text-align:center"><strong>数组中的逆序对</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution51.java" target="_blank" rel="noopener">排序问题</a></td></tr><tr><td style="text-align:center">52</td><td style="text-align:center"><strong>两个链表的第一个公共结点</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution52.java" target="_blank" rel="noopener">链表，双指针</a></td></tr><tr><td style="text-align:center">53</td><td style="text-align:center"><strong>数字在排序数组中出现的次数</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution53.java" target="_blank" rel="noopener">二分查找</a></td></tr><tr><td style="text-align:center">54</td><td style="text-align:center"><font color="red"><strong>二叉查找树的第 K 个结点</strong><font></font></font></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution54.java" target="_blank" rel="noopener">二叉树，中序遍历</a></td></tr><tr><td style="text-align:center">55.1</td><td style="text-align:center">二叉树的深度</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution55_1.java" target="_blank" rel="noopener">回溯</a></td></tr><tr><td style="text-align:center">55.2</td><td style="text-align:center">平衡二叉树</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution55_2.java" target="_blank" rel="noopener">回溯</a></td></tr><tr><td style="text-align:center">56</td><td style="text-align:center"><strong>数组中只出现一次的数字</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution56.java" target="_blank" rel="noopener">位运算</a></td></tr><tr><td style="text-align:center">57.1</td><td style="text-align:center">和为S的两个数字</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution57_1.java" target="_blank" rel="noopener">数组，双指针</a></td></tr><tr><td style="text-align:center">57.2</td><td style="text-align:center">和为 S 的连续正数序列</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution57_2.java" target="_blank" rel="noopener">数组，双指针</a></td></tr><tr><td style="text-align:center">58</td><td style="text-align:center">翻转单词顺序列</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution58_1.java" target="_blank" rel="noopener">字符串</a></td></tr><tr><td style="text-align:center">59</td><td style="text-align:center">滑动窗口的最大值</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution59.java" target="_blank" rel="noopener">大根堆，滑动窗口</a></td></tr><tr><td style="text-align:center">60</td><td style="text-align:center"><strong>动态规划解法</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution60.java" target="_blank" rel="noopener">动态规划，旋转数组</a></td></tr><tr><td style="text-align:center">61</td><td style="text-align:center">扑克牌顺子</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution61.java" target="_blank" rel="noopener">数组</a></td></tr><tr><td style="text-align:center">62</td><td style="text-align:center"><font color="red"><strong>圆圈中最后剩下的数</strong><font></font></font></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution54.java" target="_blank" rel="noopener">约瑟夫环</a></td></tr><tr><td style="text-align:center">63</td><td style="text-align:center">股票的最大利润</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution63.java" target="_blank" rel="noopener">数组</a></td></tr><tr><td style="text-align:center">64</td><td style="text-align:center">求 1+2+3+…+n</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution64.java" target="_blank" rel="noopener">递归，&amp;&amp;短路</a></td></tr><tr><td style="text-align:center">65</td><td style="text-align:center"><strong>不用加减乘除做加法</strong></td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution65.java" target="_blank" rel="noopener">位运算，BigInteger</a></td></tr><tr><td style="text-align:center">66</td><td style="text-align:center">构建乘积数组</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution66.java" target="_blank" rel="noopener">逻辑</a></td></tr><tr><td style="text-align:center">67</td><td style="text-align:center">把字符串转换成整数</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution67.java" target="_blank" rel="noopener">字符串</a></td></tr><tr><td style="text-align:center">68</td><td style="text-align:center">树中两个节点的最低公共祖先</td><td style="text-align:center"><a href="https://github.com/wufans/EverydayAlgorithms/blob/master/Java/Offer/Solution68.java" target="_blank" rel="noopener">二分查找树，递归</a></td></tr></tbody></table><hr><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h3><ol><li>何海涛. 剑指 Offer[M]. 电子工业出版社, 2012.</li><li>题目顺序参考：<a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md" target="_blank" rel="noopener">CS-Notes-剑指offer题解</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指Offer的所有题目和分类，&lt;code&gt;Solution&lt;/code&gt;用&lt;code&gt;Java&lt;/code&gt;语言实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="https://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Java" scheme="https://yoursite.com/tags/Java/"/>
    
      <category term="algorithms" scheme="https://yoursite.com/tags/algorithms/"/>
    
      <category term="剑指offer" scheme="https://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>算法之美-用两个X实现一个Y</title>
    <link href="https://yoursite.com/2019/02/21/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E2%80%94%E7%94%A8%E4%B8%A4%E4%B8%AAX%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAY/"/>
    <id>https://yoursite.com/2019/02/21/算法之美—用两个X实现一个Y/</id>
    <published>2019-02-21T12:01:01.000Z</published>
    <updated>2019-03-17T03:51:05.141Z</updated>
    
    <content type="html"><![CDATA[<p>对于经典面试题：“两个栈实现队列”和“两个队列实现栈”,应该怎么考虑呢？<br><a id="more"></a></p><h2 id="两个栈实现队列"><a href="#两个栈实现队列" class="headerlink" title="两个栈实现队列"></a>两个栈实现队列</h2><p><strong>思路:</strong> 利用inStack作为进队的缓存。出队时，因为考虑到“先进先出”，可以利用另一个栈outStack转存当前的缓存。出队时，为了保证再入队依旧满足规律，若outStack为空，先<strong>全部</strong>倒入outStack；若不为空，则outStack直接出栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Stack&lt;Integer&gt; inStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> Stack&lt;Integer&gt; outStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(Integer in)</span></span>&#123;</span><br><span class="line">    inStack.push(in);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Integer <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(outStack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(!inStack.isEmpty())&#123;</span><br><span class="line">            outStack.push(inStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(outStack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"no data"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> outStack.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Solution9 test = <span class="keyword">new</span> Solution9();</span><br><span class="line">    test.push(<span class="number">8</span>);</span><br><span class="line">    test.push(<span class="number">9</span>);</span><br><span class="line">    test.push(<span class="number">99</span>);</span><br><span class="line">    System.out.println(test.pop());</span><br><span class="line">    test.push(<span class="number">999</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两个队列实现栈"><a href="#两个队列实现栈" class="headerlink" title="两个队列实现栈"></a>两个队列实现栈</h2><p><strong>思路：</strong> 利用一个队存储，另一个队作为缓存。当出栈时，让非空的队列先出队n-1，最后剩下的一个出队则完成了栈的“先入先出”的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; queue1=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();  </span><br><span class="line">LinkedList&lt;Integer&gt; queue2=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span><span class="comment">//入栈  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    queue1.addLast(value);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span><span class="comment">//出栈     必须是非空的栈才能出栈啊  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(sSize()!=<span class="number">0</span>)<span class="comment">//栈不为空  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//移动一个队的n-1个到另一个中  </span></span><br><span class="line">        <span class="keyword">if</span>(!queue1.isEmpty())<span class="comment">//q1 空  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            putN_1ToAnthor();  </span><br><span class="line">            <span class="keyword">return</span> queue1.removeFirst();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//q2 空  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            putN_1ToAnthor();  </span><br><span class="line">            <span class="keyword">return</span> queue2.removeFirst();  </span><br><span class="line">        &#125;          </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">"栈已经为空啦，不能出栈"</span>);  </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sSize</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> queue1.size()+queue2.size();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putN_1ToAnthor</span><span class="params">()</span><span class="comment">//从非空中出队n-1个到另一个队列   因为队列总是一空一非空  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(!queue1.isEmpty())  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">while</span>(queue1.size()&gt;<span class="number">1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            queue2.addLast(queue1.removeFirst());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!queue2.isEmpty())  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">while</span>(queue2.size()&gt;<span class="number">1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            queue1.addLast(queue2.removeFirst());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其他类似题目（更新中。。）</p></blockquote><h2 id="包含-min-函数的栈"><a href="#包含-min-函数的栈" class="headerlink" title="包含 min 函数的栈"></a>包含 min 函数的栈</h2><p><strong>题目描述</strong>：定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; datastack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minstack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        datastack.push(node);</span><br><span class="line"><span class="comment">//        if(minstack.isEmpty())&#123;</span></span><br><span class="line"><span class="comment">//            minstack.push(node);</span></span><br><span class="line"><span class="comment">//        &#125;else&#123;</span></span><br><span class="line"><span class="comment">//            if(minstack.peek()&lt;node)&#123;</span></span><br><span class="line"><span class="comment">//                minstack.push(minstack.peek());</span></span><br><span class="line"><span class="comment">//            &#125;else&#123;</span></span><br><span class="line"><span class="comment">//                minstack.push(node);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//注意minstack栈顶始终存储的当前栈的最小值，且长度和datastack一样</span></span><br><span class="line">        minStack.push(minStack.isEmpty() ? node : Math.min(minStack.peek(), node));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        datastack.pop();</span><br><span class="line">        minstack.pop();<span class="comment">//注意这里</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> datastack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minstack.peek();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a>数据流中的中位数</h2><p><strong>题目描述</strong>：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p><blockquote><p>两个栈实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用两个栈实现的</span></span><br><span class="line">    Stack&lt;Integer&gt; min = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; max = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        number++;</span><br><span class="line">        <span class="keyword">if</span>(min.size() == <span class="number">0</span> &amp;&amp; (max.size() == <span class="number">0</span> || num &lt;= max.peek()))&#123;</span><br><span class="line">            min.push(num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max.size() == <span class="number">0</span> &amp;&amp; (min.size() == <span class="number">0</span> || num &gt;= min.peek()))&#123;</span><br><span class="line">            max.push(num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num &gt; max.peek())&#123;</span><br><span class="line">            <span class="keyword">while</span>(max.size() != <span class="number">0</span> &amp;&amp; num&gt;max.peek())&#123;</span><br><span class="line">                min.push(max.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; min.peek())&#123;</span><br><span class="line">            <span class="keyword">while</span>( min.size() != <span class="number">0</span>&amp;&amp; num&lt;min.peek() )&#123;</span><br><span class="line">                max.push(min.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        min.push(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(min.size()&lt;number/<span class="number">2</span>)&#123;</span><br><span class="line">            min.push(max.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(min.size()&gt;number/<span class="number">2</span>)&#123;</span><br><span class="line">            max.push(min.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(number%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (min.peek()+max.peek())/<span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)max.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>两个大根堆实现：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//用堆实现的</span></span><br><span class="line">    <span class="comment">/* 大顶堆，存储左半边元素 */</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; left = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line">    <span class="comment">/* 小顶堆，存储右半边元素，并且右半边元素都大于左半边 */</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; right = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="comment">/* 当前数据流读入的元素个数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert2</span><span class="params">(Integer val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 插入要保证两个堆存于平衡状态 */</span></span><br><span class="line">        <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* N 为偶数的情况下插入到右半边。</span></span><br><span class="line"><span class="comment">* 因为右半边元素都要大于左半边，但是新插入的元素不一定比左半边元素</span></span><br><span class="line"><span class="comment">来的大，</span></span><br><span class="line"><span class="comment">* 因此需要先将元素插入左半边，然后利用左半边为大顶堆的特点，取出堆</span></span><br><span class="line"><span class="comment">顶元素即为最大元素，此时插入右半边 */</span></span><br><span class="line">            left.add(val);</span><br><span class="line">            right.add(left.poll());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right.add(val);</span><br><span class="line">            left.add(right.poll());</span><br><span class="line">        &#125; N</span><br><span class="line">                ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (left.peek() + right.peek()) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) right.peek();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于经典面试题：“两个栈实现队列”和“两个队列实现栈”,应该怎么考虑呢？&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="https://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="algorithms" scheme="https://yoursite.com/tags/algorithms/"/>
    
      <category term="coding" scheme="https://yoursite.com/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>算法之美-回溯</title>
    <link href="https://yoursite.com/2019/01/21/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E5%9B%9E%E6%BA%AF/"/>
    <id>https://yoursite.com/2019/01/21/算法之美-回溯/</id>
    <published>2019-01-21T08:01:01.000Z</published>
    <updated>2019-03-17T03:51:06.696Z</updated>
    
    <content type="html"><![CDATA[<p>N皇后的问题应该怎么解决？回溯法来帮忙！<br><img src="https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike72%2C5%2C5%2C72%2C24/sign=b8f564729c22720e6fc3eaa81aa26123/b2de9c82d158ccbfdd83742a1dd8bc3eb13541e7.jpg" alt="此处输入图片的描述"><br><a id="more"></a></p><h2 id="什么是回溯？"><a href="#什么是回溯？" class="headerlink" title="什么是回溯？"></a>什么是回溯？</h2><p><strong>回溯</strong>法思路的简单描述是：把问题的解空间转化成了图或者树的结构表示，然后使用<code>深度优先搜索策略</code>进行遍历，遍历的过程中记录和寻找所有可行解或者最优解。基本思想类同于图的深度优先搜索和二叉树的后序遍历。</p><p>回溯法按深度优先策略搜索问题的解空间树。首先从根节点出发搜索解空间树，当算法搜索至解空间树的某一节点时，先利用剪枝函数判断该节点是否可行（即能得到问题的解）。如果不可行，则跳过对该节点为根的子树的搜索，逐层向其祖先节点回溯；否则，进入该子树，继续按深度优先策略搜索。</p><p>回溯法的基本思想是按照输入数组的顺序，每一层递归处理一个元素，当处理到最后一层的时候，也就是把数组中的所有元素都处理完的时候，把当前结果加入到最后的返回结果中。值得注意的是，每次在递归到下一层之前，我们加入了某个要处理的元素X，在下一层递归返回之后，我们要把之前加入的元素X从当前结果中取出来。如果我们不把元素X取出来，那么在下一次循环中，我们还会加入新的元素Y。那么在这一层递归中就相当于处理了不止一个新元素。</p><h2 id="经典题目实例"><a href="#经典题目实例" class="headerlink" title="经典题目实例"></a>经典题目实例</h2><h3 id="1-矩阵中的路径"><a href="#1-矩阵中的路径" class="headerlink" title="(1) 矩阵中的路径"></a>(1) 矩阵中的路径</h3><p><strong>题目描述</strong>：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。<br><strong>题解：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">private int rows;</span><br><span class="line">private int cols;</span><br><span class="line">public boolean hasPath(char[] array, int rows, int cols, char[] str) &#123;</span><br><span class="line">    //异常情况判断</span><br><span class="line">    if(array.length == 0 || array.length != rows * cols)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if(str.length == 0)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    char[][] matrix = new char[rows][cols];</span><br><span class="line">    boolean[][] mark = new boolean[rows][cols];</span><br><span class="line"></span><br><span class="line">    this.rows = rows;</span><br><span class="line">    this.cols = cols;</span><br><span class="line">    //把一维数组转化成二维矩阵</span><br><span class="line">    for (int r = 0, idx = 0; r &lt; rows; r++) &#123;  //注意括号内的inx的定义方式</span><br><span class="line">        for (int c = 0; c &lt; cols; c++) &#123;</span><br><span class="line">            matrix[r][c] = array[idx++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //遍历数组每个元素，依次与字符串比较</span><br><span class="line">    for (int r = 0; r &lt; rows; r++) &#123;</span><br><span class="line">        for (int c = 0; c &lt; cols; c++) &#123;</span><br><span class="line">            if (matrix[r][c] == str[0]) &#123;</span><br><span class="line">                mark[r][c] = true;</span><br><span class="line">                if(helper(matrix, r, c, str,mark, 0))&#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                mark[r][c] = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//回溯算法的主体，依次迭代，直到最后的结论；</span><br><span class="line">private boolean helper(char[][] matrix, int r, int c, char[] str,boolean[][] mark, int number) &#123;</span><br><span class="line"></span><br><span class="line">    if(number == str.length-1)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    number += 1;</span><br><span class="line">    if(r-1 &gt;=0)&#123;</span><br><span class="line">        if(matrix[r-1][c] == str[number] &amp;&amp; !mark[r-1][c])&#123;</span><br><span class="line">            mark[r-1][c] = true;</span><br><span class="line">            if(helper(matrix, r-1, c, str, mark, number))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(r+1 &lt; rows)&#123;</span><br><span class="line">        if(matrix[r+1][c] == str[number] &amp;&amp; !mark[r+1][c])&#123;</span><br><span class="line">            mark[r+1][c] = true;</span><br><span class="line"></span><br><span class="line">            if(helper(matrix, r+1, c, str, mark, number))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(c-1 &gt;= 0)&#123;</span><br><span class="line">        if(matrix[r][c-1] == str[number] &amp;&amp; !mark[r][c-1])&#123;</span><br><span class="line">            mark[r][c-1] = true;</span><br><span class="line">            if(helper(matrix, r, c-1, str, mark, number))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(c+1 &lt; cols)&#123;</span><br><span class="line">        if(matrix[r][c+1] == str[number] &amp;&amp; !mark[r][c+1])&#123;</span><br><span class="line">            mark[r][c+1] = true;</span><br><span class="line">            if(helper(matrix, r, c+1, str, mark, number))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="（2）机器人的运动范围"><a href="#（2）机器人的运动范围" class="headerlink" title="（2）机器人的运动范围"></a>（2）机器人的运动范围</h3><p><strong>题目描述：</strong>地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k 的格子。例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,38)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？<br><strong>题解：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">private int rows;</span><br><span class="line">private int cols;</span><br><span class="line">private int result = 0;</span><br><span class="line">private boolean[][] mark;</span><br><span class="line">public int movingCount(int threshold, int rows, int cols)&#123;</span><br><span class="line">    this.rows = rows;</span><br><span class="line">    this.cols = cols;</span><br><span class="line">    this.mark = new boolean[rows][cols];</span><br><span class="line">    boolean[][] marktmp = new boolean[rows][cols];</span><br><span class="line">    //注意边界问题</span><br><span class="line">    if(!(threshold &lt;= 0 || rows &lt;=0 || cols &lt;=0))&#123;</span><br><span class="line">        helper(threshold,rows,cols,0,0,marktmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">//回溯法核心</span><br><span class="line">private void helper(int threshold, int rows, int cols, int r, int c, boolean[][] marktmp) &#123;</span><br><span class="line">    if(judge(threshold,r,c) &amp;&amp; !marktmp[r][c])&#123;</span><br><span class="line">        System.out.println(Integer.toString(threshold)+&quot; &quot;+Integer.toString(r)+&quot; &quot;+Integer.toString(c));</span><br><span class="line">        marktmp[r][c] = true;</span><br><span class="line">        if(mark[r][c] == false)&#123;</span><br><span class="line">            mark[r][c] = true;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(r+1 &lt; rows)&#123;</span><br><span class="line">            helper(threshold,rows,cols,r+1,c,marktmp);</span><br><span class="line">        &#125;</span><br><span class="line">        if(c+1&lt;cols)&#123;</span><br><span class="line">            helper(threshold,rows,cols,r,c+1,marktmp);</span><br><span class="line">        &#125;</span><br><span class="line">        if(r-1 &gt;=0)&#123;</span><br><span class="line">            helper(threshold,rows,cols,r-1,c,marktmp);</span><br><span class="line">        &#125;</span><br><span class="line">        if(c-1 &gt;=0)&#123;</span><br><span class="line">            helper(threshold,rows,cols,r,c-1,marktmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//判断是否符合规则</span><br><span class="line">private boolean judge(int threshold, int row, int col)&#123;</span><br><span class="line">    int tmp = 0;</span><br><span class="line">    while(row &gt;0)&#123;</span><br><span class="line">        tmp += row%10;</span><br><span class="line">        row/=10;</span><br><span class="line">    &#125;</span><br><span class="line">    while(col &gt;0)&#123;</span><br><span class="line">        tmp += col%10;</span><br><span class="line">        col/=10;</span><br><span class="line">    &#125;</span><br><span class="line">    return threshold &gt;= tmp?true:false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="（3）N皇后问题"><a href="#（3）N皇后问题" class="headerlink" title="（3）N皇后问题"></a>（3）N皇后问题</h3><p><strong>题目描述：</strong>要求在一个n×n的棋盘上放置n个皇后，使得它们彼此不受攻击。按照国际象棋的规则，一个皇后可以攻击与之同一行或同一列或同一斜线上的任何棋子。因此，n皇后问题等价于：要求在一个n×n的棋盘上放置n个皇后，使得任意两个皇后不在同一行或同一列或同一斜线上。<br><strong>题解：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">   private static int SIZE = 0;//皇后的个数</span><br><span class="line">private static int count = 0;//记录摆放的方式数</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">Scanner input = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;请输入你要解决几个皇后的问题&quot;);</span><br><span class="line">SIZE = input.nextInt();</span><br><span class="line">input.close();</span><br><span class="line"> LinkedList&lt;Location&gt; list = new LinkedList&lt;Location&gt;();</span><br><span class="line">     NQueen(list, 0, 0);  //从棋盘的第0行第0列开始</span><br><span class="line">     System.out.println(SIZE + &quot;皇后共有 &quot; + count + &quot;种摆放方式&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">static class Location&#123;</span><br><span class="line">int x;//对应棋盘的行</span><br><span class="line">int y;//对应棋盘的列</span><br><span class="line"></span><br><span class="line">Location(int x,int y)&#123;</span><br><span class="line">this.x = x;</span><br><span class="line">this.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;(&quot; + x + &quot;,&quot; + y + &quot;)&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">    * 主要函数，用回溯法。</span><br><span class="line">    */</span><br><span class="line">   private static void NQueen(LinkedList&lt;Location&gt; list, int x, int y) &#123;   </span><br><span class="line"></span><br><span class="line">       if(list.size() == SIZE)&#123;  //当list元素个数为SIZE时，表示SIZE个皇后都摆放完毕，打印后即可退出函数。</span><br><span class="line">           printLocation(list);  //打印皇后摆放方式</span><br><span class="line">           return ;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       for(int i = x ; i &lt; SIZE ; i++)&#123;</span><br><span class="line">           Location loc = new Location(i, y);</span><br><span class="line">           if(isLegalLoc(list, loc))&#123;</span><br><span class="line">               list.offer(loc);  //将第y行的皇后摆放好</span><br><span class="line">               NQueen(list, 0, y+1);  //开始摆放y+1行的皇后，同样从第0列开始摆放</span><br><span class="line">               list.pollLast();  //每次摆放完一个皇后后，都要将其撤回，再试探其它的摆法。</span><br><span class="line">           &#125;                   </span><br><span class="line">       &#125;           </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">    * 判断位置为loc的皇后是否合法</span><br><span class="line">    */</span><br><span class="line">   private static boolean isLegalLoc(LinkedList&lt;Location&gt; list, Location loc) &#123;</span><br><span class="line">       for(Location each : list)&#123;</span><br><span class="line">           if(loc.x == each.x || loc.y == each.y)  //判断是否在同一行或同一列</span><br><span class="line">               return false;</span><br><span class="line">           else if (Math.abs(loc.x - each.x) == Math.abs(loc.y - each.y))  //判断是否在同斜线上</span><br><span class="line">               return false;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 打印皇后摆放方式</span><br><span class="line">    * @param list</span><br><span class="line">    */</span><br><span class="line">   private static void printLocation(LinkedList&lt;Location&gt; list) &#123;</span><br><span class="line">   String[][] show = new String[SIZE][SIZE];</span><br><span class="line">   for(int i = 0;i&lt;SIZE;i++) &#123;</span><br><span class="line">   for(int j = 0;j&lt;SIZE;j++) &#123;</span><br><span class="line">   show[i][j] = &quot;0&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   for(Location each : list)&#123;</span><br><span class="line">           System.out.print(each.toString() + &quot;\t&quot;);</span><br><span class="line">           show[each.x][each.y] = &quot;1&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println();</span><br><span class="line"></span><br><span class="line">       for(int i =0;i&lt;SIZE;i++) &#123;</span><br><span class="line">       for(int j=0;j&lt;SIZE;j++) &#123;</span><br><span class="line">       System.out.print(show[i][j] + &quot; &quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println();</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println();</span><br><span class="line"></span><br><span class="line">       count ++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-迷宫问题"><a href="#4-迷宫问题" class="headerlink" title="(4)迷宫问题"></a>(4)迷宫问题</h3><p><strong>题目描述：</strong>以一个M×N的长方阵表示迷宫，0和1分别表示迷宫中的通路和障碍。设计一个程序，对任意设定的迷宫，求出一条从入口到出口的通路，或得出没有通路的结论。<br> （1） 根据二维数组，输出迷宫的图形。<br> （2） 探索迷宫的四个方向：RIGHT为向右，DOWN向下，LEFT向左，UP向上，输出从入口到出口的行走路径。<br><strong>题解：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">class Position&#123;</span><br><span class="line">  public Position()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Position(int row, int col)&#123;</span><br><span class="line">    this.col = col;</span><br><span class="line">    this.row = row;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String toString()&#123;</span><br><span class="line">    return &quot;(&quot; + row + &quot; ,&quot; + col + &quot;)&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int row;</span><br><span class="line">  int col;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Maze&#123;</span><br><span class="line">  public Maze()&#123;</span><br><span class="line">    maze = new int[15][15];</span><br><span class="line">    stack = new Stack&lt;Position&gt;();</span><br><span class="line">    p = new boolean[15][15];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">   * 构造迷宫</span><br><span class="line">   */</span><br><span class="line">  public void init()&#123;</span><br><span class="line">    Scanner scanner = new Scanner(System.in);</span><br><span class="line">    System.out.println(&quot;请输入迷宫的行数&quot;);</span><br><span class="line">    row = scanner.nextInt();</span><br><span class="line">    System.out.println(&quot;请输入迷宫的列数&quot;);</span><br><span class="line">    col = scanner.nextInt();</span><br><span class="line">    System.out.println(&quot;请输入&quot; + row + &quot;行&quot; + col + &quot;列的迷宫&quot;);</span><br><span class="line">    int temp = 0;</span><br><span class="line">    for(int i = 0; i &lt; row; ++i) &#123;</span><br><span class="line">      for(int j = 0; j &lt; col; ++j) &#123;</span><br><span class="line">        temp = scanner.nextInt();</span><br><span class="line">        maze[i][j] = temp;</span><br><span class="line">        p[i][j] = false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">   * 回溯迷宫，查看是否有出路</span><br><span class="line">   */</span><br><span class="line">  public void findPath()&#123;</span><br><span class="line">    // 给原始迷宫的周围家一圈围墙</span><br><span class="line">    int temp[][] = new int[row + 2][col + 2];</span><br><span class="line">    for(int i = 0; i &lt; row + 2; ++i) &#123;</span><br><span class="line">      for(int j = 0; j &lt; col + 2; ++j) &#123;</span><br><span class="line">        temp[0][j] = 1;</span><br><span class="line">        temp[row + 1][j] = 1;</span><br><span class="line">        temp[i][0] = temp[i][col + 1] = 1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将原始迷宫复制到新的迷宫中</span><br><span class="line">    for(int i = 0; i &lt; row; ++i) &#123;</span><br><span class="line">      for(int j = 0; j &lt; col; ++j) &#123;</span><br><span class="line">        temp[i + 1][j + 1] = maze[i][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 从左上角开始按照顺时针开始查询</span><br><span class="line"></span><br><span class="line">    int i = 1;</span><br><span class="line">    int j = 1;</span><br><span class="line">    p[i][j] = true;</span><br><span class="line">    stack.push(new Position(i, j));</span><br><span class="line">    while (!stack.empty() &amp;&amp; (!(i == (row) &amp;&amp; (j == col)))) &#123;</span><br><span class="line"></span><br><span class="line">      if ((temp[i][j + 1] == 0) &amp;&amp; (p[i][j + 1] == false)) &#123;</span><br><span class="line">        p[i][j + 1] = true;</span><br><span class="line">        stack.push(new Position(i, j + 1));</span><br><span class="line">        j++;</span><br><span class="line">      &#125; else if ((temp[i + 1][j] == 0) &amp;&amp; (p[i + 1][j] == false)) &#123;</span><br><span class="line">        p[i + 1][j] = true;</span><br><span class="line">        stack.push(new Position(i + 1, j));</span><br><span class="line">        i++;</span><br><span class="line">      &#125; else if ((temp[i][j - 1] == 0) &amp;&amp; (p[i][j - 1] == false)) &#123;</span><br><span class="line">        p[i][j - 1] = true;</span><br><span class="line">        stack.push(new Position(i, j - 1));</span><br><span class="line">        j--;</span><br><span class="line">      &#125; else if ((temp[i - 1][j] == 0) &amp;&amp; (p[i - 1][j] == false)) &#123;</span><br><span class="line">        p[i - 1][j] = true;</span><br><span class="line">        stack.push(new Position(i - 1, j));</span><br><span class="line">        i--;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        if(stack.empty())&#123;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        i = stack.peek().row;</span><br><span class="line">        j = stack.peek().col;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Position&gt; newPos = new Stack&lt;Position&gt;();</span><br><span class="line">    if (stack.empty()) &#123;</span><br><span class="line">      System.out.println(&quot;没有路径&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      System.out.println(&quot;有路径&quot;);</span><br><span class="line">      System.out.println(&quot;路径如下：&quot;);</span><br><span class="line">      while (!stack.empty()) &#123;</span><br><span class="line">        Position pos = new Position();</span><br><span class="line">        pos = stack.pop();</span><br><span class="line">        newPos.push(pos);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 图形化输出路径</span><br><span class="line">     * */</span><br><span class="line"></span><br><span class="line">    String resault[][]=new String[row+1][col+1];</span><br><span class="line">    for(int k=0;k&lt;row;++k)&#123;</span><br><span class="line">      for(int t=0;t&lt;col;++t)&#123;</span><br><span class="line">        resault[k][t]=(maze[k][t])+&quot;&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (!newPos.empty()) &#123;</span><br><span class="line">      Position p1=newPos.pop();</span><br><span class="line">      resault[p1.row-1][p1.col-1]=&quot;#&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int k=0;k&lt;row;++k)&#123;</span><br><span class="line">      for(int t=0;t&lt;col;++t)&#123;</span><br><span class="line">        System.out.print(resault[k][t]+&quot;\t&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int maze[][];</span><br><span class="line">  private int row = 9;</span><br><span class="line">  private int col = 8;</span><br><span class="line">  Stack&lt;Position&gt; stack;</span><br><span class="line">  boolean p[][] = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class hello&#123;</span><br><span class="line">  public static void main(String[] args)&#123;</span><br><span class="line">    Maze demo = new Maze();</span><br><span class="line">    demo.init();</span><br><span class="line">    demo.findPath();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;N皇后的问题应该怎么解决？回溯法来帮忙！&lt;br&gt;&lt;img src=&quot;https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike72%2C5%2C5%2C72%2C24/sign=b8f564729c22720e6fc3eaa81aa26123/b2de9c82d158ccbfdd83742a1dd8bc3eb13541e7.jpg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="https://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="algorithms" scheme="https://yoursite.com/tags/algorithms/"/>
    
      <category term="coding" scheme="https://yoursite.com/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>Java的艺术-Java容器(2)之并发修改异常</title>
    <link href="https://yoursite.com/2019/01/06/Java%E7%9A%84%E8%89%BA%E6%9C%AF-Java%E5%AE%B9%E5%99%A8(2)%E4%B9%8B%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E5%BC%82%E5%B8%B8/"/>
    <id>https://yoursite.com/2019/01/06/Java的艺术-Java容器(2)之并发修改异常/</id>
    <published>2019-01-06T12:18:20.000Z</published>
    <updated>2019-03-12T07:39:23.615Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551345094255&amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;imgtype=0&amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png" alt="此处输入图片的描述"><br>ConcurrentModificationException（并发修改异常）为什么会出现？怎么解决呢？<br><a id="more"></a></p><h2 id="什么时候出现“并发修改异常”？"><a href="#什么时候出现“并发修改异常”？" class="headerlink" title="什么时候出现“并发修改异常”？"></a><strong>什么时候出现“并发修改异常”？</strong></h2><p>看下面这两段代码</p><blockquote><p>(1)增强for</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">res.add(<span class="string">"a"</span>);</span><br><span class="line">res.add(<span class="string">"b"</span>);</span><br><span class="line"><span class="keyword">for</span> (String s:res)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="string">"a"</span>)&#123;</span><br><span class="line">        res.add(<span class="string">"c"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>(2)迭代器</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">res.add(<span class="string">"a"</span>);</span><br><span class="line">res.add(<span class="string">"b"</span>);</span><br><span class="line">Iterator it = res.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    String s =(String) it.next();</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="string">"a"</span>)&#123;</span><br><span class="line">        res.add(<span class="string">"c"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码都会出现下面的异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.util.ConcurrentModificationException</span><br><span class="line">at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class="number">909</span>)</span><br><span class="line">at java.util.ArrayList$Itr.next(ArrayList.java:<span class="number">859</span>)</span><br><span class="line">at offer.Solution38.Permutation(Solution38.java:<span class="number">25</span>)</span><br><span class="line">at offer.Solution38.main(Solution38.java:<span class="number">35</span>)</span><br></pre></td></tr></table></figure><h2 id="为什么会出现“并发修改异常”？"><a href="#为什么会出现“并发修改异常”？" class="headerlink" title="为什么会出现“并发修改异常”？"></a><strong>为什么会出现“并发修改异常”？</strong></h2><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a><font color="red"><strong>源码分析</strong></font></h3><p>首先我们看ArrayList类的源码，其iterator()方法为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>返回一个新建的<strong>Itr</strong>对象，源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Itr() &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>是个没有内容内部类，我们只能看看ArrayList的父类AbstractList有没有对应的内容：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Index of element to be returned by subsequent call to next.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> cursor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Index of element returned by most recent call to next or</span></span><br><span class="line"><span class="comment">         * previous.  Reset to -1 if this element is deleted by a call</span></span><br><span class="line"><span class="comment">         * to remove.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The modCount value that the iterator believes that the backing</span></span><br><span class="line"><span class="comment">         * List should have.  If this expectation is violated, the iterator</span></span><br><span class="line"><span class="comment">         * has detected concurrent modification.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = cursor;</span><br><span class="line">                E next = get(i);</span><br><span class="line">                lastRet = i;</span><br><span class="line">                cursor = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                AbstractList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">                <span class="keyword">if</span> (lastRet &lt; cursor)</span><br><span class="line">                    cursor--;</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>是一个实现了<strong>Iterator</strong>接口的私有内部类。</p><p>分析它的<strong>hasNext()</strong>方法，会发现一个成员变量<strong>cursor</strong>。分析发现，这个变量表示下一个要访问元素的索引，当索引大于集合的<strong>size()</strong>后，则<strong>hasNext()=false</strong>。并且，<strong>next()</strong>方法返回的元素调用了<strong>get(cursor)</strong>,而get()方法在ArrayList中为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<strong>elementData</strong>就是用来存储ArrayList的Object数组。</p><blockquote><p>什么时候会出现ConcurrentModificationException呢？</p></blockquote><p>我们发现了Itr类的两个方法<strong>remove()和checkForComodification()</strong>会抛出这个异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            AbstractList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; cursor)</span><br><span class="line">                cursor--;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以及<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final void checkForComodification() &#123;</span><br><span class="line">            if (modCount != expectedModCount)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>我们观察上面抛出异常的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">res.add(&quot;a&quot;);</span><br><span class="line">res.add(&quot;b&quot;);</span><br><span class="line">Iterator it = res.iterator();</span><br><span class="line">while(it.hasNext())&#123;</span><br><span class="line">    String s =(String) it.next();</span><br><span class="line">    if(s == &quot;a&quot;)&#123;</span><br><span class="line">        res.add(&quot;c&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先在next()方法中会调用<strong>checkForComodification()</strong>方法，然后根据cursor的值获取到元素，接着将cursor的值赋给lastRet，并对cursor的值进行加1操作。初始时，cursor为0，lastRet为-1，那么调用一次之后，cursor的值为1，lastRet的值为0。注意此时，<strong>modCount为0，expectedModCount也为0</strong>。</p><p>随后，代码调用了res.add(“c”)。</p><p>查看源码，ArrayList的add()方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>再查看<strong>ensureCapacityInternal()</strong>的源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们发现了关键一行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modCount++;</span><br></pre></td></tr></table></figure><p>此时，<strong>modCount为1，expectedModCount为0</strong>。</p><p>在调用next()方法时，执行<strong>checkForComodification()</strong>显然就会抛出<strong>ConcurrentModificationException()</strong>！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>终于解决了这个疑惑！</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><blockquote><p>分析源码，在多线程程序中，如果有多个线程都在使用一个集合对象X，线程继续迭代，当A线程调用迭代器的next()方法时，发现modCount不等于expectedModCount，因此就抛出了ConcurrentModificationException异常。这可能就是它为什么叫并发修改异常的原因。<strong>从这一点也能说明ArrayList不是线程安全的。</strong></p></blockquote><blockquote><p>简单来说，调用list.remove(),list.add()方法导致modCount和expectedModCount的值不一致。使用for-each进行迭代实际上也会出现这种问题。</p></blockquote><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a><strong>解决办法</strong></h2><p>一般有2种解决办法：</p><blockquote><p>(1)不使用迭代器遍历集合,就可以在遍历的时候使用集合的方法进行增加或删除</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">res.add(<span class="string">"a"</span>);</span><br><span class="line">res.add(<span class="string">"b"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(res.get(i) == <span class="string">"a"</span>)</span><br><span class="line">        res.add(<span class="string">"c"</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><blockquote><p>(2)依然使用迭代器遍历,那么就需要使用Iterator的子接口ListIterator来实现向集合中添加</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ListIterator lit = res.listIterator();</span><br><span class="line"><span class="keyword">while</span>(lit.hasNext()) &#123;</span><br><span class="line">String s = (String)lit.next();</span><br><span class="line"><span class="keyword">if</span>(s.equals(<span class="string">"a"</span>)) &#123;</span><br><span class="line">lit.add(<span class="string">"c"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他解决同步问题的办法：</p><blockquote><p>(3)在使用iterator迭代的时候使用synchronized或者Lock进行同步；</p></blockquote><blockquote><p>(4)使用并发容器CopyOnWriteArrayList代替ArrayList和Vector。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1551345094255&amp;amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;amp;imgtype=0&amp;amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;ConcurrentModificationException（并发修改异常）为什么会出现？怎么解决呢？&lt;br&gt;
    
    </summary>
    
      <category term="Languages" scheme="https://yoursite.com/categories/Languages/"/>
    
    
      <category term="Java" scheme="https://yoursite.com/tags/Java/"/>
    
      <category term="容器" scheme="https://yoursite.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="源码" scheme="https://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Java的艺术-Java容器(1)之容器基础</title>
    <link href="https://yoursite.com/2019/01/05/Java%E7%9A%84%E8%89%BA%E6%9C%AF-Java%E5%AE%B9%E5%99%A8(1)%E4%B9%8B%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80/"/>
    <id>https://yoursite.com/2019/01/05/Java的艺术-Java容器(1)之容器基础/</id>
    <published>2019-01-05T11:48:20.000Z</published>
    <updated>2019-03-14T07:40:16.081Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551345094255&amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;imgtype=0&amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png" alt="此处输入图片的描述"><br>详解JAVA容器。<br><a id="more"></a></p><h2 id="Java容器是什么？"><a href="#Java容器是什么？" class="headerlink" title="Java容器是什么？"></a><font color="red"><strong>Java容器是什么？</strong></font></h2><blockquote><p><strong>容器</strong>，顾名思义，就是盛东西的地方。我们的程序中经常要管理大量的对象，比如在学校的信息管理系统里，每一个学生的相关信息，都可以抽象成一个对象；再比如在web server的场景下，一个客户端可以抽象成一个对象。这些情况下，都会产生很多同类型的对象，这时候，我们就会把同一个类型的对象放到同一个容器中进行集中管理。</p></blockquote><blockquote><p><strong>Java的容器</strong>是前人为我们设计好的一套存储对象和数据的一套轮子，<br>通过使用Java中写好的容器API我们可以很方便的存储、操作我们的数据。</p></blockquote><blockquote><p><strong>容器的作用：</strong><br>Java容器类库是用来保存对象的，他有两种不同的概念：（1）<strong>Collection</strong>，独立元素的序列，这些元素都服从一条或多条规则。List、Set以及Queue都是Collection的一种，List必须按照顺序保存元素，而Set不能有重复元素，Queue需要按照排队规则来确定对象的顺序。（2）<strong>Map</strong>，Map是键值对类型，允许用户通过键来查找对象。Hash表允许我们使用另一个对象来查找某个对象。</p></blockquote><blockquote><p>为什么需要容器呢？<br><strong>《thinking in java》</strong>书中说：“如果一个程序只包含固定数量的且生命周期都已知的对象，那么这是一个非常简单的数据。”但是事实上，我们平时接触的程序都不是如此简单的，很多程序都是在运行时才知道需要创建什么对象、创建多少对象，因此很可能我们需要在任意时刻任意位置创建任意数量的对象。因此，不能依靠创建命名的引用持有每一个对象，因为不确定性，我们必须要动态的创建对象，保存对象（其实是对象的引用）。</p></blockquote><h2 id="Java常见容器"><a href="#Java常见容器" class="headerlink" title="Java常见容器"></a><font color="red"><strong>Java常见容器</strong></font></h2><h3 id="Java完整容器类结构"><a href="#Java完整容器类结构" class="headerlink" title="Java完整容器类结构"></a>Java完整容器类结构</h3><p><img src="https://s2.ax1x.com/2019/03/07/kxN22n.md.jpg" alt="此处输入图片的描述"></p><h3 id="详细结构及概述"><a href="#详细结构及概述" class="headerlink" title="详细结构及概述"></a><strong>详细结构及概述</strong></h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a><strong>结构</strong></h4><p><strong>Collection</strong>接口<br>　├<strong>List</strong>接口<br>　　│├LinkedList 双向链表，顺序访问，快速增删，栈、队列、双向队列<br>　　│├ArrayList 顺序结构动态数组实现，随机访问<br>　　│└Vector 向量<br>　　　│└Stack 栈<br>　├<strong>Set</strong>接口<br>　　│├TreeSet 红黑树实现，有序，查找O(logN)<br>　　│├HashSet 哈希表实现，无序，查找O(1)<br>　　　│└LinkedHashSet<br>　├<strong>Queue</strong>接口<br>　　│├PriorityQueue 堆实现，可实现优先队列<br>　　│└LinkedList 双向链表，顺序访问，快速增删，栈、队列、双向队列<br><strong>Map</strong>接口<br>　├<strong>HashMap</strong> 哈希表实现，线程不安全<br>　　├Hashtable 线程安全，现为ConcurrentHashMap替换，分段锁<br>　├<strong>TreeMap</strong> 红黑树实现<br>　　├LinkedHashMap 双向链表实现<br>　　├WeakHashMap<br>　　└IdentityHashMap</p><h4 id="一句话概括常用不同容器类"><a href="#一句话概括常用不同容器类" class="headerlink" title="一句话概括常用不同容器类"></a><strong>一句话概括常用不同容器类</strong></h4><p>参考<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">Github</a></p><blockquote><p><strong>1.Set</strong><br>1.1 <strong>TreeSet</strong>：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。<br>1.2 <strong>HashSet</strong>：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。<br>1.3 <strong>LinkedHashSet</strong>：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</p></blockquote><blockquote><p><strong>2.List</strong><br>2.1 <strong>ArrayList</strong>：基于动态数组实现，支持随机访问。<br>2.2 <strong>Vector</strong>：和 ArrayList 类似，但它是线程安全的。<br>2.3 <strong>LinkedList</strong>：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间<br>插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</p></blockquote><blockquote><p><strong>3.Queue</strong><br>3.1 <strong>LinkedList</strong>：可以用它来实现双向队列。<br>3.2 <strong>PriorityQueue</strong>：基于堆结构实现，可以用它来实现优先队列。</p></blockquote><blockquote><p><strong>4.Map</strong><br>4.1 <strong>TreeMap</strong>：基于红黑树实现。<br>4.2 <strong>HashMap</strong>：基于哈希表实现。<br>4.3 <strong>HashTable</strong>：和 HashMap类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用ConcurrentHashMap 来支持线程安全，并且ConcurrentHashMap 的效率会更高，因为ConcurrentHashMap引入了分段锁。<br>4.4 <strong>LinkedHashMap</strong>：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（ LRU） 顺序。</p></blockquote><hr><blockquote><p><strong>接下来，详细比较不同容器的区别和联系！</strong></p></blockquote><h2 id="顶层接口-Collections接口"><a href="#顶层接口-Collections接口" class="headerlink" title="顶层接口-Collections接口"></a><font color="red"><strong>顶层接口-Collections接口</strong></font></h2><p>Collection是序列容器的顶级接口，这个interface定义了序列容器必须实现的所有成员方法。</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a><strong>常用方法</strong></h3><p>包括：容器容量，判断是否为空，检查容器元素，迭代器，增删等操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line">     <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">     Object[] toArray();</span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="List接口及常用实现类"><a href="#List接口及常用实现类" class="headerlink" title="List接口及常用实现类"></a><font color="red"><strong>List接口及常用实现类</strong></font></h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>实现List接口的常用类有LinkedList，ArrayList，Vector和Stack。</p></blockquote><blockquote><p>LinkedList、ArrayList都实现了List接口，都是不同步的，线程不安全，元素是有序的、可重复。</p></blockquote><blockquote><p>一般情况下使用LinkedList、ArrayList这两个就可以了，因为非同步，所以<strong>效率比较高</strong>。</p></blockquote><blockquote><p>ArrayList的随机访问效率较好，但是插入、删除元素较慢；LinkedList提供了优化的顺序访问，随机访问逊色于ArrayList，但插入、删除的代价较低。</p></blockquote><blockquote><p>总之，如果涉及到<strong>堆栈，队列</strong>等操作，应该考虑用List，对于需要<strong>快速插入，删除元素</strong>，应该使用LinkedList，如果需要<strong>快速随机</strong>访问元素，应该使用ArrayList。</p></blockquote><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a><strong>LinkedList</strong></h3><blockquote><p>基于双向链表的数据结构，允许null元素，增加、删除、修改元素方面效率比ArrayList高。</p></blockquote><blockquote><p>LinkedList提供额外的get，remove，insert方法在 LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。</p></blockquote><blockquote><p><strong>注意:LinkedList没有同步方法。</strong>如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：List list = Collections.synchronizedList(new LinkedList(…));</p></blockquote><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a><strong>ArrayList</strong></h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote><p>基于顺序结构的动态数组的数据结构，不同步，线程不安全，查询（get，set）效率高。</p></blockquote><blockquote><p>size()，isEmpty()，get()，set()方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。</p></blockquote><h4 id="Array和ArrayList的区别及各自适用的场景："><a href="#Array和ArrayList的区别及各自适用的场景：" class="headerlink" title="Array和ArrayList的区别及各自适用的场景："></a><strong>Array和ArrayList的区别及各自适用的场景：</strong></h4><blockquote><p>Array是数组，ArrayList是Array的加强版。</p></blockquote><blockquote><p>（1）array可以保存基本类型和对象类型，arrayList只能保存对象类型</p></blockquote><blockquote><p>（2）array数组的大小是固定的不能更改，而ArrayList的大小可以改变</p></blockquote><blockquote><p>（3）Array数组在存放的时候一定是同种类型的元素。ArrayList就不一定了，因为ArrayList可以存储Object。</p></blockquote><blockquote><p>（4）ArrayList有更加丰富的方法如addAll（）、removeAll()、iterator()</p></blockquote><blockquote><p><strong>适用场景：</strong><br>如果想要保存一些在整个程序运行期间都会存在而且不变的数据，我们可以将它们放进一个全局数组里，但是如果我们单纯只是想要以数组的形式保存数据，而不对数据进行增加等操作，只是方便我们进行查找的话，那么，我们就选择ArrayList。</p><p>如果我们需要对元素进行频繁的移动或删除，或者是处理的是超大量的数据，那么，使用ArrayList就真的不是一个好的选择，因为它的效率很低，使用数组进行这样的动作就很麻烦，那么，我们可以考虑选择LinkedList。</p></blockquote><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a><strong>Vector</strong></h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><blockquote><p>Vector类似ArrayList，但是Vector是<strong>线程同步</strong>的。由Vector创建的Iterator，虽然和ArrayList创建的 Iterator是同一接口，但是，因为Vector是同步的，当一个Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出ConcurrentModificationException，因此必须捕获该异常。</p></blockquote><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a><strong>Stack</strong></h3><blockquote><p>Stack继承自Vector，实现一个<strong>后进先出的堆栈</strong>。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop方法，还有 peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。</p></blockquote><hr><h2 id="Set接口及常用实现类"><a href="#Set接口及常用实现类" class="headerlink" title="Set接口及常用实现类"></a><font color="red"><strong>Set接口及常用实现类</strong></font></h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><blockquote><p>Set容器类主要有<strong>HashSet</strong>和<strong>TreeSet</strong>等。<br>元素不重复。</p></blockquote><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a><strong>HashSet</strong></h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><blockquote><p>允许包含值为null的元素，但最多只能有一个null元素。</p><p>基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</p></blockquote><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a><strong>TreeSet</strong></h3><blockquote><p>TreeSet基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</p></blockquote><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a><strong>LinkedHashSet</strong></h3><blockquote><p>LinkedHashSet的实现借助LinkedHashMap使用适配器模式实现的。具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</p></blockquote><hr><h2 id="Map接口及常用实现类"><a href="#Map接口及常用实现类" class="headerlink" title="Map接口及常用实现类"></a><font color="red"><strong>Map接口及常用实现类</strong></font></h2><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><blockquote><p>Map没有继承Collection接口，Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个value。Map接口提供3种集合的视图，Map的内容可以被当作一组key集合，一组value集合，或者一组key-value映射。</p></blockquote><blockquote><p>主要方法：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span><span class="comment">//比较对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span><span class="comment">//删除一个对象</span></span></span><br><span class="line"><span class="function"><span class="title">put</span><span class="params">(Object key,Object value)</span><span class="comment">//添加key和value</span></span></span><br></pre></td></tr></table></figure><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a><strong>TreeMap</strong></h3><h4 id="TreeMap-和-TreeSet"><a href="#TreeMap-和-TreeSet" class="headerlink" title="TreeMap 和 TreeSet"></a><strong>TreeMap 和 TreeSet</strong></h4><p>TreeSet是借助TreeMap实现的的适配器模式的体现。TreeMap懂了TreeSet也了解了，TreeMap实现了SortedMap接口，会根据key的大小对Map中的元素进行排序。key的大小判断在没有传入比较器Comparator的情况下通过自身的自然顺序比较。TreeMap底层通过红黑树实现</p><p><strong>红黑树</strong>是一颗近似平衡的二叉查找树，任何一个节点的左右子树高度差不会超过二者中较低的那个的一倍，TreeMap的每个节点即为一个键值对，红黑树的特性如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(1)每个节点要么是黑色，要么是红色</span><br><span class="line">(2)根节点必须为黑色</span><br><span class="line">(3)红色节点不能连续，即红色节点的孩子和父亲只能是黑色</span><br><span class="line">(4)任何节点到树的末端的任何路径包含的黑色节点个数相同</span><br><span class="line">(5)每次对红黑树操作后都要使其满足上述条件，调整红黑树的策略主要是：</span><br><span class="line"> - 改变节点颜色；</span><br><span class="line"> - 改变树的结构（左旋操作、右旋操作）</span><br></pre></td></tr></table></figure></p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a><strong>HashMap</strong></h3><h4 id="HashTable和HashMap"><a href="#HashTable和HashMap" class="headerlink" title="HashTable和HashMap"></a>HashTable和HashMap</h4><blockquote><p>第一、继承不同。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span> <span class="keyword">extends</span> <span class="title">Dictionary</span> <span class="keyword">implements</span> <span class="title">Map</span></span></span><br><span class="line"><span class="class">　　<span class="title">public</span> <span class="title">class</span> <span class="title">HashMap</span>  <span class="keyword">extends</span> <span class="title">AbstractMap</span> <span class="keyword">implements</span> <span class="title">Map</span></span></span><br></pre></td></tr></table></figure><blockquote><p>第二、Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。</p></blockquote><blockquote><p>第三、Hashtable中，key和value都不允许出现null值。在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。</p></blockquote><blockquote><p>第四、两个遍历方式的内部实现上不同。Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。</p></blockquote><blockquote><p>第五、哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。</p></blockquote><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a><strong>LinkedHashMap</strong></h3><p>LinkedHashMap实现了Map接口，即允许放入key为null的元素，也允许插入value为null的元素。从名字上可以看出该容器是linked list和HashMap的混合体，也就是说它同时满足HashMap和linked list的某些特性。可将LinkedHashMap看作采用LinkedList增强的HashMap。</p><h4 id="LinkedHashMap-和-LinkedHashSet"><a href="#LinkedHashMap-和-LinkedHashSet" class="headerlink" title="LinkedHashMap 和 LinkedHashSet:"></a><strong>LinkedHashMap 和 LinkedHashSet:</strong></h4><blockquote><p>LinkedHashSet和LinkedHashMap在Java里也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说LinkedHashSet里面有一个LinkedHashMap（适配器模式）。</p></blockquote><blockquote><p>LinkedHashMap是HashMap的子类，二者唯一的区别是LinkedHashMap在HashMap的基础上，采用双向链表（doubly-linkedlist）的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同。上图给出了LinkedHashMap的结构图，主体部分跟HashMap完全一样，多了header指向双向链表的头部（是一个哑元），该双向链表的迭代顺序就是entry的插入顺序。</p></blockquote><blockquote><p>LinkedHashMap在遍历的时候不同于HashMap需要先遍历整个table，LinkedHashMap只需要遍历header指向的双向链表即可，因此LinkedHashMap的迭代时间只和entry数量相关。其他的包括初始容量、负载因子以及hashCode、equals方法基本和HashMap一致。</p></blockquote><h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a><strong>WeakHashMap</strong></h3><blockquote><p>WeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。</p></blockquote><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a><strong>ConcurrentHashMap</strong></h3><p>HashMap不是线程安全的，HashTable是线程安全的，但是其安全性由全局锁保证，因此效率很低。而ConcurrentHashMap 是将锁的范围细化来实现高效并发的。 基本策略是将数据结构分为一个一个 Segment（每一个都是一个并发可读的 hash table， 即分段锁）作为一个并发单元。 为了减少开销， 除了一处 Segment 是在构造器初始化的， 其他都延迟初始化。 并使用 volatile 关键字来保证 Segment 延迟初始化的可见性问题。</p><blockquote><p>jdk1.8对ConcurrentHashMap做了一些改进：</p></blockquote><blockquote><p><strong>改进一</strong>：取消segments字段，直接采用transient volatile HashEntry&lt; K,V&gt;[] table保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。</p></blockquote><blockquote><p><strong>改进二</strong>：将原先table数组＋单向链表的数据结构，变更为table数组＋单向链表＋红黑树的结构。在冲突链表长度过长的情况，如果还是采用单向链表方式，那么查询某个节点的时间复杂度为O(n)；因此，对于个数超过8(默认值)的列表，jdk1.8中采用了红黑树的结构，那么查询的时间复杂度可以降低到O(logN)，可以改进性能。</p></blockquote><h2 id="容器的遍历"><a href="#容器的遍历" class="headerlink" title="容器的遍历"></a><font color="red"><strong>容器的遍历</strong></font></h2><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a><strong>迭代器模式</strong></h3><p>Collection 实现了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = container.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">　　Object obj = it.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="List遍历"><a href="#List遍历" class="headerlink" title="List遍历"></a><strong>List遍历</strong></h3><p>主要有三种：<br>第一种：迭代器+for<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator iterator = list.iterator();iterator.hasNext();)&#123;                    </span><br><span class="line">    <span class="keyword">int</span> i = (Integer) iterator.next();                   </span><br><span class="line">    System.out.println(i);               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二种：迭代器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    <span class="keyword">int</span> i = (Integer) iterator.next();<span class="comment">//注意next()返回的是Object对象！！</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第三种：增强for<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Object object : list) &#123;</span><br><span class="line">    System.out.println(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第四种：普通for<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;list.size();i++) &#123;  </span><br><span class="line">    <span class="keyword">int</span> j= (Integer) list.get(i);</span><br><span class="line">    System.out.println(j);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Map遍历"><a href="#Map遍历" class="headerlink" title="Map遍历"></a><strong>Map遍历</strong></h3><p><strong>有四种：</strong></p><p>第一种：通过获取所有的key按照key来遍历<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Set&lt;Integer&gt; set = map.keySet(); //得到所有key的集合</span></span><br><span class="line"><span class="keyword">for</span> (Integer in : map.keySet()) &#123;</span><br><span class="line">    String str = map.get(in);<span class="comment">//得到每个key多对用value的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二种：通过Map.entrySet使用iterator遍历key和value<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">     Map.Entry&lt;Integer, String&gt; entry = it.next();</span><br><span class="line">       System.out.println(<span class="string">"key= "</span> + entry.getKey() + <span class="string">" and value= "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意，用迭代器遍历Map时，Map没有iterator()方法，所以需要用entrySet()得到Set对象，再调用iterator()得到迭代器对象。</p></blockquote><p>第三种：通过Map.entrySet遍历key和value，<strong>推荐，尤其是容量大时</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="comment">//Map.entry&lt;Integer,String&gt; 映射项（键-值对）  有几个方法：用上面的名字entry</span></span><br><span class="line">    <span class="comment">//entry.getKey() ;entry.getValue(); entry.setValue();</span></span><br><span class="line">    <span class="comment">//map.entrySet()  返回此映射中包含的映射关系的 Set视图。</span></span><br><span class="line">    System.out.println(<span class="string">"key= "</span> + entry.getKey() + <span class="string">" and value= "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第四种：通过Map.values()遍历所有的value，但不能遍历key<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String v : map.values()) &#123;</span><br><span class="line">    System.out.println(<span class="string">"value= "</span> + v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong>参考：</strong><br><a href="https://blog.csdn.net/qq_37465368/article/details/80854672https://blog.csdn.net/qq_37465368/article/details/80854672" target="_blank" rel="noopener">Java常见的容器类及其区别</a><br><a href="https://blog.csdn.net/dandanzmc/article/details/23447827" target="_blank" rel="noopener">Java中的容器</a><br><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">一份涵盖大部分Java程序员所需要掌握的核心知识</a><br><a href="https://blog.csdn.net/starlh35/article/details/79262472" target="_blank" rel="noopener">深入整理java集合容器</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1551345094255&amp;amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;amp;imgtype=0&amp;amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;详解JAVA容器。&lt;br&gt;
    
    </summary>
    
      <category term="Languages" scheme="https://yoursite.com/categories/Languages/"/>
    
    
      <category term="Java" scheme="https://yoursite.com/tags/Java/"/>
    
      <category term="容器" scheme="https://yoursite.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>keras模型拼接</title>
    <link href="https://yoursite.com/2018/12/25/keras%E6%A8%A1%E5%9E%8B%E6%8B%BC%E6%8E%A5/"/>
    <id>https://yoursite.com/2018/12/25/keras模型拼接/</id>
    <published>2018-12-25T12:48:20.000Z</published>
    <updated>2019-03-05T07:22:22.896Z</updated>
    
    <content type="html"><![CDATA[<p><strong>在模型测试过程中，如何让两个模型中间层的输入输出拼在一起呢？</strong><br><img src="https://upgrad.com/blog/wp-content/uploads/2018/04/keras0.png" alt="此处输入图片的描述"></p><a id="more"></a><p>首先，加载训练好的模型后，我们可以用下面的方式获取模型的中间层输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = load_model(&quot;model1.h5&quot;)</span><br><span class="line">First_model = Model(inputs=model.input, outputs=model.layers[7].output)#表示获取模型第7层的输出</span><br></pre></td></tr></table></figure></p><p>然后如何把第7层的输出，作为下一个模型中间层的输入呢？用下面的方法是不可以的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model2 = load_model(&quot;model2.h5&quot;)</span><br><span class="line">second_model = Model(inputs=model2.layers[8].input, outputs=model2.layers[-1].output)</span><br></pre></td></tr></table></figure></p><p>这样会得到类似下面的错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RuntimeError: Graph disconnected: cannot obtain value for tensor Tensor(&quot;conv2d_1_input:0&quot;, shape=(?, 144, 144, 3), dtype=float32) at layer &quot;conv2d_1_input&quot;. The following previous layers were accessed without issue: []</span><br></pre></td></tr></table></figure></p><p>解决办法是声明一个新的Input Layer,用下面的方式拼接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">second_input = Input(model.layers[8].input_shape[1:])</span><br><span class="line">second_model = second_input</span><br><span class="line">for layer in model.layers[8:]:</span><br><span class="line">    second_model = layer(second_model)</span><br><span class="line">second_model = Model(inputs=second_input, outputs=second_model)</span><br></pre></td></tr></table></figure></p><p>由此，便完成了模型的拼接！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;在模型测试过程中，如何让两个模型中间层的输入输出拼在一起呢？&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://upgrad.com/blog/wp-content/uploads/2018/04/keras0.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="https://yoursite.com/categories/Machine-Learning/"/>
    
    
      <category term="python" scheme="https://yoursite.com/tags/python/"/>
    
      <category term="keras" scheme="https://yoursite.com/tags/keras/"/>
    
  </entry>
  
  <entry>
    <title>数据库(3)-JDBC</title>
    <link href="https://yoursite.com/2018/12/07/%E6%95%B0%E6%8D%AE%E5%BA%93(3)-JDBC/"/>
    <id>https://yoursite.com/2018/12/07/数据库(3)-JDBC/</id>
    <published>2018-12-07T11:48:20.000Z</published>
    <updated>2019-03-17T04:07:40.214Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/03/14/AAvGd0.jpg" alt="此处输入图片的描述"><br>JAVA数据库连接JDBC、以及DAO模式的使用。</p><a id="more"></a><h2 id="JDBC概述"><a href="#JDBC概述" class="headerlink" title="JDBC概述"></a>JDBC概述</h2><p>Java 数据库连接，<code>（Java Database Connectivity，简称JDBC）</code>是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。JDBC也是Sun Microsystems的商标。它JDBC是面向关系型数据库的。<br><strong>即用于执行SQL语句的JAVA API。</strong></p><h2 id="一、安装和配置"><a href="#一、安装和配置" class="headerlink" title="一、安装和配置"></a>一、安装和配置</h2><p>直接按照教程，话不多说。<br><a href="https://www.jb51.net/article/23876.htm" target="_blank" rel="noopener">MySQL安装图解</a></p><h2 id="二、下载数据库对应的jar包"><a href="#二、下载数据库对应的jar包" class="headerlink" title="二、下载数据库对应的jar包"></a>二、下载数据库对应的jar包</h2><blockquote><p>（1）在<a href="https://dev.mysql.com/downloads/connector/j/" target="_blank" rel="noopener">MySQL官网页面</a>,选择对应系统的文件。如果是<strong>windows</strong>系统，选择<strong>Platform Independent</strong>对应的jar包即可。</p></blockquote><blockquote><p>（2）复制<strong>mysql-connector-java-8.0.15.jar</strong>包到你的\jre1.8.0_181\lib\ext文件夹下。</p></blockquote><h2 id="三、JDBC基本操作"><a href="#三、JDBC基本操作" class="headerlink" title="三、JDBC基本操作"></a>三、<strong>JDBC基本操作</strong></h2><h3 id="1-使用的基本步骤"><a href="#1-使用的基本步骤" class="headerlink" title="(1)使用的基本步骤"></a><strong>(1)使用的基本步骤</strong></h3><blockquote><p>a.注册驱动<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DriverManager.registerDriver(<span class="keyword">new</span> com.mysql.jdbc.Driver());</span><br><span class="line"><span class="comment">//上面这种方法相当于注册两次驱动，因此没有必要，最好用下面这种代码：</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"><span class="comment">//上面已经deprecated</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>b.建立连接<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 一个参数，用&amp;隔开</span></span><br><span class="line">DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost/database_name?user=user&amp;password=password"</span>);</span><br><span class="line"><span class="comment">//2. 建立连接 参数一： 协议 + 访问的数据库 ， 参数二： 用户名 ， 参数三： 密码。</span></span><br><span class="line">conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost/database_name"</span>, <span class="string">"user"</span>, <span class="string">"password"</span>);</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>c.创建statement<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3. 创建statement对象 ，很重要的一个类</span></span><br><span class="line">st = conn.createStatement();</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>d.执行sql ，得到ResultSet<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4. 执行查询 ， 得到结果集</span></span><br><span class="line">String sql = <span class="string">"select * from table_name"</span>;</span><br><span class="line">rs = st.executeQuery(sql);</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>e.遍历结果集<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5. 遍历查询每一条记录</span></span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">   <span class="keyword">int</span> id = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">   String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">   <span class="keyword">int</span> age = rs.getInt(<span class="string">"age"</span>);</span><br><span class="line">   System.out.println(<span class="string">"id="</span>+id + <span class="string">"===name="</span>+name+<span class="string">"==age="</span>+age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>f.释放资源<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        rs.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException sqlEx) &#123; &#125;</span><br><span class="line">    rs = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="2-JDBC数据库CURD对应的SQL语句"><a href="#2-JDBC数据库CURD对应的SQL语句" class="headerlink" title="(2)JDBC数据库CURD对应的SQL语句"></a>(2)<strong>JDBC数据库CURD对应的SQL语句</strong></h3><blockquote><p>通过代码示例了解如何通过JDBC对数据库进行增删改查的任务。</p></blockquote><h4 id="A-Insert"><a href="#A-Insert" class="headerlink" title="A. Insert"></a>A. Insert</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获取连接对象</span></span><br><span class="line">conn = JDBCUtil.getConn();</span><br><span class="line"><span class="comment">// 2. 根据连接对象，得到statement对象</span></span><br><span class="line">st = conn.createStatement();</span><br><span class="line"><span class="comment">// 3. 执行添加</span></span><br><span class="line">String sql = <span class="string">"insert into t_stu values(null , 'wufan' , 99)"</span>;</span><br><span class="line"><span class="comment">//返回影响的行数，如果大于0表明操作成功。否则失败</span></span><br><span class="line"><span class="keyword">int</span> result = st.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(result &gt;<span class="number">0</span> )&#123;</span><br><span class="line">System.out.println(<span class="string">"添加成功"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"添加失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="B-Delete"><a href="#B-Delete" class="headerlink" title="B. Delete"></a>B. Delete</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获取连接对象</span></span><br><span class="line">conn = JDBCUtil.getConn();</span><br><span class="line"><span class="comment">// 2. 根据连接对象，得到statement</span></span><br><span class="line">st = conn.createStatement();</span><br><span class="line"><span class="comment">// 3. 执行删除</span></span><br><span class="line">String sql = <span class="string">"delete from t_stu where name='wufan'"</span>;</span><br><span class="line"><span class="comment">//返回影响的行数，如果大于0表明操作成功。否则失败</span></span><br><span class="line"><span class="keyword">int</span> result = st.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(result &gt;<span class="number">0</span> )&#123;</span><br><span class="line">System.out.println(<span class="string">"删除成功"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"删除失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="C-Query"><a href="#C-Query" class="headerlink" title="C. Query"></a>C. Query</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获取连接对象</span></span><br><span class="line">conn = JDBCUtil.getConn();</span><br><span class="line"><span class="comment">// 2. 根据连接对象，得到statement</span></span><br><span class="line">st = conn.createStatement();</span><br><span class="line"><span class="comment">// 3. 执行返回ResultSet.</span></span><br><span class="line">String sql = <span class="string">"select * from t_stu"</span>;</span><br><span class="line">rs = st.executeQuery(sql);</span><br><span class="line"><span class="comment">// 4. 遍历结果集</span></span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line"><span class="keyword">int</span> age = rs.getInt(<span class="string">"age"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(name + <span class="string">"   "</span> + age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="D-Update"><a href="#D-Update" class="headerlink" title="D. Update"></a>D. Update</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获取连接对象</span></span><br><span class="line">conn = JDBCUtil.getConn();</span><br><span class="line"><span class="comment">// 2. 根据连接对象，得到statement</span></span><br><span class="line">st = conn.createStatement();</span><br><span class="line"><span class="comment">// 3. 执行更新</span></span><br><span class="line">String sql = <span class="string">"update t_stu set age = 16 where name ='wufan'"</span>;</span><br><span class="line"><span class="comment">//返回影响的行数，如果大于0表明操作成功。否则失败</span></span><br><span class="line"><span class="keyword">int</span> result = st.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(result &gt;<span class="number">0</span> )&#123;</span><br><span class="line">System.out.println(<span class="string">"删除成功"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"删除失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、使用properties配置文件"><a href="#四、使用properties配置文件" class="headerlink" title="四、使用properties配置文件"></a>四、使用properties配置文件</h2><h3 id="1-关于Properties"><a href="#1-关于Properties" class="headerlink" title="(1)关于Properties"></a>(1)关于Properties</h3><blockquote><p>在JDBC中，Properties()是一种很方便的方法，不需要将url、user、password、driverClass写在代码方法中，而是写入配置文件，并通过调用配置文件实现。</p></blockquote><h3 id="2-使用properties链接数据库"><a href="#2-使用properties链接数据库" class="headerlink" title="(2)使用properties链接数据库"></a>(2)使用properties链接数据库</h3><blockquote><p>1.在src声明一个配置文件XXX.properties，内容如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">driverClass=com.mysql.jdbc.Driver</span><br><span class="line">url=jdbc:mysql://localhost:3306/database?useUnicode=true&amp;characterEncoding=utf8</span><br><span class="line">username=root</span><br><span class="line">password=root</span><br></pre></td></tr></table></figure><blockquote><p>2.在工具类中，使用静态代码块读取属性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String driverClass;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//1. 创建一个属性配置对象</span></span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"jdbc.properties"</span>); <span class="comment">//对应文件位于工程根目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1：使用当前类加载器，读取src底下的资源文件。</span></span><br><span class="line"><span class="comment">//InputStream is = JDBCUtil.class.getClassLoader().getResourceAsStream("jdbc.properties");</span></span><br><span class="line"><span class="comment">//方法2：导入输入流。</span></span><br><span class="line">properties.load(is);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取属性</span></span><br><span class="line">driverClass = properties.getProperty(<span class="string">"driverClass"</span>);</span><br><span class="line">url = properties.getProperty(<span class="string">"url"</span>);</span><br><span class="line">name = properties.getProperty(<span class="string">"name"</span>);</span><br><span class="line">password = properties.getProperty(<span class="string">"password"</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>获取连接：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(driverClass);</span><br><span class="line">            conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>释放资源：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(Connection conn, PreparedStatement pstmt, ResultSet rs)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               rs.close();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (pstmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               pstmt.close();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               conn.close();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>可以发现，这种方式能降低代码维护成本，解决了数据库更换的麻烦。</p></blockquote><h2 id="五、DAO模式"><a href="#五、DAO模式" class="headerlink" title="五、DAO模式"></a>五、DAO模式</h2><blockquote><p><strong>DAO: Data Access Object 数据访问对象</strong></p></blockquote><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>(1).隔离业务逻辑代码和数据访问代码,位于业务逻辑和持久化数据之间，实现对持久化数据的访问。<br>(2).隔离不同数据库的实现。</p><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><p>(1).DAO接口<br>(2).DAO实现类<br>(3).实体类<br>(4).数据库连接和关闭工具类</p><h3 id="直接上代码"><a href="#直接上代码" class="headerlink" title="直接上代码"></a>直接上代码</h3><p>(1).DAO接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DAO</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findeAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(2).DAO实现类(实体类略去)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: wufan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UerDao</span> <span class="keyword">implements</span> <span class="title">DAO</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findeAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement st = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 获取连接对象</span></span><br><span class="line">            conn = JDBCUtil.getConnection();</span><br><span class="line">            <span class="comment">//2. 创建statement对象</span></span><br><span class="line">            st = conn.createStatement();</span><br><span class="line">            String sql = <span class="string">"select * from user"</span>;</span><br><span class="line">            rs = st.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                String phone = rs.getString(<span class="string">"phone"</span>);</span><br><span class="line">                <span class="keyword">int</span> id = rs.getInt(<span class="string">"uid"</span>);</span><br><span class="line">                System.out.print(id+<span class="string">"\t"</span>+phone);</span><br><span class="line">                System.out.println(<span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtil.release(conn, st, rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UerDao ud = <span class="keyword">new</span> UerDao();</span><br><span class="line">        ud.findeAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(4).数据库连接和关闭工具类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: wufan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driverClass;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            <span class="comment">//InputStream is = JDBCUtil.class.getClassLoader().getResourceAsStream("JDBC.properties");</span></span><br><span class="line">            InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"P:\\Java\\Database\\src\\JDBC.properties"</span>); <span class="comment">//对应文件位于工程根目录</span></span><br><span class="line">            properties.load(is);</span><br><span class="line"></span><br><span class="line">            driverClass = properties.getProperty(<span class="string">"driverClass"</span>);</span><br><span class="line">            url = properties.getProperty(<span class="string">"url"</span>);</span><br><span class="line">            username = properties.getProperty(<span class="string">"username"</span>);</span><br><span class="line">            password = properties.getProperty(<span class="string">"password"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(driverClass);</span><br><span class="line">            conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(Connection conn, Statement pstmt, ResultSet rs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pstmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pstmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="六、PrepareStatement"><a href="#六、PrepareStatement" class="headerlink" title="六、PrepareStatement"></a>六、PrepareStatement</h2><blockquote><p>在需要传入参数的SQL语句中，替换<code>Statement</code>对象。</p></blockquote><blockquote><p>相比较以前的<code>Statemen</code>， 预先处理给定的sql语句，对其执行语法检查。 在sql语句里面使用<code>?</code>占位符来替代后续要传递进来的变量。后面进来的变量值，将会被看成是字符串，不会产生任何的关键字。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"insert into table_name values(? , ? , ?)"</span>;</span><br><span class="line">PrepareStatement ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">//给占位符赋值</span></span><br><span class="line"><span class="comment">//注意从左到右数过来，1 代表第一个问号， 永远从1开始。</span></span><br><span class="line">ps.setInt(<span class="number">1</span>,id);</span><br><span class="line">ps.setString(<span class="number">2</span>, userName);</span><br><span class="line">ps.setString(<span class="number">3</span>, phone);</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="七、遇到的错误"><a href="#七、遇到的错误" class="headerlink" title="七、遇到的错误"></a>七、遇到的错误</h2><blockquote><p>(1)time zone错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SQLException: The server time zone value &apos;ÖÐ¹ú±ê×¼Ê±¼ä&apos; is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.</span><br><span class="line">SQLState: 01S00</span><br><span class="line">VendorError: 0</span><br></pre></td></tr></table></figure></p></blockquote><p>这是由于数据库和系统时区差异所造成的，简单的方法是再url后面加上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverTimezone=GMT</span><br></pre></td></tr></table></figure></p><p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost/database_name?&quot;+&quot;user=root&amp;password=root&quot;+&quot;&amp;serverTimezone=GMT&quot;);</span><br></pre></td></tr></table></figure></p><blockquote><p>(2) java.io.FileNotFoundException: JDBC.properties (系统找不到指定的文件。)<br>解决办法1：使用类加载<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream is = JDBCUtil.class.getClassLoader().getResourceAsStream(<span class="string">"JDBC.properties"</span>);</span><br></pre></td></tr></table></figure></p></blockquote><p>办法2：改用全路径<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"P:\\Java\\Database\\src\\JDBC.properties"</span>);</span><br></pre></td></tr></table></figure></p><hr><p><strong>参考链接：</strong><br>1.<a href="https://blog.csdn.net/qq_36923376/article/details/83657127" target="_blank" rel="noopener">mysql-8.0.13使用jdbc与java连接教程</a><br>2.<a href="https://www.cnblogs.com/wuyuegb2312/p/3872607.html" target="_blank" rel="noopener">通过JDBC进行简单的增删改查（以MySQL为例）</a><br>3.《高性能MySQL》</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/03/14/AAvGd0.jpg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;JAVA数据库连接JDBC、以及DAO模式的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Database" scheme="https://yoursite.com/categories/Database/"/>
    
    
      <category term="数据库" scheme="https://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java的艺术-Java技术栈</title>
    <link href="https://yoursite.com/2018/12/05/Java%E7%9A%84%E8%89%BA%E6%9C%AF-Java%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    <id>https://yoursite.com/2018/12/05/Java的艺术-Java技术栈/</id>
    <published>2018-12-05T13:48:20.000Z</published>
    <updated>2019-03-07T02:52:56.016Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551345094255&amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;imgtype=0&amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png" alt="此处输入图片的描述"><br>当学Java迷茫的时候，不妨看看，激励一下自己！<br><a id="more"></a></p><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a><font color="red">基础篇</font></h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p><strong>→ 什么是面向对象</strong><br>面向对象、面向过程<br>面向对象的三大基本特征和五大基本原则<br><strong>→ 平台无关性</strong><br>Java 如何实现的平台无关<br>JVM 还支持哪些语言（Kotlin、Groovy、JRuby、Jython、Scala）<br><strong>→ 值传递</strong><br>值传递、引用传递<br>为什么说 Java 中只有值传递<br><strong>→ 封装、继承、多态</strong><br>什么是多态、方法重写与重载<br>Java 的继承与实现<br>构造函数与默认构造函数<br>类变量、成员变量和局部变量<br>成员变量和方法作用域</p><h3 id="Java-基础知识"><a href="#Java-基础知识" class="headerlink" title="Java 基础知识"></a>Java 基础知识</h3><p><strong>→ 基本数据类型</strong><br>8 种基本数据类型：整型、浮点型、布尔型、字符型<br>整型中 byte、short、int、long 的取值范围<br>什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？<br><strong>→ 自动拆装箱</strong><br>什么是包装类型、什么是基本类型、什么是自动拆装箱<br>Integer 的缓存机制<br><strong>→ String</strong><br>字符串的不可变性<br>JDK 6 和 JDK 7 中 substring 的原理及区别、<br>replaceFirst、replaceAll、replace 区别、<br>String 对“+”的重载、字符串拼接的几种方式和区别<br>String.valueOf 和 Integer.toString 的区别、<br>switch 对 String 的支持<br>字符串池、常量池（运行时常量池、Class 常量池）、intern<br><strong>→ 熟悉 Java 中各种关键字</strong><br>transient、instanceof、final、static、volatile、synchronized、const 原理及用法<br><strong>→ 集合类</strong><br>常用集合类的使用、ArrayList 和 LinkedList 和 Vector 的区别 、SynchronizedList 和 Vector 的区别、HashMap、HashTable、ConcurrentHashMap 区别、<br>Set 和 List 区别？Set 如何保证元素不重复？<br>Java 8 中 stream 相关用法、apache 集合处理工具类的使用、不同版本的 JDK 中 HashMap 的实现的区别以及原因<br>Collection 和 Collections 区别<br>Arrays.asList 获得的 List 使用时需要注意什么<br>Enumeration 和 Iterator 区别<br>fail-fast 和 fail-safe<br>CopyOnWriteArrayList、ConcurrentSkipListMap<br><strong>→ 枚举</strong><br>枚举的用法、枚举的实现、枚举与单例、Enum 类<br>Java 枚举如何比较<br>switch 对枚举的支持<br>枚举的序列化如何实现<br>枚举的线程安全性问题<br><strong>→ IO</strong><br>字符流、字节流、输入流、输出流、<br>同步、异步、阻塞、非阻塞、Linux 5 种 IO 模型<br>BIO、NIO 和 AIO 的区别、三种 IO 的用法与原理、netty<br><strong>→ 反射</strong><br>反射与工厂模式、反射有什么用<br>Class 类、java.lang.reflect.*<br><strong>→ 动态代理</strong><br>静态代理、动态代理<br>动态代理和反射的关系<br>动态代理的几种实现方式<br>AOP<br><strong>→ 序列化</strong><br>什么是序列化与反序列化、为什么序列化、序列化底层原理、序列化与单例模式、protobuf、为什么说序列化并不安全</p><p><strong>→ 注解</strong><br>元注解、自定义注解、Java 中常用注解使用、注解与反射的结合<br>Spring 常用注解<br><strong>→ JMS</strong><br>什么是 Java 消息服务、JMS 消息传送模型<br><strong>→ JMX</strong><br>java.lang.management.<em>、 javax.management.</em><br><strong>→ 泛型</strong><br>泛型与继承、类型擦除、泛型中 KTVE? object 等的含义、泛型各种用法<br>限定通配符和非限定通配符、上下界限定符 extends 和 super<br>List<object> 和原始类型 List 之间的区别?<br>List&lt;?&gt; 和 List<object> 之间的区别是什么?<br><strong>→ 单元测试</strong><br>junit、mock、mockito、内存数据库（h2）<br><strong>→ 正则表达式</strong><br>java.lang.util.regex.<em><br><strong>→ 常用的 Java 工具库</strong><br>commons.lang、commons.</em>…、 guava-libraries、 netty<br><strong>→ API &amp; SPI</strong><br>API、API 和 SPI 的关系和区别<br>如何定义 SPI、SPI 的实现原理<br><strong>→ 异常</strong><br>异常类型、正确处理异常、自定义异常<br>Error 和 Exception<br>异常链、try-with-resources<br>finally 和 return 的执行顺序<br><strong>→ 时间处理</strong><br>时区、冬令时和夏令时、时间戳、Java 中时间 API<br>格林威治时间、CET,UTC,GMT,CST 几种常见时间的含义和关系<br>SimpleDateFormat 的线程安全性问题<br>Java 8 中的时间处理<br>如何在东八区的计算机上获取美国时间<br><strong>→ 编码方式</strong><br>Unicode、有了 Unicode 为啥还需要 UTF-8<br>GBK、GB2312、GB18030 之间的区别<br>UTF8、UTF16、UTF32 区别<br>URL 编解码、Big Endian 和 Little Endian<br>如何解决乱码问题<br><strong>→ 语法糖</strong><br>Java 中语法糖原理、解语法糖<br>语法糖：switch 支持 String 与枚举、泛型、自动装箱与拆箱、方法变长参数、枚举、内部类、条件编译、 断言、数值字面量、for-each、try-with-resource、Lambda 表达式</object></object></p><h3 id="阅读源代码"><a href="#阅读源代码" class="headerlink" title="阅读源代码"></a>阅读源代码</h3><p>String、Integer、Long、Enum、<br>BigDecimal、ThreadLocal、ClassLoader &amp; URLClassLoader、<br>ArrayList &amp; LinkedList、<br>HashMap &amp; LinkedHashMap &amp; TreeMap &amp; CouncurrentHashMap、HashSet &amp; LinkedHashSet &amp; TreeSet</p><h3 id="Java-并发编程"><a href="#Java-并发编程" class="headerlink" title="Java 并发编程"></a>Java 并发编程</h3><p><strong>→ 并发与并行</strong><br>什么是并发、什么是并行<br>并发与并行的区别<br><strong>→ 什么是线程，与进程的区别</strong><br>线程的实现、线程的状态、优先级、线程调度、创建线程的多种方式、守护线程<br>线程与进程的区别<br><strong>→ 线程池</strong><br>自己设计线程池、submit() 和 execute()、线程池原理<br>为什么不允许使用 Executors 创建线程池<br><strong>→ 线程安全</strong><br>死锁、死锁如何排查、线程安全和内存模型的关系<br><strong>→ 锁</strong><br>CAS、乐观锁与悲观锁、数据库相关锁机制、分布式锁、偏向锁、轻量级锁、重量级锁、monitor、<br>锁优化、锁消除、锁粗化、自旋锁、可重入锁、阻塞锁、死锁<br><strong>→ 死锁</strong><br>什么是死锁<br>死锁如何解决<br><strong>→ synchronized</strong><br>synchronized 是如何实现的？<br>synchronized 和 lock 之间关系、不使用 synchronized 如何实现一个线程安全的单例<br>synchronized 和原子性、可见性和有序性之间的关系<br><strong>→ volatile</strong><br>happens-before、内存屏障、编译器指令重排和 CPU 指令重<br>volatile 的实现原理<br>volatile 和原子性、可见性和有序性之间的关系<br>有了 symchronized 为什么还需要 volatile<br><strong>→ sleep 和 wait</strong><br><strong>→ wait 和 notify</strong><br><strong>→ notify 和 notifyAll</strong><br><strong>→ ThreadLocal</strong><br><strong>→ 写一个死锁的程序</strong><br><strong>→ 写代码来解决生产者消费者问题</strong><br><strong>→ 并方包</strong><br>Thread、Runnable、Callable、ReentrantLock、ReentrantReadWriteLock、Atomic*、Semaphore、CountDownLatch、ConcurrentHashMap、Executors</p><h2 id="底层篇"><a href="#底层篇" class="headerlink" title="底层篇"></a><font color="red">底层篇</font></h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p><strong>→ JVM 内存结构</strong><br>class 文件格式、运行时数据区：堆、栈、方法区、直接内存、运行时常量池、<br>堆和栈区别<br>Java 中的对象一定在堆上分配吗？</p><p><strong>→ Java 内存模型</strong><br>计算机内存模型、缓存一致性、MESI 协议<br>可见性、原子性、顺序性、happens-before、<br>内存屏障、synchronized、volatile、final、锁<br><strong>→ 垃圾回收</strong><br>GC 算法：标记清除、引用计数、复制、标记压缩、分代回收、增量式回收<br>GC 参数、对象存活的判定、垃圾收集器（CMS、G1、ZGC、Epsilon）<br><strong>→ JVM 参数及调优</strong><br>-Xmx、-Xmn、-Xms、Xss、-XX:SurvivorRatio、<br>-XX:PermSize、-XX:MaxPermSize、-XX:MaxTenuringThreshold<br><strong>→ Java 对象模型</strong><br>oop-klass、对象头<br><strong>→ HotSpot</strong><br>即时编译器、编译优化<br><strong>→ 虚拟机性能监控与故障处理工具</strong><br>jps, jstack, jmap, jstat, jconsole, jinfo, jhat, javap, btrace, TProfiler<br>Arthas</p><h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>classLoader、类加载过程、双亲委派（破坏双亲委派）、模块化（jboss modules、osgi、jigsaw）</p><h3 id="编译与反编译"><a href="#编译与反编译" class="headerlink" title="编译与反编译"></a>编译与反编译</h3><p>什么是编译（前端编译、后端编译）、什么是反编译<br>JIT、JIT 优化（逃逸分析、栈上分配、标量替换、锁优化）<br>编译工具：javac<br>反编译工具：javap 、jad 、CRF</p><h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a><font color="red">进阶篇</font></h2><h3 id="Java-底层知识"><a href="#Java-底层知识" class="headerlink" title="Java 底层知识"></a>Java 底层知识</h3><p><strong>→ 字节码、class 文件格式</strong><br><strong>→ CPU 缓存，L1，L2，L3 和伪共享</strong><br><strong>→ 尾递归</strong><br><strong>→ 位运算</strong><br>用位运算实现加、减、乘、除、取余</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>设计模式的六大原则：<br>开闭原则（Open Close Principle）、里氏代换原则（Liskov Substitution Principle）、依赖倒转原则（Dependence Inversion Principle）<br>接口隔离原则（Interface Segregation Principle）、迪米特法则（最少知道原则）（Demeter Principle）、合成复用原则（Composite Reuse Principle）<br><strong>→ 了解 23 种设计模式</strong><br>创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。<br>结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。<br>行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter 模式）、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。<br><strong>→ 会使用常用设计模式</strong><br>单例的七种写法：懒汉——线程不安全、懒汉——线程安全、饿汉、饿汉——变种、静态内部类、枚举、双重校验锁<br>工厂模式、适配器模式、策略模式、模板方法模式、观察者模式、外观模式、代理模式等必会<br><strong>→ 不用 synchronized 和 lock，实现线程安全的单例模式</strong><br><strong>→ 实现 AOP</strong><br><strong>→ 实现 IOC</strong><br><strong>→ nio 和 reactor 设计模式</strong></p><h3 id="网络编程知识"><a href="#网络编程知识" class="headerlink" title="网络编程知识"></a>网络编程知识</h3><p><strong>→ tcp、udp、http、https 等常用协议</strong><br>三次握手与四次关闭、流量控制和拥塞控制、OSI 七层模型、tcp 粘包与拆包<br><strong>→ http/1.0 http/1.1 http/2 之前的区别</strong><br>http 中 get 和 post 区别<br>常见的 web 请求返回的状态码<br>404、302、301、500分别代表什么<br><strong>→ http/3</strong><br><strong>→ Java RMI，Socket，HttpClient</strong><br><strong>→ cookie 与 session</strong><br>cookie 被禁用，如何实现 session<br><strong>→ 用 Java 写一个简单的静态文件的 HTTP 服务器</strong><br><strong>→ 了解 nginx 和 apache 服务器的特性并搭建一个对应的服务器</strong><br><strong>→ 用 Java 实现 FTP、SMTP 协议</strong><br><strong>→ 进程间通讯的方式</strong><br><strong>→ 什么是 CDN？如果实现？</strong><br><strong>→ DNS</strong><br>什么是 DNS 、记录类型: A 记录、CNAME 记录、AAAA 记录等<br>域名解析、根域名服务器<br>DNS 污染、DNS 劫持、公共 DNS：114 DNS、Google DNS、OpenDNS<br><strong>→ 反向代理</strong><br>正向代理、反向代理<br>反向代理服务器</p><h3 id="框架知识"><a href="#框架知识" class="headerlink" title="框架知识"></a>框架知识</h3><p><strong>→ Servlet</strong><br>生命周期<br>线程安全问题<br>filter 和 listener<br>web.xml 中常用配置及作用<br><strong>→ Hibernate</strong><br>什么是 OR Mapping<br>Hibernate 的懒加载<br>Hibernate 的缓存机制<br>Hibernate / Ibatis / MyBatis 之间的区别<br><strong>→ Spring</strong><br>Bean 的初始化<br>AOP 原理<br>实现 Spring 的IOC<br>Spring 四种依赖注入方式<br><strong>→ Spring MVC</strong><br>什么是 MVC<br>Spring mvc 与 Struts mvc 的区别<br><strong>→ Spring Boot</strong><br>Spring Boot 2.0、起步依赖、自动配置、<br>Spring Boot 的 starter 原理，自己实现一个 starter<br><strong>→ Spring Security</strong><br><strong>→ Spring Cloud</strong><br>服务发现与注册：Eureka、Zookeeper、Consul<br>负载均衡：Feign、Spring Cloud Loadbalance<br>服务配置：Spring Cloud Config<br>服务限流与熔断：Hystrix<br>服务链路追踪：Dapper<br>服务网关、安全、消息</p><h3 id="应用服务器知识"><a href="#应用服务器知识" class="headerlink" title="应用服务器知识"></a>应用服务器知识</h3><p><strong>→ JBoss<br>→ tomcat<br>→ jetty<br>→ Weblogic</strong></p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p><strong>→ git &amp; svn</strong><br><strong>→ maven &amp; gradle</strong><br><strong>→ Intellij IDEA</strong><br>常用插件：Maven Helper 、FindBugs-IDEA、阿里巴巴代码规约检测、GsonFormat<br>Lombok plugin、.ignore、Mybatis plugin</p><h2 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a><font color="red">高级篇</font></h2><h3 id="新技术"><a href="#新技术" class="headerlink" title="新技术"></a>新技术</h3><p><strong>→ Java 8</strong><br>lambda 表达式、Stream API、时间 API<br><strong>→ Java 9</strong><br>Jigsaw、Jshell、Reactive Streams<br><strong>→ Java 10</strong><br>局部变量类型推断、G1 的并行 Full GC、ThreadLocal 握手机制<br><strong>→ Java 11</strong><br>ZGC、Epsilon、增强 var<br><strong>→ Spring 5</strong><br>响应式编程<br><strong>→ Spring Boot 2.0</strong><br><strong>→ HTTP/2</strong><br><strong>→ HTTP/3</strong>    </p><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>使用单例、使用 Future 模式、使用线程池<br>选择就绪、减少上下文切换、减少锁粒度、数据压缩、结果缓存</p><h3 id="线上问题分析"><a href="#线上问题分析" class="headerlink" title="线上问题分析"></a>线上问题分析</h3><p><strong>→ dump 获取</strong><br>线程 Dump、内存 Dump、gc 情况<br><strong>→ dump 分析</strong><br>分析死锁、分析内存泄露<br><strong>→ dump 分析及获取工具</strong><br>jstack、jstat、jmap、jhat、Arthas<br><strong>→ 自己编写各种 outofmemory，stackoverflow 程序</strong><br>HeapOutOfMemory、 Young OutOfMemory、<br>MethodArea OutOfMemory、ConstantPool OutOfMemory、<br>DirectMemory OutOfMemory、Stack OutOfMemory Stack OverFlow<br><strong>→ Arthas</strong><br>jvm 相关、class/classloader 相关、monitor/watch/trace 相关、<br>options、管道、后台异步任务<br>文档：<a href="https://alibaba.github.io/arthas/advanced-use.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/advanced-use.html</a><br><strong>→ 常见问题解决思路</strong><br>内存溢出、线程死锁、类加载冲突<br><strong>→ 使用工具尝试解决以下问题，并写下总结</strong><br>当一个 Java 程序响应很慢时如何查找问题<br>当一个 Java 程序频繁 FullGC 时如何解决问题<br>如何查看垃圾回收日志<br>当一个 Java 应用发生 OutOfMemory 时该如何解决<br>如何判断是否出现死锁<br>如何判断是否存在内存泄露<br>使用 Arthas 快速排查 Spring Boot 应用404/401问题<br>使用 Arthas 排查线上应用日志打满问题<br>利用 Arthas 排查 Spring Boot 应用 NoSuchMethodError</p><h3 id="编译原理知识"><a href="#编译原理知识" class="headerlink" title="编译原理知识"></a>编译原理知识</h3><p><strong>→ 编译与反编译</strong><br><strong>→ Java 代码的编译与反编译</strong><br><strong>→ Java 的反编译工具</strong><br>javap 、jad 、CRF<br><strong>→ 即时编译器</strong><br><strong>→ 编译过程</strong><br>词法分析，语法分析（LL 算法，递归下降算法，LR 算法）<br>语义分析，运行时环境，中间代码，代码生成，代码优化</p><h3 id="操作系统知识"><a href="#操作系统知识" class="headerlink" title="操作系统知识"></a>操作系统知识</h3><p><strong>→ Linux 的常用命令<br>→ 进程间通信<br>→ 进程同步<br>生产者消费者问题、哲学家就餐问题、读者写者问题<br>→ 缓冲区溢出<br>→ 分段和分页<br>→ 虚拟内存与主存<br>→ 虚拟内存管理<br>→ 换页算法</strong></p><h3 id="数据库知识"><a href="#数据库知识" class="headerlink" title="数据库知识"></a>数据库知识</h3><p><strong>→ MySQL 执行引擎<br>→ MySQL 执行计划</strong><br>如何查看执行计划，如何根据执行计划进行 SQL 优化<br><strong>→ 索引</strong><br>Hash 索引、B 树索引（B+树、和B树、R树）<br>普通索引、唯一索引<br>覆盖索引、最左前缀原则、索引下推<br><strong>→ SQL 优化</strong><br><strong>→ 数据库事务和隔离级别</strong><br>事务的隔离级别、事务能不能实现锁的功能<br><strong>→ 数据库锁</strong><br>行锁、表锁、使用数据库锁实现乐观锁、<br><strong>→ 连接</strong><br>内连接，左连接，右连接<br><strong>→ 数据库主备搭建</strong><br><strong>→ binlog<br>→ redolog<br>→ 内存数据库</strong><br>h2<br><strong>→ 分库分表<br>→ 读写分离<br>→ 常用的 NoSql 数据库</strong><br>redis、memcached<br><strong>→ 分别使用数据库锁、NoSql 实现分布式锁<br>→ 性能调优<br>→ 数据库连接池</strong></p><h3 id="数据结构与算法知识"><a href="#数据结构与算法知识" class="headerlink" title="数据结构与算法知识"></a>数据结构与算法知识</h3><p><strong>→ 简单的数据结构</strong><br>栈、队列、链表、数组、哈希表、<br>栈和队列的相同和不同之处<br>栈通常采用的两种存储结构<br><strong>→ 树</strong><br>二叉树、字典树、平衡树、排序树、<br>B 树、B+ 树、R 树、多路树、红黑树<br><strong>→ 堆</strong><br>大根堆、小根堆<br><strong>→ 图</strong><br>有向图、无向图、拓扑<br><strong>→ 排序算法</strong><br>稳定的排序：冒泡排序、插入排序、鸡尾酒排序、桶排序、计数排序、归并排序、原地归并排序、二叉排序树排序、鸽巢排序、基数排序、侏儒排序、图书馆排序、块排序<br>不稳定的排序：选择排序、希尔排序、Clover 排序算法、梳排序、堆排序、平滑排序、快速排序、内省排序、耐心排序<br>各种排序算法和时间复杂度<br><strong>→ 两个栈实现队列，和两个队列实现栈<br>→ 深度优先和广度优先搜索<br>→ 全排列、贪心算法、KMP 算法、hash 算法<br>→ 海量数据处理</strong><br>分治，hash 映射，堆排序，双层桶划分，Bloom Filter，bitmap，数据库索引，mapreduce 等。</p><h3 id="大数据知识"><a href="#大数据知识" class="headerlink" title="大数据知识"></a>大数据知识</h3><p><strong>→ Zookeeper</strong><br>基本概念、常见用法<br><strong>→ Solr，Lucene，ElasticSearch</strong><br>在 linux 上部署 solr，solrcloud，新增、删除、查询索引<br><strong>→ Storm，流式计算，了解 Spark，S4</strong><br>在 linux 上部署 storm，用 zookeeper 做协调，运行 storm hello world，local 和 remote 模式运行调试 storm topology。<br><strong>→ Hadoop，离线计算</strong><br>HDFS、MapReduce<br><strong>→ 分布式日志收集 flume，kafka，logstash</strong><br><strong>→ 数据挖掘，mahout</strong></p><h3 id="网络安全知识"><a href="#网络安全知识" class="headerlink" title="网络安全知识"></a>网络安全知识</h3><p><strong>→ XSS</strong><br>XSS 的防御<br><strong>→ CSRF</strong><br><strong>→ 注入攻击</strong><br>SQL 注入、XML 注入、CRLF 注入<br><strong>→ 文件上传漏洞<br>→ 加密与解密</strong><br>对称加密、非对称加密、哈希算法、加盐哈希算法<br>MD5，SHA1、DES、AES、RSA、DSA<br>彩虹表<br><strong>→ DDOS攻击</strong><br>DOS 攻击、DDOS 攻击<br>memcached 为什么可以导致 DDos 攻击、什么是反射型 DDoS<br>如何通过 Hash 碰撞进行 DOS 攻击<br><strong>→ SSL、TLS，HTTPS<br>→ 用 openssl 签一个证书部署到 apache 或 nginx</strong></p><h2 id="架构篇"><a href="#架构篇" class="headerlink" title="架构篇"></a><font color="red">架构篇</font></h2><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>数据一致性、服务治理、服务降级<br><strong>→ 分布式事务</strong><br>2PC、3PC、CAP、BASE、 可靠消息最终一致性、最大努力通知、TCC<br><strong>→ Dubbo</strong><br>服务注册、服务发现，服务治理<br><a href="http://dubbo.apache.org/zh-cn/" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/</a><br><strong>→ 分布式数据库</strong><br>怎样打造一个分布式数据库、什么时候需要分布式数据库、<br>mycat、otter、HBase<br><strong>→ 分布式文件系统</strong><br>mfs、fastdfs<br><strong>→ 分布式缓存</strong><br>缓存一致性、缓存命中率、缓存冗余<br><strong>→ 限流降级</strong><br>Hystrix、Sentinal<br><strong>→ 算法</strong><br>共识算法、Raft 协议、Paxos 算法与 Raft 算法、<br>拜占庭问题与算法、2PC、3PC</p><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>SOA、康威定律<br><strong>→ ServiceMesh</strong><br>sidecar<br><strong>→ Docker &amp; Kubernets<br>→ Spring Boot<br>→ Spring Cloud</strong></p><h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><p><strong>→ 分库分表<br>→ CDN 技术<br>→ 消息队列</strong><br>ActiveMQ</p><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p><strong>→ 监控什么</strong><br>CPU、内存、磁盘 I/O、网络 I/O 等<br><strong>→ 监控手段</strong><br>进程监控、语义监控、机器资源监控、数据波动<br><strong>→ 监控数据采集</strong><br>日志、埋点<br><strong>→ Dapper</strong></p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>tomcat 负载均衡、Nginx 负载均衡<br>四层负载均衡、七层负载均衡</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS 原理、DNS 的设计</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>数据一致性</p><h2 id="扩展篇"><a href="#扩展篇" class="headerlink" title="扩展篇"></a><font color="red">扩展篇</font></h2><h3 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h3><p>IaaS、SaaS、PaaS、虚拟化技术、openstack、Serverlsess</p><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><p>Solr、Lucene、Nutch、Elasticsearch</p><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><p>Shiro</p><h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><p>哈希算法、Merkle 树、公钥密码算法、共识算法、<br>Raft 协议、Paxos 算法与 Raft 算法、拜占庭问题与算法、消息认证码与数字签名<br><strong>→ 比特币</strong><br>挖矿、共识机制、闪电网络、侧链、热点问题、分叉<br><strong>→ 以太坊<br>→ 超级账本</strong></p><h3 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h3><p>数学基础、机器学习、人工神经网络、深度学习、应用场景。<br><strong>→ 常用框架</strong><br>TensorFlow、DeepLearning4J</p><h3 id="loT"><a href="#loT" class="headerlink" title="loT"></a>loT</h3><h3 id="量子计算"><a href="#量子计算" class="headerlink" title="量子计算"></a>量子计算</h3><h3 id="AR-amp-VR"><a href="#AR-amp-VR" class="headerlink" title="AR &amp; VR"></a>AR &amp; VR</h3><h3 id="其他语言"><a href="#其他语言" class="headerlink" title="其他语言"></a>其他语言</h3><p>Groovy、Python、Go、NodeJs、Swift、Rust</p><h2 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a><font color="red">推荐书籍</font></h2><p>《深入理解 Java 虚拟机》<br>《Effective Java》<br>《深入分析 Java Web 技术内幕》<br>《大型网站技术架构》<br>《代码整洁之道》<br>《架构整洁之道》<br>《Head First 设计模式》<br>《maven 实战》<br>《区块链原理、设计与应用》<br>《Java 并发编程实战》<br>《鸟哥的 Linux 私房菜》<br>《从Paxos 到 Zookeeper》<br>《架构即未来》</p><p><strong><a href="https://mp.weixin.qq.com/s/zYJTLOpCkYuMR1HMCJOt-A" target="_blank" rel="noopener">转载自公众号：Hollis</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1551345094255&amp;amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;amp;imgtype=0&amp;amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;当学Java迷茫的时候，不妨看看，激励一下自己！&lt;br&gt;
    
    </summary>
    
      <category term="Languages" scheme="https://yoursite.com/categories/Languages/"/>
    
    
      <category term="Java" scheme="https://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="https://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java的艺术-类和接口的多继承</title>
    <link href="https://yoursite.com/2018/12/05/Java%E7%9A%84%E8%89%BA%E6%9C%AF-%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF/"/>
    <id>https://yoursite.com/2018/12/05/Java的艺术-类和接口的多继承/</id>
    <published>2018-12-05T10:48:20.000Z</published>
    <updated>2019-03-07T07:42:42.367Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551345094255&amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;imgtype=0&amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png" alt="此处输入图片的描述"><br>Java也有多继承？来看看JDK8的这个新特性！<br><a id="more"></a></p><h2 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a><font color="red"><strong>接口（Interface）</strong></font></h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。</p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><blockquote><p><strong>(JDK8以前)</strong>接口中可以含有 变量和方法。但是要注意，接口中的变量会被隐式地指定为<strong>public static final</strong>变量（并且只能是public static final变量，用private修饰会报编译错误），而方法会被隐式地指定为<strong>public abstract</strong>方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误）</p></blockquote><blockquote><p>并且<strong>接口中所有的方法不能有具体的实现</strong>，也就是说，<font color="red"><strong>接口中的方法必须都是抽象方法</strong></font>。从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。</p></blockquote><h3 id="Java8-新特性"><a href="#Java8-新特性" class="headerlink" title="Java8 新特性"></a>Java8 新特性</h3><blockquote><p><font color="red"><strong>但是，自从Java 8发布后，接口中也可以自定义方法了（default method）</strong></font>。这样如果为很多继承了同一个接口的类增加功能，不必对这些类重新设计。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface Test &#123;</span><br><span class="line">    //default关键字不能省略，否则提示Interface abstract methods cannot have body</span><br><span class="line">    default String test(String str)&#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">    //默认为public,abstract的</span><br><span class="line">    int test2();</span><br><span class="line">    //default关键字不能与abstact同时修饰接口方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同时，接口方法也可以被<strong>static</strong>修饰。</p></blockquote><blockquote><p>但是这也给Java带来了新问题——<font color="red"><strong>Java多继承的冲突</strong></font>。</p></blockquote><h3 id="接口中被default与static修饰的方法"><a href="#接口中被default与static修饰的方法" class="headerlink" title="接口中被default与static修饰的方法"></a>接口中被default与static修饰的方法</h3><ul><li><p>非default、static方法不能有实现，否则编译错误：Abstract methods do not specify a body</p></li><li><p>default、static方法必须有具体的实现，否则编译错误：This method requires a body instead of a semicolon</p></li><li><p>可以拥有多个default方法</p></li><li><p>可以拥有多个static方法</p></li><li><p>使用接口中类型时，仅仅需要实现抽象方法，default、static方法不需要强制自己新实现</p></li></ul><h2 id="Java多继承"><a href="#Java多继承" class="headerlink" title="Java多继承"></a><font color="red"><strong>Java多继承</strong></font></h2><h3 id="接口多继承冲突"><a href="#接口多继承冲突" class="headerlink" title="接口多继承冲突"></a>接口多继承冲突</h3><blockquote><p>比如有三个接口，Interface Test1,Interface Test2,Interface Test3。其中，Interface Test3继承自Test1和Test2。</p></blockquote><blockquote><p>如果Test1和Test2有相同签名的默认(default)方法，并且Test3没有override，则编译会出错。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Test1 &#123;</span><br><span class="line">     default String test(String str)&#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Test2 &#123;</span><br><span class="line">     default String test(String str)&#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface Test3 extends Test1,Test2 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multiextends.Test3 inherits unrelated defaults for test(String) from types multiextends.Test1 and multiextends.Test2</span><br></pre></td></tr></table></figure></p><p>需要在子接口中覆盖这个方法，让子类知道默认调用哪个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Test3 extends Test1,Test2 &#123;</span><br><span class="line">     default String test(String str)&#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意判断是否签名相同是根据传入的参数，而不是返回的参数。此时接口会根据传入的参数选择不同的default方法执行。</strong><br>比如下面的会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Test1 &#123;</span><br><span class="line"></span><br><span class="line">     default int test(String str)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Test2 &#123;</span><br><span class="line">//传入相同的String，返回不同的类型</span><br><span class="line">     default String test(String str)&#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//编译通过，不需要覆盖</span><br><span class="line">interface Test3 extends Test1,Test2 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是下面的编译通过：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Test1 &#123;</span><br><span class="line">     default String test(int a)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Test2 &#123;</span><br><span class="line">//传入不同类型的参数，返回相同的类型</span><br><span class="line">     default String test(String str)&#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//报错，需要覆盖</span><br><span class="line">//interface Test3 extends Test1,Test2 &#123;</span><br><span class="line">//&#125;</span><br></pre></td></tr></table></figure></p><h3 id="超类多继承冲突"><a href="#超类多继承冲突" class="headerlink" title="超类多继承冲突"></a>超类多继承冲突</h3><blockquote><p>如果比如有两个接口，Interface Test1,Interface Test2，一个超类Class Test3，一个子类Class Test4其中，Class Test4实现Interface Test1和Interface Test2，继承Class Test3。</p></blockquote><blockquote><p>如果方法有冲突会怎么样？<br>直接看代码：（注意注释中对静态方法和静态属性的 ）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">interface Test1 &#123;</span><br><span class="line">     default String test(int a)&#123;</span><br><span class="line">        return &quot;test&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Test2 &#123;</span><br><span class="line">//传入不同类型的参数，返回相同的类型</span><br><span class="line">     default String test(String str)&#123;</span><br><span class="line">        return &quot;test2&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Test3&#123;</span><br><span class="line">//如果public换成static会报错</span><br><span class="line">//但是如果只和一个Interface冲突，则可以用static修饰。</span><br><span class="line">//因为静态方法和属性可以被继承，但是不能被重写，而是被&quot;隐藏&quot;，直接通过父类名称调用。</span><br><span class="line">    public String test(String str)&#123;</span><br><span class="line">        return &quot;test3&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Test4 extends Test3 implements Test1,Test2&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test4 test = new Test4();</span><br><span class="line">        System.out.println(test.test(&quot;str&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//执行结果</span><br><span class="line">//test3</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><font color="red"><strong>总结</strong></font></h2><blockquote><p><strong>接口冲突：</strong>如果一个类同时实现了具有相同方法签名的接口，则该类必须覆盖该抽象方法。</p></blockquote><blockquote><p><strong>超类冲突</strong>：超类和接口提供相同方法签名的方法，此时子类要是不覆盖，则默认调用超类方法。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1551345094255&amp;amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;amp;imgtype=0&amp;amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;Java也有多继承？来看看JDK8的这个新特性！&lt;br&gt;
    
    </summary>
    
      <category term="Languages" scheme="https://yoursite.com/categories/Languages/"/>
    
    
      <category term="Java" scheme="https://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>搭建博客时候问题小记</title>
    <link href="https://yoursite.com/2018/12/01/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%97%B6%E5%80%99%E9%97%AE%E9%A2%98%E5%B0%8F%E8%AE%B0/"/>
    <id>https://yoursite.com/2018/12/01/搭建博客时候问题小记/</id>
    <published>2018-12-01T06:48:20.000Z</published>
    <updated>2019-03-06T11:39:24.864Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong>汇总搭建博客遇见的几个问题（持续更新。。。）<br><a id="more"></a></p><h2 id="nothing-added-to-commit-but-untracked-files-present"><a href="#nothing-added-to-commit-but-untracked-files-present" class="headerlink" title="nothing added to commit but untracked files present"></a>nothing added to commit but untracked files present</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;first commit&quot;</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">        .gitignore</span><br><span class="line">        _config.yml</span><br><span class="line">        git</span><br><span class="line">        git.pub</span><br><span class="line">        package-lock.json</span><br><span class="line">        package.json</span><br><span class="line">        scaffolds/</span><br><span class="line">        source/</span><br><span class="line">        themes/</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present</span><br></pre></td></tr></table></figure><p>这个错误原因有两个：</p><ol><li>已经存在的项目？</li><li>没有把需要提交的文件加载进来，所以需要用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add （文件名）</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="fatal-remote-origin-already-exists"><a href="#fatal-remote-origin-already-exists" class="headerlink" title="fatal: remote origin already exists."></a>fatal: remote origin already exists.</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: remote origin already exists.</span><br></pre></td></tr></table></figure><p>用到的解决办法：</p><ol><li><p>删除远程仓库，再添加远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$git remote rm origin</span><br><span class="line"></span><br><span class="line">$git remote add origin git@github.com:wufans/wufans.github.io.git</span><br></pre></td></tr></table></figure></li><li><p>修改git的config文件的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$vi .git/config</span><br></pre></td></tr></table></figure></li></ol><p>删除[remote “origin”]</p><hr><h2 id="github-rejected"><a href="#github-rejected" class="headerlink" title="github rejected"></a>github rejected</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">To github.com:wufans/wufans.github.io.git</span><br><span class="line"> ! [rejected]        master -&gt; master (non-fast-forward)</span><br><span class="line"> &apos;git@github.com:wufans/wufans.github.io.git&apos;</span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: &apos;git pull ...&apos;) before pushing again.</span><br></pre></td></tr></table></figure><p>这个方法就是因为本地仓库和github上面仓库的内容有冲突导致的<br>我用的解决办法是删除了原来的repository，重新建立了一个仓库，问题解决。</p><hr><h2 id="创建流量统计功能的方法"><a href="#创建流量统计功能的方法" class="headerlink" title="创建流量统计功能的方法"></a>创建流量统计功能的方法</h2><p><a href="https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="noopener">参考博客</a></p><hr><h2 id="附加功能的添加"><a href="#附加功能的添加" class="headerlink" title="附加功能的添加"></a>附加功能的添加</h2><p><a href="https://blog.csdn.net/linshuhe1/article/details/52424573" target="_blank" rel="noopener">参考博客</a></p><hr><h2 id="解决公式显示不正常的问题"><a href="#解决公式显示不正常的问题" class="headerlink" title="解决公式显示不正常的问题"></a>解决公式显示不正常的问题</h2><p><a href="https://blog.csdn.net/emptyset110/article/details/50123231" target="_blank" rel="noopener">参考博客</a></p><hr><h2 id="hexo设置侧边栏头像"><a href="#hexo设置侧边栏头像" class="headerlink" title="hexo设置侧边栏头像"></a>hexo设置侧边栏头像</h2><p>编辑站点的 _config.yml，新增字段 avatar， 值设置成头像的链接地址。</p><p>其中，头像的链接地址可以是：</p><p>完整的互联网 URL，例如：<a href="https://avatars1.githubusercontent.com/u/32269?v=3&amp;s=460" target="_blank" rel="noopener">https://avatars1.githubusercontent.com/u/32269?v=3&amp;s=460</a></p><p>站点内的地址，例如：</p><p>/uploads/avatar.jpg 需要将你的头像图片放置在 站点的 source/uploads/（可能需要新建uploads目录）<br>/images/avatar.jpg 需要将你的头像图片放置在 主题的 source/images/ 目录下。</p><hr><h2 id="hexo部署失败，不能连接github的解决"><a href="#hexo部署失败，不能连接github的解决" class="headerlink" title="hexo部署失败，不能连接github的解决"></a>hexo部署失败，不能连接github的解决</h2><p>一直在解决这个问题，修改了本地文件的几个配置之后，突然发现生成的博客不能直接push到github上了，显示错误<br><img src="https://s1.ax1x.com/2018/12/27/F2IkYd.jpg" alt="此处输入图片的描述"><br>但是用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure></p><p>部署到本地的时候是没有问题的。<br>然后用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@gihub.com</span><br></pre></td></tr></table></figure></p><p>测试连接也出现了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh_exchange_identification: read:Connection reset by peer</span><br></pre></td></tr></table></figure></p><p>和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection reset by 192.30.253.112 port 22</span><br></pre></td></tr></table></figure></p><p>这样的错误<br>尝试了以下解决办法：</p><ol><li>因为前几次修改了hosts文件解决github不能加载CSS的问题，让电脑解析github的域名时用的是自定义的IP，所以可能有这个原因，因此在hosts里面注释掉了修改的部分，然后刷新DNS缓存<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /flushdns</span><br><span class="line">#这里还遇到了ipconfig和ping不是一个命令的错误，需要配置环境变量path</span><br><span class="line">#%SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem</span><br></pre></td></tr></table></figure></li></ol><p>最后发现没用。</p><ol><li>删除了github上面的ssh配置，重新配置了github服务器端与本地的ssh秘钥，然后再使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@gihub.com</span><br></pre></td></tr></table></figure></li></ol><p>结果能连上了，但是再用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p><p>之后，又报了刚才的错误，而且再测试与github上面的连接居然也出错了~</p><ol><li>俗话说，重启治百病，于是重启了一下————是的，没用</li><li>用网上的解决办法，可能是网络防火墙设置的原因，用手机给电脑开热点再测试连接，结果也没用<br>最后打算第二天重新部署博客了，然后奇迹发生了，起床之后再测试链接，work~</li></ol><hr><h2 id="Github不能访问、不能正常加载CSS的解决"><a href="#Github不能访问、不能正常加载CSS的解决" class="headerlink" title="Github不能访问、不能正常加载CSS的解决"></a>Github不能访问、不能正常加载CSS的解决</h2><p>修改了windows的hosts文件之后，经常会出现github访问异常，页面的CSS样式无法加载等的情况。<br><strong>解决办法</strong><br>给hosts文件增加github的CDN fastly.net,跳过域名解析，直接通过IP访问github。<br>在hosts文件下增加一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">185.31.17.184 github.global.ssl.fastly.net</span><br></pre></td></tr></table></figure></p><font color="red"><strong>问题</strong></font><p>使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p><p>部署博客时，出现下列错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fatal: TaskCanceledException encountered.</span><br><span class="line">   ▒▒ȡ▒▒һ▒▒▒▒▒▒</span><br><span class="line">bash: /dev/tty: No such device or address</span><br><span class="line">error: failed to execute prompt script (exit code 1)</span><br><span class="line">fatal: could not read Username for &apos;https://github.com&apos;: No error</span><br><span class="line">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="line">Error: fatal: TaskCanceledException encountered.</span><br><span class="line">   ��ȡ��һ������</span><br><span class="line">bash: /dev/tty: No such device or address</span><br><span class="line">error: failed to execute prompt script (exit code 1)</span><br><span class="line">fatal: could not read Username for &apos;https://github.com&apos;: No error</span><br><span class="line"></span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (D:\blog\GIT\hexo\node_modules\hexo-util\lib\spawn.js:37:17)</span><br><span class="line">    at emitTwo (events.js:125:13)</span><br><span class="line">    at ChildProcess.emit (events.js:213:7)</span><br><span class="line">    at ChildProcess.cp.emit (D:\blog\GIT\hexo\node_modules\cross-spawn\lib\enoent.js:40:29)</span><br><span class="line">    at maybeClose (internal/child_process.js:927:16)</span><br><span class="line">    at Process.ChildProcess._handle.onexit (internal/child_process.js:211:5)</span><br></pre></td></tr></table></figure></p><font color="red"><strong>解决</strong></font><p>如果开启了本地预览，先关闭<br>然后用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure></p><p>清空缓存，再重新生成静态文件并部署，问题解决~</p><p><font color="red">另外</font><br>用了上面的方法之后还出现了这个问题的话，<big><font color="red">重启</font></big>一下电脑~~</p><h2 id="添加版权声明"><a href="#添加版权声明" class="headerlink" title="添加版权声明"></a>添加版权声明</h2><p>添加版权声明</p><p>在Github上，Next主题的issues上有设置 Creative Commons 协议，这个就是设置版权声明，但是配置了以后图标比较小，没有文字说明（就是没逼格），而且还会出现在它不该出现的地方。</p><h3 id="新建-passage-end-tag-swig-文件"><a href="#新建-passage-end-tag-swig-文件" class="headerlink" title="新建 passage-end-tag.swig 文件"></a>新建 passage-end-tag.swig 文件</h3><p>在路径\themes\next\layout_macro中添加passage-end-tag.swig文件，其内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.passage_end_tag.enabled %&#125;</span><br><span class="line">&lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;</span><br><span class="line">------ 本文结束 ------&lt;/div&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;div style=&quot;border: 1px solid black&quot;&gt;</span><br><span class="line">&lt;div style=&quot;margin-left:10px&quot;&gt;</span><br><span class="line">&lt;span style=&quot;font-weight:blod&quot;&gt;版权声明&lt;/span&gt;</span><br><span class="line">&lt;img src=&quot;http://creativecommons.org/images/deed/logo_deed.gif&quot;&gt;&lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;Fan Wu&apos;s Blog&lt;/a&gt; by &lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;Fan Wu&lt;/a&gt; is licensed under a &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; style=&quot;color:#258FC6&quot;&gt;Creative Commons BY-NC-ND 4.0 International License&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">由&lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;Fan Wu&lt;/a&gt;创作并维护的&lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;Fan Wu&apos;s Blog&lt;/a&gt;博客采用&lt;a href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; style=&quot;color:#258FC6&quot;&gt;创作共用保留署名-非商业-禁止演绎4.0国际许可证&lt;/a&gt;。&lt;br/&gt;</span><br><span class="line">本文首发于&lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;Fan Wu&apos;s Blog&lt;/a&gt; 博客（ &lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;http://wufan.site/&lt;/a&gt; ），版权所有，侵权必究。&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>如果觉得上面的样式不好看，也可以引用下面的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.passage_end_tag.enabled %&#125;</span><br><span class="line">&lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;</span><br><span class="line">-------------本文结束&lt;i class=&quot;fa fa-heart&quot;&gt;&lt;/i&gt;感谢阅读-------------&lt;/div&gt;</span><br><span class="line">&lt;ul class=&quot;post-copyright&quot;&gt;</span><br><span class="line">  &lt;li class=&quot;post-copyright-author&quot;&gt;</span><br><span class="line">      &lt;strong&gt;本文作者:&lt;/strong&gt;&#123;&#123; theme.author &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">  &lt;li class=&quot;post-copyright-link&quot;&gt;</span><br><span class="line">    &lt;strong&gt;本文链接:&lt;/strong&gt;</span><br><span class="line">    &lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.path &#125;&#125;&lt;/a&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">  &lt;li class=&quot;post-copyright-license&quot;&gt;</span><br><span class="line">    &lt;strong&gt;许可协议:&lt;/strong&gt;</span><br><span class="line">    除特殊声明外，本站博文均采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-sa/3.0/cn/&quot; rel=&quot;external nofollow&quot; target=&quot;_blank&quot;&gt;CC BY-NC-SA 4.0 CN&lt;/a&gt; 许可协议，转载请注明出处！</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><h3 id="修改-post-swig-文件"><a href="#修改-post-swig-文件" class="headerlink" title="修改 post.swig 文件"></a>修改 post.swig 文件</h3><p>在\themes\next\layout_macro\post.swig中，post-body之后，post-footer之前添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% if not is_index %&#125;</span><br><span class="line">    &#123;% include &apos;passage-end-tag.swig&apos; %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h3 id="在主题配置文件中添加字段"><a href="#在主题配置文件中添加字段" class="headerlink" title="在主题配置文件中添加字段"></a>在主题配置文件中添加字段</h3><p>在主题配置文件”_config.yml”中添加以下字段开启此功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#文章末尾添加“本文结束”标记</span><br><span class="line">passage_end_tag:</span><br><span class="line">  enabled: true</span><br></pre></td></tr></table></figure><p>完成以上设置之后，在每篇文章之后都会添加“版权声明”标记。</p><h2 id="添加动画效果"><a href="#添加动画效果" class="headerlink" title="添加动画效果"></a>添加动画效果</h2><p>背景动画基于canvas，添加到博客上也比较简单，在\themes\next\layout_layout.swig的上面添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.canvas_nest %&#125;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>在\themes\next_config.yml中添加以下字段开启此功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># background settings</span><br><span class="line"># add canvas-nest effect</span><br><span class="line"># see detail from https://github.com/hustcc/canvas-nest.js</span><br><span class="line">canvas_nest: true</span><br></pre></td></tr></table></figure></p><p>添加完了，发现博客背景是白色，会遮住动画，只留下两边一点点的位置看到动画效果，这时候可以去设置一下背景颜色，在\themes\next\source\css_schemes\Pisces_layout.styl中，把.content-wrap中的background修改为none。</p><p>这时候如果用手机打开，也能看到动画效果，但是带来的体验不好，显得页面比较乱，这是可以把.content-wrap的+mobile()中的background修改为white，这样手机端的体验就好很多，却又不影响电脑端的炫酷动画。</p><h2 id="解决博客浏览统计功能突然失效的方法（hexo-theme-next-busuanzi-count）"><a href="#解决博客浏览统计功能突然失效的方法（hexo-theme-next-busuanzi-count）" class="headerlink" title="解决博客浏览统计功能突然失效的方法（hexo-theme-next-busuanzi_count）"></a>解决博客浏览统计功能突然失效的方法（hexo-theme-next-busuanzi_count）</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>我这里是使用的hexo-theme-next主题，主题版本为：3.8.0(更新于10-31日)</p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>由于定位到是不蒜子统计功能突然有问题了，所以前往不蒜子官网进行查看，发现官网有一段很重要的提示：<br><strong>“因七牛强制过期『dn-lbstatics.qbox.me』域名，与客服沟通无果，只能更换域名到『busuanzi.ibruce.info』！”</strong><br>所以定位到问题，原来是不蒜子使用的七牛的域名被强制过期。<br>需要把 dn-lbstatics.qbox.me 域名更换为 busuanzi.ibruce.info</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>hexo-theme-next主题中使用了dn-lbstatics.qbox.me域名的文件位置为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">themes\next\layout\_third-party\analytics\busuanzi-counter.swig</span><br></pre></td></tr></table></figure><p>修改busuanzi-counter.swig</p><p>找到如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>重新预览，即可看到不蒜子统计功能已经生效<br><a href="https://blog.csdn.net/qijian2003122/article/details/82987577" target="_blank" rel="noopener">原文</a></p><h2 id="恢复你的博客，只需要三步"><a href="#恢复你的博客，只需要三步" class="headerlink" title="恢复你的博客，只需要三步"></a>恢复你的博客，只需要三步</h2><p><strong>如果你重装了系统或者更换了新电脑/新平台，怎么才能快速恢复原来的博客呢？</strong><br>如果你保留了原来博客文件夹下所有文件，那么恢复博客只需要三步：</p><h3 id="安装必备组件"><a href="#安装必备组件" class="headerlink" title="安装必备组件"></a>安装必备组件</h3><p>包括：安装Git，安装Node.js</p><h3 id="Github配对"><a href="#Github配对" class="headerlink" title="Github配对"></a>Github配对</h3><p>打开git bash，在用户主目录下运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure></p><p>把其中的邮件地址换成自己的邮件地址，然后一路回车,在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥<br>登陆GitHub，打开「Settings」-&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容），最后点击「Add SSH Key」<br>测试是否配对成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>打开git bash客户端，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure></p><p>，开始安装hexo<br>安装成功后，进入你原来的博客目录，就可以用hexo命令进行博客生成和部署啦~</p><h2 id="给博客自定义域名开启Https"><a href="#给博客自定义域名开启Https" class="headerlink" title="给博客自定义域名开启Https"></a>给博客自定义域名开启Https</h2><p><strong>HTTPS</strong>（全称：Hyper Text Transfer Protocol over Secure Socket Layer 或 Hypertext Transfer Protocol Secure，超文本传输安全协议），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。<br>GitHub官方在5月1号宣布，GitHub Pages的自定义域名获得对HTTPS的支持。但是因为自己的域名是自定义的，购于阿里云，因此不能直接在Setting中设置Enforce HTTPS:<br><img src="https://s1.ax1x.com/2018/12/26/F2rlvj.png" alt="此处输入图片的描述"><br>而Github pages不支持SSL证书上传，因此，开启HTTPS需要借助CloudFlare的CDN代理。即用户到CDN服务器的连接为https，而CDN服务器到GithubPage服务器的连接为http，就是在CDN服务器那里加上反向代理。<br><strong>步骤如下：</strong></p><ol><li>首先注册并登陆CloudFlare,在域名购买的地方修改name sever，修改DNS解析地址。（启用动态DNS加速）<br><img src="https://s1.ax1x.com/2018/12/26/F2r3Ks.png" alt="此处输入图片的描述"></li><li>与域名绑定并激活成功后，设置CloudFlare 的 DNS：<br><img src="https://s1.ax1x.com/2018/12/26/F2rdGF.png" alt="此处输入图片的描述"></li><li>设置CloudFlare 的 Crypto：<br><img src="https://s1.ax1x.com/2018/12/26/F2rDM9.png" alt="此处输入图片的描述"></li><li>设置路由规则Page Rules：<br><img src="https://s1.ax1x.com/2018/12/26/F2rsq1.png" alt="此处输入图片的描述"><br>至此，等待一段时间，就可以用https协议访问你的自定义域名<br>为了让博客完全开启Https，还需要修改文章内容中用http协议的链接，比如图片，这样，就能看到浏览器域名旁边的小绿锁啦！<br><img src="https://s1.ax1x.com/2018/12/27/F255Q0.png" alt="此处输入图片的描述"><br>同时，修改了DNS解析服务器后，网站响应速度也更快了！一举两得！</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;汇总搭建博客遇见的几个问题（持续更新。。。）&lt;br&gt;
    
    </summary>
    
      <category term="Guidances" scheme="https://yoursite.com/categories/Guidances/"/>
    
    
      <category term="hexo" scheme="https://yoursite.com/tags/hexo/"/>
    
      <category term="blog" scheme="https://yoursite.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Java的艺术-注解类型(Annotation)</title>
    <link href="https://yoursite.com/2018/11/28/Java%E7%9A%84%E8%89%BA%E6%9C%AF-%E6%B3%A8%E8%A7%A3%E7%B1%BB%E5%9E%8B(Annotation)/"/>
    <id>https://yoursite.com/2018/11/28/Java的艺术-注解类型(Annotation)/</id>
    <published>2018-11-28T03:08:02.000Z</published>
    <updated>2019-03-17T04:13:49.398Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551345094255&amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;imgtype=0&amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png" alt="此处输入图片的描述"><br>使用注解来进行开发，可以免去写XML配置。那么注解到底是什么呢？</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a><font color="red"><strong>概念</strong></font></h2><p><strong>注解（Annotation）</strong></p><blockquote><p>也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。<br>这些标记和注释可以在编译、类加载、运行时被读取，并执行响应的处理。<br><strong>通俗地讲，注解相当于给类、属性或者方法贴上一个标签。</strong></p></blockquote><p><strong>注解的元注解</strong></p><blockquote><p>元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。<br>元注解有五种：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>、<span class="meta">@Documented</span>、<span class="meta">@Target</span>、<span class="meta">@Inherited</span>、<span class="meta">@Repeatable</span></span><br></pre></td></tr></table></figure></p></blockquote><h2 id="注解的基本用法"><a href="#注解的基本用法" class="headerlink" title="注解的基本用法"></a><font color="red"><strong>注解的基本用法</strong></font></h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>注解通过@interface 关键字定义。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个名为AnnotationTest的注解。</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationTest&#123;&#125;</span><br></pre></td></tr></table></figure></p><h3 id="注解的属性"><a href="#注解的属性" class="headerlink" title="注解的属性"></a>注解的属性</h3><p>注解的属性类似于类的成员变量。并且注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“<strong>无形参的方法</strong>”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。<br>可以通过<font color="red"><strong>default</strong></font>关键字给出默认值。<br>举例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationTest&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "Hello World"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在使用的时候，赋值的方式是在注解的括号内以 <font color="red"><strong>value=””</strong></font>形式，多个属性之间用<font color="red"><strong>“,”</strong></font>隔开。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AnnotationTest</span>(id=<span class="number">0</span>,message=<span class="string">"God"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为属性message有默认值，也可以不赋值</span></span><br><span class="line"><span class="meta">@AnnotationTest</span>(id=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当所有属性都有默认值，括号内为空</span></span><br></pre></td></tr></table></figure></p><p>甚至当注解没有属性时，可以不用括号：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Check &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有属性的注解，不用括号</span></span><br><span class="line"><span class="meta">@Check</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h3><blockquote><p>注解中所有方法（也就是属性）没有方法体，且只允许public和abstract修饰。缺省默认为public，且注解方法不允许有throws子句。</p></blockquote><blockquote><p>注解中方法的返回值只能为：基本数据类型，String，Class，美剧类型，注解和他们的一维数组。</p></blockquote><blockquote><p>注解的继承只能作用在类上，方法上的注解不会被继承，Interface中的所有注解不会被继承。</p></blockquote><h2 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a><font color="red"><strong>常见注解</strong></font></h2><h3 id="五种元注解"><a href="#五种元注解" class="headerlink" title="五种元注解"></a>五种元注解</h3><p>前面我们提到，Java中有五种元注解。</p><ul><li><p><strong>@Retention</strong></p><blockquote><p>解释说明一个注解的存活时间。取值如下：</p></blockquote><ul><li><strong>RetentionPolicy.SOURCE</strong>        注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。</li><li><strong>RetentionPolicy.CLASS</strong> 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。</li><li><strong>RetentionPolicy.RUNTIME</strong> 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationTest &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>@Documented</strong></p></li></ul><blockquote><p>能够将注解中的元素包含到 Javadoc 中去。</p></blockquote><ul><li><p><strong>@Target</strong></p><blockquote><p>限定注解运用的场景。取值如下：</p></blockquote><ul><li><strong>ElementType.ANNOTATION_TYPE</strong> 可以给一个注解进行注解</li><li><strong>ElementType.CONSTRUCTOR</strong> 可以给构造方法进行注解</li><li><strong>ElementType.FIELD</strong> 可以给属性进行注解</li><li><strong>ElementType.LOCAL_VARIABLE</strong> 可以给局部变量进行注解</li><li><strong>ElementType.METHOD</strong> 可以给方法进行注解</li><li><strong>ElementType.PACKAGE</strong> 可以给一个包进行注解</li><li><strong>ElementType.PARAMETER</strong> 可以给一个方法内的参数进行注解</li><li><strong>ElementType.TYPE</strong> 可以给一个类型进行注解，比如类、接口、枚举</li></ul></li><li><p><strong>@Inherited</strong></p><blockquote><p>如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> Test &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为Test注解被@Inherited注解，所以继承了注解了Test的A类后的B类，也拥有Test这个注解。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>@Repeatable</strong></p><blockquote><p>Repeatable 是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> Persons &#123;</span><br><span class="line">Person[]  value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repeatable</span>(Persons.class)</span><br><span class="line"><span class="meta">@interface</span> Person&#123;</span><br><span class="line">String role <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"artist"</span>)</span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"coder"</span>)</span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"PM"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>@Repeatable 注解了 Person。而 @Repeatable 后面括号中的类相当于一个容器注解。</p><p>什么是<strong>容器注解</strong>呢？就是用来存放其它注解的地方。它本身也是一个注解。</p><p>我们再看看代码中的相关容器注解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> Persons &#123;</span><br><span class="line">Person[]  value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>按照规定，它里面必须要有一个 value 的属性，属性类型是一个被 @Repeatable 注解过的注解数组，注意它是数组。</p><p>可以这样理解。Persons 是一张总的标签，上面贴满了 Person 这种同类型但内容不一样的标签。把 Persons 给一个 SuperMan 贴上，相当于同时给他贴了程序员、产品经理、画家的标签。</p><h3 id="Java预置注解"><a href="#Java预置注解" class="headerlink" title="Java预置注解"></a>Java预置注解</h3><p>Java本身提供了现成的注解。</p><ul><li><p><strong>@Deprecated</strong></p><blockquote><p>用来标记过时的元素。</p></blockquote></li><li><p><strong>@Override</strong></p><blockquote><p>提示子类要复写父类中被@Override 修饰的方法</p></blockquote></li><li><p><strong>@SuppressWarnings</strong></p><blockquote><p>阻止警告。调用被 @Deprecated 注解的方法后，编译器会警告提醒，而有时候开发者会忽略这种警告，他们可以在调用的地方通过 @SuppressWarnings 达到目的。</p></blockquote></li><li><p><strong>@SafeVarargs</strong></p><blockquote><p>参数安全类型注解。它的目的是提醒开发者不要用参数做一些不安全的操作,它的存在会阻止编译器产生 unchecked 这样的警告。它是在 Java 1.7 的版本中加入的。</p></blockquote></li><li><p><strong>@FunctionalInterface</strong></p><blockquote><p>函数式接口注解，这个是 Java 1.8 版本引入的新特性。线程开发中常用的 Runnable 就是一个典型的函数式接口。函数式接口可以很容易转换为 Lambda 表达式。</p></blockquote></li></ul><h2 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a><font color="red"><strong>注解的作用</strong></font></h2><blockquote><p><strong>编译检查</strong> 编译器可以利用注解来探测错误和警告信息；通过代码里标识的元数据让编译器能够实现基本的编译检查【Override】</p></blockquote><blockquote><p><strong>编写文档</strong> 软件工具可以用来利用注解信息来生成代码、Html文档或者做其它相应处理。通过代码里标识的元数据生成文档【生成文档doc文档】</p></blockquote><blockquote><p><strong>代码分析</strong> 某些注解可以在程序运行的时候接受代码的提取；通过代码里标识的元数据对代码进行分析【使用反射】</p></blockquote><p>总之，当开发者使用了Annotation 修饰了类、方法、Field 等成员之后，这些 Annotation 不会自己生效，必须由开发者提供相应的代码来提取并处理 Annotation 信息。这些处理提取和处理 Annotation 的代码统称为 APT（Annotation Processing Tool)。<br><strong>而注解主要就是给编译器或者APT用的。</strong></p><p>注解也就是代码添加元数据，描述信息。</p><p>相比使用单独的XML来描述这些元数据，使用注解要简单些，和代码在一起也更好维护。相比使用继承（如TesCase）或者方法前缀的约定（如testXXX是测试方法）要灵活些。</p><p></p><p>一些插件机制就是通过注解提供插件的元数据，在加载类后扫描所以带该注解的类就可以找到插件，减少了配置的麻烦。</p><p></p><h2 id="注解的解析-反射"><a href="#注解的解析-反射" class="headerlink" title="注解的解析-反射"></a><font color="red"><strong>注解的解析-反射</strong></font></h2><p>注解的提取（解析）需要借助于 Java 的反射技术，反射比较慢，所以注解使用时也需要谨慎计较时间成本。</p><h3 id="类的注解的解析"><a href="#类的注解的解析" class="headerlink" title="类的注解的解析"></a>类的注解的解析</h3><blockquote><p>首先通过Class对象的isAnnotationPresent()方法判断他是否应用了某个注解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnnotationPresent</span><span class="params">(Class&lt;? extends Annotation&gt; annotationClass)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>然后通过getAnnotation()方法获取Annotation对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;A extends Annotation&gt; <span class="function">A <span class="title">getAnnotation</span><span class="params">(Class&lt;A&gt; annotationClass)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>或者getAnnotations()方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Annotation[] getAnnotations() &#123;&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>如果获取到的 Annotation 如果不为 null，则就可以调用它们的属性方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AnnotationTest</span>()</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> hasAnnotation = Test.class.isAnnotationPresent(TestAnnotation.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( hasAnnotation ) &#123;</span><br><span class="line">TestAnnotation testAnnotation = Test.class.getAnnotation(TestAnnotation.class);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"id:"</span>+testAnnotation.id());</span><br><span class="line">System.out.println(<span class="string">"message:"</span>+testAnnotation.message());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>也可以使用forName()方法加载类，使用isAnnotation(Annotation.class)判定对象是否存在注解，并使用getAnnotation(Description.class)得到带有@Description注解的类。</p><h3 id="方法的注解的解析"><a href="#方法的注解的解析" class="headerlink" title="方法的注解的解析"></a>方法的注解的解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@AnnotationTest</span>()</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_method</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        Test my_test = <span class="keyword">new</span> Test();</span><br><span class="line">        Class test_class = Test.class;</span><br><span class="line">        Method method = test_class.getDeclaredMethod(<span class="string">"test_method"</span>,String.class);</span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(AnnotationTest.class)) &#123;</span><br><span class="line">            <span class="comment">//执行方法</span></span><br><span class="line">            method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            method.invoke(my_test, <span class="string">"hello"</span>);</span><br><span class="line">            <span class="comment">//解析注解元素</span></span><br><span class="line">            AnnotationTest a = method.getAnnotation(AnnotationTest.class);</span><br><span class="line">            System.out.println(a.test());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的属性的注解的解析"><a href="#类的属性的注解的解析" class="headerlink" title="类的属性的注解的解析"></a>类的属性的注解的解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@AnnotationTest</span>()</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_method</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        Test my_test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="comment">//利用反射，通过class对象的getDeclaredField(String str)获得元素Field对象</span></span><br><span class="line">        Field test_field = Test.class.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">        <span class="comment">//判断元素是否是注解的对象</span></span><br><span class="line">        <span class="keyword">if</span>(test_field.isAnnotationPresent(AnnotationTest.class))&#123;</span><br><span class="line">            <span class="comment">//修改权限（同一个类内部其实没有必要，肯定有访问权限。）</span></span><br><span class="line">            test_field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//利用Field对象的getXXX()获取实例的值。</span></span><br><span class="line">            System.out.println(test_field.getInt(my_test));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><blockquote><p>一定要用@Retention元注解表示出注解的存活时间，不然在动态执行时可能判定某个类并没有受到注解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationTest &#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">default</span> 2019</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><hr><p><a href="https://www.cnblogs.com/Qian123/p/5256084.html" target="_blank" rel="noopener">参考1</a><br><a href="https://blog.csdn.net/briblue/article/details/73824058" target="_blank" rel="noopener">参考2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1551345094255&amp;amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;amp;imgtype=0&amp;amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;使用注解来进行开发，可以免去写XML配置。那么注解到底是什么呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Languages" scheme="https://yoursite.com/categories/Languages/"/>
    
    
      <category term="Java" scheme="https://yoursite.com/tags/Java/"/>
    
      <category term="注解" scheme="https://yoursite.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
      <category term="反射" scheme="https://yoursite.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Java的艺术-浅谈反射机制</title>
    <link href="https://yoursite.com/2018/11/25/Java%E7%9A%84%E8%89%BA%E6%9C%AF-%E6%B5%85%E6%9E%90%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>https://yoursite.com/2018/11/25/Java的艺术-浅析反射机制/</id>
    <published>2018-11-25T13:08:02.000Z</published>
    <updated>2019-03-12T07:42:16.658Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551345094255&amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;imgtype=0&amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png" alt="此处输入图片的描述"><br>在运行时发现和使用类的信息 - <strong>Java反射</strong>。</p><a id="more"></a><h2 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h2><p>通俗的解释是：JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p><h2 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h2><p>动态语言，是指程序在运行时可以改变其结构：新的函数可以被引进，已有的函数可以被删除等在结构上的变化。</p><h2 id="反射的作用"><a href="#反射的作用" class="headerlink" title="反射的作用"></a>反射的作用</h2><p><a href="https://zhuanlan.zhihu.com/p/32259566" target="_blank" rel="noopener">参考</a><br>假设我们有很多食材需要处理，猪肉，牛肉，羊肉；每一样食材对应一个类，这个类里面有处理食材的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pork</span></span>&#123;     <span class="comment">//猪肉</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"cook pork"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Beef</span></span>&#123;     <span class="comment">//牛肉</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"cook beef"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mutton</span></span>&#123;    <span class="comment">//羊肉</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"cook mutton"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当我们在程序中需要根据食材的不同来实例化对应类的对象，再调用对应的方法要怎么做呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       String food=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(food.equals(<span class="string">"Pork"</span>))&#123;</span><br><span class="line">                Pork pork=<span class="keyword">new</span> Pork();</span><br><span class="line">                pork.cook();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(food.equals(<span class="string">"Beef"</span>))&#123;</span><br><span class="line">Beef beef=<span class="keyword">new</span> Beef();</span><br><span class="line">beef.cook();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(food.equals(<span class="string">"Mutton"</span>))&#123;</span><br><span class="line">Mutton mutton=<span class="keyword">new</span> Mutton();</span><br><span class="line">mutton.cook();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上的做法是很容易想到的，很直观，但是当我们的食材有几十种甚至上百种时，我们要怎么写上百个if else 来判断食材，再实例化对应的类，调用对应的方法。</p><p>有没有更简单的方法？答案是肯定的，我们可以利用反射机制来完成这一工作，在程序运行时根据类名实例化对应的对象，并调用对应的方法</p><p>步骤如下：</p><p>1、首先我们需要用到接口:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFood</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、所有的食材类实现这一接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pork</span> <span class="keyword">implements</span> <span class="title">IFood</span></span>&#123;     <span class="comment">//猪肉</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"cook pork"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Beef</span> <span class="keyword">implements</span> <span class="title">IFood</span></span>&#123;     <span class="comment">//牛肉</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"cook beef"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mutton</span> <span class="keyword">implements</span> <span class="title">IFood</span></span>&#123;    <span class="comment">//羊肉</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"cook mutton"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3、接下来我们看看怎么使程序更为简单<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">         String food=<span class="string">"Pork"</span>;                 <span class="comment">//字符串food代表食物的类</span></span><br><span class="line">         Class c=Class.forName(food);        <span class="comment">//根据字符串food来载入类对象</span></span><br><span class="line">         Object object=c.newInstance();      <span class="comment">//生成对象</span></span><br><span class="line">         IFood Ifood=(IFood)object;          <span class="comment">//强制转型</span></span><br><span class="line">         Ifood.cook();                       <span class="comment">//调用方法</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如此一来我们不需要写冗杂的if else 嵌套了</p><p>只需要利用 Class.forName()方法根据字符串来实例化对应的类，并调用其方法即可。</p><p>当我们需要处理其他的食材的时候只需要添加对应的类即可，而主程序中可以不改变一行代码。</p><h2 id="反射的应用"><a href="#反射的应用" class="headerlink" title="反射的应用"></a>反射的应用</h2><h3 id="Class对象的获取"><a href="#Class对象的获取" class="headerlink" title="Class对象的获取"></a>Class对象的获取</h3><p>加载完类之后, 在堆内存中会产生一个Class类型的对象(一个类只有一个Class对象), 这个对象包含了完整的类的结构信息,而且这个Class对象就像一面镜子,透过这个镜子看到类的结构,所以被称之为:<strong>反射。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line">--java.lang.Class&lt;T&gt;</span><br></pre></td></tr></table></figure></p><p>获取Class对象的方法一般有三种方法：</p><blockquote><p>调用<strong>对象</strong>的getClass()方法;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"test"</span>);</span><br><span class="line">Class&lt;?&gt; class1 = sb.getClass();</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p><strong>类名</strong>的.class(最安全/性能最好)属性，或者TYPE属性(继承自Object类);<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; class1 = <span class="keyword">int</span>.class;</span><br><span class="line">Class&lt;?&gt; class2 = Integer.class;</span><br><span class="line">Class&lt;?&gt; class3 = Integer.TYPE;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>运用<strong>Class.forName(String className)</strong>动态加载类,className需要是类的全限定名(最常用)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; class1 = Class.forName(<span class="string">"Integer"</span>);</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="创建实例化对象"><a href="#创建实例化对象" class="headerlink" title="创建实例化对象"></a>创建实例化对象</h3><p>得到了对应java.lang.Class对象，有两种方法通过反射生成对象：[<strong>都需要抛出异常</strong>]</p><blockquote><p>使用Class对象的newInstance()方法来创建该Class对象对应类的实例(这种方式要求该Class对象的对应类有默认构造器)；<strong>相当于无参构造</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; class1 = String.class;</span><br><span class="line">Object str = c.newInstance();</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>先使用Class对象获取指定的Constructor对象, 再调用Constructor对象的newInstance()方法来创建该Class对象对应类的实例(通过这种方式可以选择指定的构造器来创建实例).<strong>适用于无参和有参的构造方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span></span></span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取String所对应的Class对象</span></span><br><span class="line">Class&lt;?&gt; c = String.class;</span><br><span class="line"><span class="comment">//获取String类带一个String参数的构造器</span></span><br><span class="line">Constructor constructor = c.getConstructor(String.class);</span><br><span class="line"><span class="comment">//根据构造器创建实例</span></span><br><span class="line">Object obj = constructor.newInstance(<span class="string">"test"</span>);</span><br></pre></td></tr></table></figure><p>另外可以用getConstructors()方法返回Constructor对象的一个数组。这些对象反映此 Class 对象所表示的类的所有公共构造方法。如果该类没有公共构造方法，或者该类是一个数组类，或者该类反映一个基本类型或 void，则返回一个长度为 0 的数组。 注意，此方法返回 Constructor<t> 对象的数组（即取自此类构造方法的数组）时，此方法的返回类型是 Constructor&lt;?&gt;[]，不是预期的 Constructor<t>[]。此少量信息的返回类型是必需的，因为从此方法返回之后，该数组可能被修改以保存不同类的 Constructor 对象，而这将违反 Constructor<t>[] 的类型保证。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = String.class;<span class="comment">//获取Class对象</span></span><br><span class="line">Constructor&lt;?&gt; cons[] = c.getConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor&lt;?&gt; constructor : cons) &#123;</span><br><span class="line">    System.out.println(constructor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></t></t></p><p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">byte</span>[],<span class="keyword">int</span>,<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">byte</span>[],java.nio.charset.Charset)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">byte</span>[],java.lang.String) <span class="keyword">throws</span> java.io.UnsupportedEncodingException</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">byte</span>[],<span class="keyword">int</span>,<span class="keyword">int</span>,java.nio.charset.Charset)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">byte</span>[],<span class="keyword">int</span>,<span class="keyword">int</span>,java.lang.String) <span class="keyword">throws</span> java.io.UnsupportedEncodingException</span><br><span class="line"><span class="keyword">public</span> java.lang.String(java.lang.StringBuilder)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(java.lang.StringBuffer)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">byte</span>[])</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">int</span>[],<span class="keyword">int</span>,<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> java.lang.String()</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">char</span>[])</span><br><span class="line"><span class="keyword">public</span> java.lang.String(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">char</span>[],<span class="keyword">int</span>,<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">byte</span>[],<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="keyword">byte</span>[],<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure></p><p>此外，还可以用getDeclaredConstructors()方法获取所有的构造方法。</p><blockquote><p><strong>getConstructor()和getDeclaredConstructor()区别:</strong></p></blockquote><blockquote><p>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)<br>这个方法会返回制定参数类型的所有构造器，包括public的和非public的，当然也包括private的。<br>getDeclaredConstructors()的返回结果就没有参数类型的过滤了。</p></blockquote><blockquote><p>getConstructor(Class&lt;?&gt;… parameterTypes)<br>这个方法返回的是getDeclaredConstructor()方法返回结果的子集，只返回制定参数类型访问权限是public的构造器。<br>getConstructors()的返回结果同样也没有参数类型的过滤。</p></blockquote><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><p>获取某个Class对象的方法集合，主要有以下几种方法：</p><blockquote><p>getDeclaredMethods方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>getMethods方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method[] getMethods() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>getMethod 方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为<font color="red"><strong>方法的参数对应Class的对象</strong></font>。<br>注意：如果不带方法参数对应的class对象，则无法根据方法名获取对应的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></span><br></pre></td></tr></table></figure></p></blockquote><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><blockquote><p>当我们从类中获取了一个方法后，我们就可以用 invoke() 方法来调用这个方法。invoke 方法的原型为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span> <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException</span></span><br></pre></td></tr></table></figure></p></blockquote><p><strong>invoke回调流程示例：</strong></p><ul><li><p>由Class对象动态构造对应类型对象；</p></li><li><p>利用Class对象的getMethod()、getMethods()、getDeclaredMethod()、getDeclaredMethods()等方法构造method对象；</p></li><li><p>类型对象，使其执行对应形参的方法（也就是需要传入一个<strong>动态执行方法的对象</strong>，以及<strong>对应方法的形参</strong>）。</p></li></ul><p>举例：(利用反射调用String对象的toString()方法)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class test = String.class;</span><br><span class="line">Object ob = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">Method me = test.getDeclaredMethod(<span class="string">"toString"</span>);</span><br><span class="line">System.out.println(me.invoke(ob,<span class="keyword">null</span>));</span><br></pre></td></tr></table></figure></p><p><strong>invoke()的缺点:</strong></p><ul><li><p>invoke的参数和返回值必需时Object类型的，这意味着必须进行多次的类型转换（特别是基本数据类型），而这将导致编译器错过检查代码的机会，有类型安全的风险，只有到了测试阶段才会发现这些错误，此时找到并改正他们将会更加困难。</p></li><li><p>使用反射获得方法指针的代码要比仅仅直接调用方法明显慢一些。</p></li><li><p>因此仅在必要时才使用Method对象，而最好使用<strong>接口和内部类</strong>，不建议Java开发者使用Method对象的回调功能，使用接口进行回调不仅会使代码的运行速度更快，还更易于维护。</p></li></ul><h3 id="访问成员变量"><a href="#访问成员变量" class="headerlink" title="访问成员变量"></a>访问成员变量</h3><p>通过Class对象的的getField()方法可以获取该类所包含的全部或指定的成员变量Field,Filed提供了如下两组方法来读取和设置成员变量值：<br><strong>getFiled：</strong>访问公有的成员变量<br><strong>getDeclaredField：</strong>所有已声明的成员变量，但不能得到其父类的成员变量</p><blockquote><p>getXxx(Object obj): 获取obj对象的该成员变量的值, 此处的Xxx对应8中基本类型,如果该成员变量的类型是引用类型, 则取消get后面的Xxx;<br>setXxx(Object obj, Xxx val): 将obj对象的该成员变量值设置成val值.此处的Xxx对应8种基本类型, 如果该成员类型是引用类型, 则取消set后面的Xxx;</p></blockquote><p><font color="red">注: getDeclaredXxx方法可以获取所有的成员变量,无论private/public</font>;</p><h2 id="反射与Spring框架设计"><a href="#反射与Spring框架设计" class="headerlink" title="反射与Spring框架设计"></a>反射与Spring框架设计</h2><p>反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射，运行时动态加载需要加载的对象。</p><p>Spring内部采用了很多反射机制。<br>很多web框架的前端，实现URI请求映射到Action方法，也可以简单的通过反射来做。<br>这部分内容后面再单独补充。</p><h2 id="反射存在的问题"><a href="#反射存在的问题" class="headerlink" title="反射存在的问题"></a><a href="https://www.sczyh30.com/posts/Java/java-reflection-1/" target="_blank" rel="noopener">反射存在的问题</a></h2><ol><li>由于反射会<strong>额外消耗一定的系统资源</strong>，因此如果不需要动态地创建一个对象，那么就不需要用反射。</li><li>另外，反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致<strong>安全问题</strong>。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1551345094255&amp;amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;amp;imgtype=0&amp;amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;在运行时发现和使用类的信息 - &lt;strong&gt;Java反射&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Languages" scheme="https://yoursite.com/categories/Languages/"/>
    
    
      <category term="Java" scheme="https://yoursite.com/tags/Java/"/>
    
      <category term="注解" scheme="https://yoursite.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
      <category term="反射" scheme="https://yoursite.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>算法之美-二叉树的遍历</title>
    <link href="https://yoursite.com/2018/10/21/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <id>https://yoursite.com/2018/10/21/算法之美-二叉树的遍历/</id>
    <published>2018-10-21T08:01:01.000Z</published>
    <updated>2019-03-21T08:00:05.985Z</updated>
    
    <content type="html"><![CDATA[<p>前序？后序？层序？递归？一问看尽二叉树应该怎么遍历。<br><a id="more"></a></p><h2 id="二叉树的定义："><a href="#二叉树的定义：" class="headerlink" title="二叉树的定义："></a>二叉树的定义：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: WuFan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/3/6 22:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> offer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> BinaryTreeNode left;</span><br><span class="line">    <span class="keyword">private</span> BinaryTreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode</span><span class="params">(<span class="keyword">int</span> data, BinaryTreeNode left, BinaryTreeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(BinaryTreeNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(BinaryTreeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的遍历："><a href="#二叉树的遍历：" class="headerlink" title="二叉树的遍历："></a>二叉树的遍历：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: WuFan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/3/6 22:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> offer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前序遍历递归的方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>!=root)&#123;</span><br><span class="line">            System.out.print(root.getData()+<span class="string">"\t"</span>);</span><br><span class="line">            preOrder(root.getLeft());</span><br><span class="line">            preOrder(root.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历非递归的方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderNonRecursive</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">        Stack&lt;BinaryTreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;BinaryTreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.print(root.getData()+<span class="string">"\t"</span>);</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root=root.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty()) <span class="keyword">break</span>;</span><br><span class="line">            root=stack.pop();</span><br><span class="line">            root=root.getRight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历采用递归的方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>!=root)&#123;</span><br><span class="line">            inOrder(root.getLeft());</span><br><span class="line">            System.out.print(root.getData()+<span class="string">"\t"</span>);</span><br><span class="line">            inOrder(root.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历采用非递归的方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderNonRecursive</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">        Stack&lt;BinaryTreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;BinaryTreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root=root.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty())<span class="keyword">break</span>;</span><br><span class="line">            root=stack.pop();</span><br><span class="line">            System.out.print(root.getData()+<span class="string">"\t"</span>);</span><br><span class="line">            root=root.getRight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历采用递归的方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            postOrder(root.getLeft());</span><br><span class="line">            postOrder(root.getRight());</span><br><span class="line">            System.out.print(root.getData()+<span class="string">"\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历采用非递归的方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderNonRecursive</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">        Stack&lt;BinaryTreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;BinaryTreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root=root.getLeft();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span>==stack.lastElement().getRight())&#123;</span><br><span class="line">                    root=stack.pop();</span><br><span class="line">                    System.out.print(root.getData()+<span class="string">"\t"</span>);</span><br><span class="line">                    <span class="keyword">while</span>(root==stack.lastElement().getRight())&#123;</span><br><span class="line">                        System.out.print(stack.lastElement().getData()+<span class="string">"\t"</span>);</span><br><span class="line">                        root=stack.pop();</span><br><span class="line">                        <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(!stack.isEmpty())</span><br><span class="line">                    root=stack.lastElement().getRight();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    root=<span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//层序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">        BinaryTreeNode temp;</span><br><span class="line">        Queue&lt;BinaryTreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;BinaryTreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            temp=queue.poll();</span><br><span class="line">            System.out.print(temp.getData()+<span class="string">"\t"</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span>!=temp.getLeft())</span><br><span class="line">                queue.offer(temp.getLeft());</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span>!=temp.getRight())&#123;</span><br><span class="line">                queue.offer(temp.getRight());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinaryTreeNode node10=<span class="keyword">new</span> BinaryTreeNode(<span class="number">10</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        BinaryTreeNode node8=<span class="keyword">new</span> BinaryTreeNode(<span class="number">8</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        BinaryTreeNode node9=<span class="keyword">new</span> BinaryTreeNode(<span class="number">9</span>,<span class="keyword">null</span>,node10);</span><br><span class="line">        BinaryTreeNode node4=<span class="keyword">new</span> BinaryTreeNode(<span class="number">4</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        BinaryTreeNode node5=<span class="keyword">new</span> BinaryTreeNode(<span class="number">5</span>,node8,node9);</span><br><span class="line">        BinaryTreeNode node6=<span class="keyword">new</span> BinaryTreeNode(<span class="number">6</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        BinaryTreeNode node7=<span class="keyword">new</span> BinaryTreeNode(<span class="number">7</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        BinaryTreeNode node2=<span class="keyword">new</span> BinaryTreeNode(<span class="number">2</span>,node4,node5);</span><br><span class="line">        BinaryTreeNode node3=<span class="keyword">new</span> BinaryTreeNode(<span class="number">3</span>,node6,node7);</span><br><span class="line">        BinaryTreeNode node1=<span class="keyword">new</span> BinaryTreeNode(<span class="number">1</span>,node2,node3);</span><br><span class="line"></span><br><span class="line">        BinaryTree tree=<span class="keyword">new</span> BinaryTree();</span><br><span class="line">        <span class="comment">//采用递归的方式进行遍历</span></span><br><span class="line">        System.out.println(<span class="string">"-----前序遍历------"</span>);</span><br><span class="line">        tree.preOrder(node1);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//采用非递归的方式遍历</span></span><br><span class="line">        tree.preOrderNonRecursive(node1);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//采用递归的方式进行遍历</span></span><br><span class="line">        System.out.println(<span class="string">"-----中序遍历------"</span>);</span><br><span class="line">        tree.inOrder(node1);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//采用非递归的方式遍历</span></span><br><span class="line">        tree.inOrderNonRecursive(node1);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//采用递归的方式进行遍历</span></span><br><span class="line">        System.out.println(<span class="string">"-----后序遍历------"</span>);</span><br><span class="line">        tree.postOrder(node1);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//采用非递归的方式遍历</span></span><br><span class="line">        tree.postOrderNonRecursive(node1);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//采用递归的方式进行遍历</span></span><br><span class="line">        System.out.println(<span class="string">"-----层序遍历------"</span>);</span><br><span class="line">        tree.levelOrder(node1);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前序？后序？层序？递归？一问看尽二叉树应该怎么遍历。&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="https://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="algorithms" scheme="https://yoursite.com/tags/algorithms/"/>
    
      <category term="树" scheme="https://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Java的艺术-数据类型详解</title>
    <link href="https://yoursite.com/2018/10/07/Java%E7%9A%84%E8%89%BA%E6%9C%AF-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://yoursite.com/2018/10/07/Java的艺术-数据类型/</id>
    <published>2018-10-07T06:48:20.000Z</published>
    <updated>2019-03-15T16:03:23.122Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551345094255&amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;imgtype=0&amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png" alt="此处输入图片的描述"></p><p><strong>一文道尽Java数据类型怎么用。</strong><br><a id="more"></a></p><h2 id="一、什么是数据类型"><a href="#一、什么是数据类型" class="headerlink" title="一、什么是数据类型"></a><font color="red">一、什么是数据类型</font></h2><p>　　数据类型在计算机语言里面，是对内存位置的一个抽象表达方式，可以理解为针对内存的一种抽象的表达方式。<br>　　Java是强类型语言，所以Java对于数据类型的规范会相对严格。数据类型是语言的抽象原子概念，可以说是语言中最基本的单元定义，在Java里面，本质上讲将数据类型分为两种：基本类型和引用数据类型。</p><blockquote><p>基本类型：简单数据类型是不能简化的、内置的数据类型、由编程语言本身定义，它表示了真实的数字、字符和整数。</p></blockquote><blockquote><p>引用数据类型：Java语言本身不支持C++中的结构（struct）或联合（union）数据类型，它的复合数据类型一般都是通过类或接口进行构造，类提供了捆绑数据和方法的方式，同时可以针对程序外部进行信息隐藏。</p></blockquote><p>　　不同数据类型的变量在内存中分配的字节数不同，同时存储方式也是不同的。所以Java给变量赋值前需要先确定变量的类型，确定了变量的类型，即确定了数据需分配内存空间的大小，数据在内存的存储方式。</p><h2 id="二、Java基本类型和对应的包装类型"><a href="#二、Java基本类型和对应的包装类型" class="headerlink" title="二、Java基本类型和对应的包装类型"></a><font color="red">二、Java基本类型和对应的包装类型</font></h2><p>为了方便对基本类型进行操作，Java为每个基本类型提供了对应的包装类型（引用类型）。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><strong>byte</strong>：Java中最小的数据类型，在内存中占8位(bit)，即1个字节，取值范围-128~127，默认值0</p><p><strong>short</strong>：短整型，在内存中占16位，即2个字节，取值范围-32768~32717，默认值0</p><p><strong>int</strong>：整型，用于存储整数，在内在中占32位，即4个字节，取值范围-2147483648~2147483647，默认值0</p><p><strong>long</strong>：长整型，在内存中占64位，即8个字节-2^63~2^63-1，默认值0L</p><p><strong>float</strong>：浮点型，在内存中占32位，即4个字节，用于存储带小数点的数字（与double的区别在于float类型有效小数点只有6~7位），默认值0</p><p><strong>double</strong>：双精度浮点型，用于存储带有小数点的数字，在内存中占64位，即8个字节，默认值0</p><p><strong>char</strong>：字符型，用于存储单个字符，占16位，即2个字节，取值范围0~65535，默认值为空</p><p><strong>boolean</strong>：布尔类型，占<a href="https://www.jianshu.com/p/2f663dc820d0" target="_blank" rel="noopener">1位，1个字节或者四个字节(存在不同解释角度)</a>，用于判断真或假（仅有两个值，即true、false），默认值false。</p><p>Java中基本类型的存储是固定字节的，具体大小与对应的包装类型如下：</p><table><thead><tr><th style="text-align:center">基本类型</th><th style="text-align:center">存储位数</th><th style="text-align:center">包装类型</th></tr></thead><tbody><tr><td style="text-align:center">boolean</td><td style="text-align:center"><a href="https://www.jianshu.com/p/2f663dc820d0" target="_blank" rel="noopener">1,8,32</a></td><td style="text-align:center">Boolean</td></tr><tr><td style="text-align:center">byte</td><td style="text-align:center">8</td><td style="text-align:center">Byte</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">16</td><td style="text-align:center">Character</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">16</td><td style="text-align:center">Short</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">32</td><td style="text-align:center">Integer</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">64</td><td style="text-align:center">Long</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">32</td><td style="text-align:center">Float</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">64</td><td style="text-align:center">Double</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">BigInteger</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">BigDecimal</td></tr></tbody></table><h3 id="封装类型特征"><a href="#封装类型特征" class="headerlink" title="封装类型特征"></a>封装类型特征</h3><blockquote><p>每个基本类型都有一个包装类，这些包装类包含在<strong>java.lang</strong>包中。继承关系如下：</p></blockquote><ul><li>Object<ul><li>Boolean</li><li>Number<ul><li>Byte</li><li>Short</li><li>Integer</li><li>Long</li><li>Float</li><li>Double</li><li>BigInteger</li><li>BigDecimal</li></ul></li><li>Character</li></ul></li></ul><blockquote><p><strong>BigInteger、BigDecimal</strong>没有相对应的基本类型，主要应用于高精度的运算，<strong>BigInteger</strong> 支持任意精度的整数，<strong>BigDecimal</strong>支持任意精度带小数点的运算。</p></blockquote><blockquote><p>当整数类型的数据使用字面量赋值的时候，默认值为int类型，就是直接使用0或者其他数字的时候，<strong>默认值的类型为int类型</strong>，所以当使用 long a = 0这种赋值方式的时候，JVM内部存在数据转换。</p></blockquote><blockquote><p>浮点类型的数据使用字面量赋值的时候，<strong>默认值为double类型</strong>，就是当小数字面量出现的时候，JVM会使用double类型的数据类型。</p></blockquote><blockquote><p>从JDK 5.0开始，Java包含<strong>自动拆箱装箱</strong>的特性.调用valueOf()方法。</p></blockquote><h3 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h3><p>基本类型对应的缓冲池如下：</p><ul><li>-boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul><h2 id="三、在内存中的存储方式"><a href="#三、在内存中的存储方式" class="headerlink" title="三、在内存中的存储方式"></a><font color="red">三、在内存中的存储方式</font></h2><blockquote><p><strong>基本数据类型：</strong>所有的简单数据类型不存在“引用”的概念，基本数据类型都是直接存储在内存中的堆、栈上；</p></blockquote><blockquote><p><strong>引用类型：</strong>引用类型继承于Object类（也是引用类型）都是按照Java里面存储对象的内存模型来进行数据存储的，使用Java内存堆和内存栈来进行这种类型的数据存储，简单地讲，“引用”是存储在有序的内存栈上的，而对象本身的值存储在内存堆上的；</p></blockquote><h3 id="关于基本数据类型存放的位置"><a href="#关于基本数据类型存放的位置" class="headerlink" title="关于基本数据类型存放的位置"></a><strong>关于基本数据类型存放的位置</strong></h3><p>取决于基本类型声明的位置：</p><blockquote><p><strong>在方法中声明的变量</strong>，即该变量是局部变量，每当程序调用方法时，系统都会为该方法建立一个方法栈，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，其对应在该方法中声明的变量随着栈的销毁而结束，这就局部变量只能在方法中有效的原因。方法中声明的变量可以是基本类型的变量，也可以是引用类型的变量。<br>（1）当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在方法栈中<br>（2）当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在方法的栈中，该变量所指向的对象是放在堆类存中的。</p></blockquote><blockquote><p><strong>在类中声明的变量</strong>是成员变量，也叫全局变量，放在堆中的（因为全局变量不会随着某个方法执行结束而销毁）。同样在类中声明的变量即可是基本类型的变量 也可是引用类型的变量。<br>（1）当声明的是基本类型的变量其变量名及其值放在堆内存中的<br>（2）引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中</p></blockquote><h3 id="基本类型和封装类型异同"><a href="#基本类型和封装类型异同" class="headerlink" title="基本类型和封装类型异同"></a>基本类型和封装类型异同</h3><blockquote><p>基本类型不是对象</p></blockquote><blockquote><p>声明方式不同：包装类型需要用new。</p></blockquote><blockquote><p>存储方式和存储位置不同</p></blockquote><blockquote><p>初始值不同：boolean初始为false,int为0，而Boolean和Integer都为null。</p></blockquote><blockquote><p>使用方式和场景不同：基本类型数据存储相对简单，运算效率比较高。使用包装类型会牺牲一些转换效率，但可以避免持久化数据时产生的一些异常。同时，集合的元素必须是对象类型，满足了java一切皆是对象的思想。</p></blockquote><blockquote><p>销毁效率不同：基本类型定义的变量创建和销毁很快，而类定义的变量还需要JVM去销毁。</p></blockquote><h2 id="四、类型转换"><a href="#四、类型转换" class="headerlink" title="四、类型转换"></a><font color="red"><strong>四、类型转换</strong></font></h2><h3 id="基本类型之自动类型转换"><a href="#基本类型之自动类型转换" class="headerlink" title="基本类型之自动类型转换"></a>基本类型之自动类型转换</h3><p>注意，只能低精度转向高精度。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> char1 = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> char2 = <span class="string">'b'</span>;</span><br><span class="line"><span class="keyword">int</span> int1 = char1 + <span class="number">1</span>;<span class="comment">//这里即自动类型转换。</span></span><br><span class="line"><span class="keyword">int</span> int2 = char1 +char2;<span class="comment">//这里也完成了自动类型转换。</span></span><br><span class="line"><span class="comment">//char2 = int1;//出错</span></span><br></pre></td></tr></table></figure></p><h3 id="基本类型之强制类型转换"><a href="#基本类型之强制类型转换" class="headerlink" title="基本类型之强制类型转换"></a>基本类型之强制类型转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> char1 = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> char2 = <span class="string">'b'</span>;</span><br><span class="line"><span class="keyword">int</span> int1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> char3 =(<span class="keyword">char</span>)int1;</span><br><span class="line"><span class="keyword">char</span> char4 = (<span class="keyword">char</span>)(char1 + char2);<span class="comment">//这里也完成了强制类型转换。</span></span><br></pre></td></tr></table></figure><h3 id="基本类型→包装类型"><a href="#基本类型→包装类型" class="headerlink" title="基本类型→包装类型"></a>基本类型→包装类型</h3><p>这主要是包括构造方法和装箱操作。<br>还有valauOf()方法。</p><h4 id="（1）拆箱与装箱"><a href="#（1）拆箱与装箱" class="headerlink" title="（1）拆箱与装箱"></a>（1）拆箱与装箱</h4><p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">8</span>;</span><br><span class="line">System.out.println(a == b);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>注意区分拆箱和装箱，以及对象比较：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> int1 = <span class="number">9</span>;</span><br><span class="line">Integer a = <span class="number">9</span>;</span><br><span class="line">Integer c = <span class="keyword">new</span> Integer(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(int1 == c);<span class="comment">//true，比较值</span></span><br><span class="line">System.out.println(a == int1);<span class="comment">//true，比较值</span></span><br><span class="line">System.out.println(a == c);<span class="comment">//false，比较引用</span></span><br></pre></td></tr></table></figure></p><h4 id="（2）构造方法"><a href="#（2）构造方法" class="headerlink" title="（2）构造方法"></a>（2）构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//char</span></span><br><span class="line">Character(<span class="keyword">char</span> value)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//boolean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Boolean</span><span class="params">(<span class="keyword">boolean</span> value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Boolean</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function"><span class="comment">//注意，这个构造方法是输入的字符串是忽略大小写，相见源码：</span></span></span><br><span class="line"><span class="function"><span class="title">return</span> <span class="params">((s != <span class="keyword">null</span>)</span> &amp;&amp; s.<span class="title">equalsIgnoreCase</span><span class="params">(<span class="string">"true"</span>)</span>)</span>;</span><br></pre></td></tr></table></figure><p>其余的Byte、Int、Double、Long、Short都包含两个构造方法，一个传入本身的基本类型，一个传入一个String类型。</p><p>注意，Float包含三个构造函数，除了上述两个，还可以传入double基本类型的值，源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Float</span><span class="params">(<span class="keyword">double</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = (<span class="keyword">float</span>)value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="（3）valueOf-使用上等价于构造方法"><a href="#（3）valueOf-使用上等价于构造方法" class="headerlink" title="（3）valueOf():使用上等价于构造方法"></a>（3）<strong>valueOf()</strong>:使用上等价于构造方法</h4><p><strong>valueOf()</strong>方法等价于构造方法，能用构造方法得到的包装对象也可以用同样的方法通过<strong>valueOf()</strong>得到。<br>valueOf() 方法的实现是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。<br>编译器会在自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</p><h4 id="（4）String-→基本类型的其他方法"><a href="#（4）String-→基本类型的其他方法" class="headerlink" title="（4）String →基本类型的其他方法"></a>（4）String →基本类型的其他方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer to String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s)</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parseInt(s,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s, <span class="keyword">int</span> radix)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> NumberFormatException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * WARNING: This method may be invoked early during VM initialization</span></span><br><span class="line"><span class="comment">         * before IntegerCache is initialized. Care must be taken to not use</span></span><br><span class="line"><span class="comment">         * the valueOf method.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (radix &lt; Character.MIN_RADIX) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"radix "</span> + radix +</span><br><span class="line">                                            <span class="string">" less than Character.MIN_RADIX"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (radix &gt; Character.MAX_RADIX) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"radix "</span> + radix +</span><br><span class="line">                                            <span class="string">" greater than Character.MAX_RADIX"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> negative = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, len = s.length();</span><br><span class="line">        <span class="keyword">int</span> limit = -Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> multmin;</span><br><span class="line">        <span class="keyword">int</span> digit;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> firstChar = s.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (firstChar &lt; <span class="string">'0'</span>) &#123; <span class="comment">// Possible leading "+" or "-"</span></span><br><span class="line">                <span class="keyword">if</span> (firstChar == <span class="string">'-'</span>) &#123;</span><br><span class="line">                    negative = <span class="keyword">true</span>;</span><br><span class="line">                    limit = Integer.MIN_VALUE;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstChar != <span class="string">'+'</span>)</span><br><span class="line">                    <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="comment">// Cannot have lone "+" or "-"</span></span><br><span class="line">                    <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            multmin = limit / radix;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">                <span class="comment">// Accumulating negatively avoids surprises near MAX_VALUE</span></span><br><span class="line">                digit = Character.digit(s.charAt(i++),radix);</span><br><span class="line">                <span class="keyword">if</span> (digit &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (result &lt; multmin) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">                &#125;</span><br><span class="line">                result *= radix;</span><br><span class="line">                <span class="keyword">if</span> (result &lt; limit + digit) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">                &#125;</span><br><span class="line">                result -= digit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> negative ? result : -result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其他类包括了<strong>parseByte(),parseDouble()</strong>等。</p><h3 id="包装类型→基本类型"><a href="#包装类型→基本类型" class="headerlink" title="包装类型→基本类型"></a>包装类型→基本类型</h3><h4 id="（1）包装类型到对应基本类型"><a href="#（1）包装类型到对应基本类型" class="headerlink" title="（1）包装类型到对应基本类型"></a>（1）包装类型到对应基本类型</h4><p>根据继承关系，继承自java.lang.Number的包装类型都包含了Number类的如下公共无参方法，源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">longValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">floatValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">doubleValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">byteValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">byte</span>)intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">shortValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">short</span>)intValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>类似的，对于Charcter类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>对于Boolean类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">booleanValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="（2）包装类型→String类型"><a href="#（2）包装类型→String类型" class="headerlink" title="（2）包装类型→String类型"></a>（2）包装类型→String类型</h4><blockquote><p>除此外，所有的包装类型都可以用<strong>toString()</strong>方法得到字符串类型的对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Character</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[] = &#123;value&#125;;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(buf);<span class="comment">//实际上调用String类的valueOf()方法。</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Boolean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value ? <span class="string">"true"</span> : <span class="string">"false"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Float</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Float.toString(value);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FloatingDecimal.toJavaFormatString(f);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Double</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString(value);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FloatingDecimal.toJavaFormatString(d);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString(value);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//注意看这里，java是如何把int类型的数转换成String的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == Integer.MIN_VALUE)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"-2147483648"</span>;</span><br><span class="line">        <span class="keyword">int</span> size = (i &lt; <span class="number">0</span>) ? stringSize(-i) + <span class="number">1</span> : stringSize(i);<span class="comment">//得到i的字符数</span></span><br><span class="line">        <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[size];<span class="comment">//buf存储字符</span></span><br><span class="line">        getChars(i, size, buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> index, <span class="keyword">char</span>[] buf)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q, r;</span><br><span class="line">        <span class="keyword">int</span> charPos = index;</span><br><span class="line">        <span class="keyword">char</span> sign = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sign = <span class="string">'-'</span>;</span><br><span class="line">            i = -i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate two digits per iteration</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">65536</span>) &#123;</span><br><span class="line">            q = i / <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// really: r = i - (q * 100);</span></span><br><span class="line">            r = i - ((q &lt;&lt; <span class="number">6</span>) + (q &lt;&lt; <span class="number">5</span>) + (q &lt;&lt; <span class="number">2</span>));</span><br><span class="line">            i = q;</span><br><span class="line">            buf [--charPos] = DigitOnes[r];</span><br><span class="line">            buf [--charPos] = DigitTens[r];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fall thru to fast mode for smaller numbers</span></span><br><span class="line">        <span class="comment">// assert(i &lt;= 65536, i);</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            q = (i * <span class="number">52429</span>) &gt;&gt;&gt; (<span class="number">16</span>+<span class="number">3</span>);</span><br><span class="line">            r = i - ((q &lt;&lt; <span class="number">3</span>) + (q &lt;&lt; <span class="number">1</span>));  <span class="comment">// r = i-(q*10) ...</span></span><br><span class="line">            buf [--charPos] = digits [r];</span><br><span class="line">            i = q;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sign != <span class="number">0</span>) &#123;</span><br><span class="line">            buf [--charPos] = sign;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Long，与Integer类似的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString(value);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">long</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == Long.MIN_VALUE)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"-9223372036854775808"</span>;</span><br><span class="line">        <span class="keyword">int</span> size = (i &lt; <span class="number">0</span>) ? stringSize(-i) + <span class="number">1</span> : stringSize(i);</span><br><span class="line">        <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[size];</span><br><span class="line">        getChars(i, size, buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Short</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.toString((<span class="keyword">int</span>)value);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//所以也调用了Integer的这个静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == Integer.MIN_VALUE)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"-2147483648"</span>;</span><br><span class="line">        <span class="keyword">int</span> size = (i &lt; <span class="number">0</span>) ? stringSize(-i) + <span class="number">1</span> : stringSize(i);<span class="comment">//得到i的字符数</span></span><br><span class="line">        <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[size];<span class="comment">//buf存储字符</span></span><br><span class="line">        getChars(i, size, buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Byte</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.toString((<span class="keyword">int</span>)value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>常见的类型转换，以Integer为例：</p><h4 id="int-→-String"><a href="#int-→-String" class="headerlink" title="int → String"></a>int → String</h4><blockquote><p>(1)int后直接+””<br>(2)s = String.valueOf(i);<br>(3)Integer.toString(i);</p></blockquote><h4 id="String→int"><a href="#String→int" class="headerlink" title="String→int"></a>String→int</h4><blockquote><p>(1) i = Integer.parseInt(s);<br>(2) i = Integer.valueOf(s).intValue();<br>(3) i = new Integer(s).intValue();</p></blockquote><h2 id="五、枚举类型"><a href="#五、枚举类型" class="headerlink" title="五、枚举类型"></a>五、枚举类型</h2><p>Java 5.0版本之后引入的除泛型之外的另外一个强大特性：枚举(Enums)。性能远高于静态类。解决一些固定常量集合的问题上枚举成为唯一首选和推荐的一种方式。<br><a href="https://blog.csdn.net/zyhlwzy/article/details/79045066" target="_blank" rel="noopener">枚举类解析</a></p><blockquote><p>enum 不能使用 extends 关键字继承其他类，因为 enum 已经继承了 java.lang.Enum（java是单一继承）。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1551345094255&amp;amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;amp;imgtype=0&amp;amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一文道尽Java数据类型怎么用。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Languages" scheme="https://yoursite.com/categories/Languages/"/>
    
    
      <category term="Java" scheme="https://yoursite.com/tags/Java/"/>
    
      <category term="源码" scheme="https://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="数据类型" scheme="https://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java的艺术-多线程初探(1)</title>
    <link href="https://yoursite.com/2018/10/05/Java%E7%9A%84%E8%89%BA%E6%9C%AF-%E5%A4%9A%E7%BA%BF%E7%A8%8B(1)/"/>
    <id>https://yoursite.com/2018/10/05/Java的艺术-多线程(1)/</id>
    <published>2018-10-05T06:48:20.000Z</published>
    <updated>2019-03-15T15:51:51.615Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551345094255&amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;imgtype=0&amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png" alt="此处输入图片的描述"><br>本文介绍Java中线程、进程、多线程的概念，详细介绍多线程的不同实现方式，从源码分析Callable()接口和Runnable()接口和FutureTask类。<br><a id="more"></a></p><h2 id="一、进程与线程"><a href="#一、进程与线程" class="headerlink" title="一、进程与线程"></a><font color="red">一、进程与线程</font></h2><p><strong>进程（Thread）：</strong>进程指正在运行的程序。当一个程序进入内存运行，即变成一个进程，进程是处于运行过程中的程序，并且具有一定独立功能，包括由操作系统分配的内存空间。<br><strong>线程(Process)：</strong>线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为<strong>多线程程序</strong>。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。<br><strong>线程池(Thread Pool):</strong>基本思想是一种对象池的思想，开辟一块内存空间，里面存放了众多(未死亡)的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省系统资源。<br><strong>并行（Parallen）与并发(Concurrent)：</strong><br>并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。<br>并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。<br><strong>并发不一定是并行的，并行一定是并发的。</strong></p><blockquote><p>如果某个系统支持两个或者多个动作（Action）同时存在，那么这个系统就是一个并发系统。如果某个系统支持两个或者多个动作同时执行，那么这个系统就是一个并行系统。并发系统与并行系统这两个定义之间的关键差异在于“存在”这个词。<br>在并发程序中可以同时拥有两个或者多个线程。这意味着，如果程序在单核处理器上运行，那么这两个线程将交替地换入或者换出内存。这些线程是同时“存在”的——每个线程都处于执行过程中的某个状态。如果程序能够并行执行，那么就一定是运行在多核处理器上。此时，程序中的每个线程都将分配到一个独立的处理器核上，因此可以同时运行。<br>“并行”概念是“并发”概念的一个子集。也就是说，你可以编写一个拥有多个线程或者进程的并发程序，但如果没有多核处理器来执行这个程序，那么就不能以并行方式来运行代码。因此，凡是在求解单个问题时涉及多个执行流程的编程模式或者执行行为，都属于并发编程的范畴。</p></blockquote><p><strong>其他概念：</strong></p><ul><li>线程同步（synchronized）</li><li>线程间通信</li><li>线程死锁</li><li>线程控制：挂起、停止和恢复</li></ul><blockquote><p>问题：Java程序运行至少启动几个线程？<br>至少启动两个线程，每当使用 Java 命令执行一个类时，实际上都会启动一个 JVM，每一个JVM实际上就是在操作系统中启动一个线程，Java 本身具备了垃圾的收集机制。所以在 Java 运行时至少会启动两个线程，一个是 main 线程，另外一个是垃圾收集线程。</p></blockquote><h2 id="二、线程的生命周期"><a href="#二、线程的生命周期" class="headerlink" title="二、线程的生命周期"></a><a href="http://www.runoob.com/java/java-multithreading.html" target="_blank" rel="noopener"><font color="red">二、线程的生命周期</font></a></h2><p><strong>新建状态:</strong><br>使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。</p><p><strong>就绪状态:</strong><br>当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</p><p><strong>运行状态:</strong><br>如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p><p><strong>阻塞状态:</strong><br>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：</p><p>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</p><p>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</p><p>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。</p><p><strong>死亡状态:</strong><br>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。<br><img src="https://upload-images.jianshu.io/upload_images/1689841-383f7101e6588094.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt="此处输入图片的描述"></p><p>线程在Running的过程中可能会遇到阻塞(Blocked)情况：</p><ul><li>调用join()和sleep()方法，sleep()时间结束或被打断，join()中断,IO完成都会回到Runnable状态，等待JVM的调度。</li><li>调用wait()，使该线程处于等待池(wait blocked pool),直到notify()/notifyAll()，线程被唤醒被放到锁定池(lock blocked pool )，释放同步锁使线程回到可运行状态（Runnable）</li><li>对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。<br>此外，在runnable状态的线程是处于被调度的线程，此时的调度顺序是不一定的。Thread类中的yield方法可以让一个running状态的线程转入runnable。</li></ul><h2 id="二、线程的优先级"><a href="#二、线程的优先级" class="headerlink" title="二、线程的优先级"></a><font color="red">二、线程的优先级</font></h2><p>每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。</p><p>Java 线程的优先级是一个整数，其取值范围是 <strong>1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）</strong>。</p><p>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</p><p>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。</p><h2 id="四、线程的实现"><a href="#四、线程的实现" class="headerlink" title="四、线程的实现"></a><font color="red">四、线程的实现</font></h2><p>Java提供了三种创建线程的方法：</p><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><ul><li>声明实现 Runnable 接口的类。该类然后实现 run 方法。然后创建Runnable的子类对象，传入到某个线程的构造方法中，开启线程。</li><li>将线程的任务从线程的子类中分离出来，进行了单独的封装。按照面向对象的思想将任务的封装成对象。</li><li>避免了java单继承的局限性。<br><strong>步骤：</strong></li></ul><p>1、定义类实现Runnable接口。<br>2、覆盖接口中的run方法。。<br>3、创建Thread类的对象<br>4、将Runnable接口的子类对象作为参数传递给Thread类的构造函数。<br>5、调用Thread类的start方法开启线程。</p><p><strong>示例：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyThread2</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.num = num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i + num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="继承Thread类本身"><a href="#继承Thread类本身" class="headerlink" title="继承Thread类本身"></a>继承Thread类本身</h3><p>Thread是程序中的执行线程。Java 虚拟机允许应用程序并发地运行多个执行线程。<br>继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。<br>该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。<br><strong>步骤：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.定义一个类继承Thread。</span><br><span class="line">2.重写run方法。</span><br><span class="line">3.创建子类对象，就是创建线程对象。</span><br><span class="line">4.调用start方法，开启线程并让线程执行，同时还会告诉jvm去调用run方法</span><br></pre></td></tr></table></figure></p><p><strong>示例：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">":"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建线程实例</span></span><br><span class="line">MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line"><span class="comment">//修改线程名字</span></span><br><span class="line">mt.setName(<span class="string">"thread1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">mt.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程实例</span></span><br><span class="line">MyThread mt2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">mt2.setName(<span class="string">"thread2"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">mt2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="通过Callabel和Future创建线程（不常用）"><a href="#通过Callabel和Future创建线程（不常用）" class="headerlink" title="通过Callabel和Future创建线程（不常用）"></a>通过Callabel和Future创建线程（不常用）</h3><p><strong>步骤：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。</span><br><span class="line">2. 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。</span><br><span class="line">3. 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</span><br><span class="line">4. 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。</span><br></pre></td></tr></table></figure></p><p><strong>示例：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableThreadTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        CallableThreadTest ctt = <span class="keyword">new</span> CallableThreadTest();  <span class="comment">//创建Callable实现类的实例</span></span><br><span class="line">        FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(ctt);  <span class="comment">//用FutureTask类包装Callble对象，FutureTask对象封装了Callable对象call方法的返回值，因为它实现了Future()接口。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" 的循环变量i的值"</span>+i);  </span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">20</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">new</span> Thread(ft,<span class="string">"有返回值的线程"</span>).start();  <span class="comment">//使用FutureTask对象作为Thread对象的target创建并启动新线程</span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">try</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            System.out.println(<span class="string">"子线程的返回值："</span>+ft.get());  <span class="comment">//使用FutureTask的get方法来获得子线程结束后的返回值。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)  </span><br><span class="line">        &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e)  </span><br><span class="line">        &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception  <span class="comment">//线程执行体，有返回值</span></span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> i;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="三种方式对比"><a href="#三种方式对比" class="headerlink" title="三种方式对比"></a>三种方式对比</h3><ol><li><p>采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</p></li><li><p>使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</p></li><li><p>相比于Callable接口，另外两种方式的run()方法没有返回值，而Callable接口的call()方法有返回值，并且可用FutureTask对象捕获。</p></li><li><p>call() 方法可以抛出异常，run()方法不可以的。</p></li></ol><h3 id="Thread的run-和start-方法的区别"><a href="#Thread的run-和start-方法的区别" class="headerlink" title="Thread的run()和start()方法的区别"></a>Thread的run()和start()方法的区别</h3><p>start()：该方法是在当前线程中启动一个新的线程，而新启动的线程会调用run()方法，同时该方法不能重复调用；<br>run()  ：该方法和普通的方法一样，可以重复执行，不会创建新的线程。</p><h2 id="五、终止线程"><a href="#五、终止线程" class="headerlink" title="五、终止线程"></a>五、终止线程</h2><p>1、当run方法执行完毕，自动终止；</p><p>2、使用stop方法，不过这个方法不推荐使用，会有意料不到的后果；</p><p>3、使用interrupt方法</p><h2 id="六、源码解析"><a href="#六、源码解析" class="headerlink" title="六、源码解析"></a>六、<strong>源码解析</strong></h2><h3 id="Runnable-和-Callable-接口的源码"><a href="#Runnable-和-Callable-接口的源码" class="headerlink" title="Runnable 和 Callable 接口的源码"></a>Runnable 和 Callable 接口的源码</h3><p>从源码看返回值的差别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FutureTask类源码"><a href="#FutureTask类源码" class="headerlink" title="FutureTask类源码"></a>FutureTask类源码</h3><p>FutureTask用来包装实现了Callable接口的类，创建有返回值的多线程。<br>FutureTask的继承关系如下：</p><ul><li>FutureTask<ul><li>RunnableFuture(parent_Interface)</li><li>Runnable(granparent_Interface)</li><li>Future(granparent_Interface)</li></ul></li></ul><p>来看Future的源码，主要定义了5种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">//取消该线程</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//如有必要，等待计算完成，然后获取其结果。</span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//等待一段时间后获取结果</span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>FutureTask 实现了 Runnable 和 Future，所以兼顾两者优点，既可以在 Thread 中使用，又可以在 ExecutorService [这个后面再写篇博客总结一下]中使用。</p></blockquote><pre><code>ExecutorService是Java提供的线程池。需要使用线程的时候，可以通过ExecutorService获得线程。它可以有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞，同时提供定时执行、定期执行、单线程、并发数控制等功能，比TimerTask更好。</code></pre><blockquote><p>FutureTask 是为了弥补 Thread 的不足而设计的，它可以让程序员准确地知道线程什么时候执行完成并获得到线程执行完成后返回的结果。</p></blockquote><blockquote><p>FutureTask 是一种可以取消的异步的计算任务，它的计算是通过 Callable 实现的，它等价于可以携带结果的 Runnable，并且有三个状态：等待、运行和完成。完成包括所有计算以任意的方式结束，包括正常结束、取消和异常。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1551345094255&amp;amp;di=7757ebd7ca42b6b8acc5a3432680f30c&amp;amp;imgtype=0&amp;amp;src=http://p0.qhimg.com/t0174dfc0ed2d451c38.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;本文介绍Java中线程、进程、多线程的概念，详细介绍多线程的不同实现方式，从源码分析Callable()接口和Runnable()接口和FutureTask类。&lt;br&gt;
    
    </summary>
    
      <category term="Languages" scheme="https://yoursite.com/categories/Languages/"/>
    
    
      <category term="Java" scheme="https://yoursite.com/tags/Java/"/>
    
      <category term="源码" scheme="https://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="多线程" scheme="https://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据库(2)-SQL其他须知</title>
    <link href="https://yoursite.com/2018/09/07/%E6%95%B0%E6%8D%AE%E5%BA%93(2)-MySQL%E9%AB%98%E7%BA%A7/"/>
    <id>https://yoursite.com/2018/09/07/数据库(2)-MySQL高级/</id>
    <published>2018-09-07T08:48:20.000Z</published>
    <updated>2019-03-17T03:49:37.374Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/03/14/AAvGd0.jpg" alt="此处输入图片的描述"><br>MySQL特性，多表查询与<code>SQL注入</code>的介绍。</p><a id="more"></a><h2 id="一、MySQL正则表达式"><a href="#一、MySQL正则表达式" class="headerlink" title="一、MySQL正则表达式"></a>一、MySQL正则表达式</h2><blockquote><p>在<a href="https://wufan.site/2018/08/05/%E6%95%B0%E6%8D%AE%E5%BA%93%281%29-SQL%E5%88%9D%E8%AF%86/" target="_blank" rel="noopener">数据库(1)-SQL初识</a>中介绍了SQL基础语句。MySQL可以通过 LIKE 来进行模糊匹配。</p></blockquote><blockquote><p>同时，MySQL也支持使用 REGEXP 操作符来进行正则表达式匹配。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查找name字段中以'st'为开头的所有数据：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> tabel_name <span class="keyword">WHERE</span> <span class="keyword">name</span> REGEXP <span class="string">'^st'</span>;</span><br></pre></td></tr></table></figure><h2 id="二、MySQL事务"><a href="#二、MySQL事务" class="headerlink" title="二、MySQL事务"></a>二、MySQL事务</h2><blockquote><p><strong>MySQL 事务</strong>主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务。</p></blockquote><blockquote><p>事务是必须满足4个条件（ACID）：<strong>原子性</strong>（Atomicity，或称不可分割性）、<strong>一致性</strong>（Consistency）、<strong>隔离性</strong>（Isolation，又称独立性）、<strong>持久性</strong>（Durability）。</p></blockquote><ul><li><p>原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p></li><li><p>一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p></li><li><p>隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p></li><li><p>持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p></li></ul><blockquote><p>MYSQL 事务处理主要有两种方法：</p></blockquote><ul><li><p>1、用 BEGIN, ROLLBACK, COMMIT来实现</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> 开始一个事务</span><br><span class="line"><span class="keyword">ROLLBACK</span> 事务回滚</span><br><span class="line"><span class="keyword">COMMIT</span> 事务确认</span><br></pre></td></tr></table></figure></li><li><p>2、直接用 SET 来改变 MySQL 的自动提交模式:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> AUTOCOMMIT=<span class="number">0</span> 禁止自动提交</span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT=<span class="number">1</span> 开启自动提交</span><br></pre></td></tr></table></figure></li></ul><h2 id="三、导入导出数据"><a href="#三、导入导出数据" class="headerlink" title="三、导入导出数据"></a>三、导入导出数据</h2><h3 id="（1）导出数据"><a href="#（1）导出数据" class="headerlink" title="（1）导出数据"></a>（1）导出数据</h3><blockquote><p>使用 SELECT … INTO OUTFILE 语句导出数据<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">INTO</span> <span class="keyword">OUTFILE</span> <span class="string">'test.txt'</span>;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="（2）导入数据"><a href="#（2）导入数据" class="headerlink" title="（2）导入数据"></a>（2）导入数据</h3><blockquote><p>A.mysql 命令导入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u用户名 -p密码 &lt; in_database.sql</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>B.source 命令导入<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /path/in_database.sql</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>C.使用 LOAD DATA 导入数据<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">LOCAL</span> <span class="keyword">INFILE</span> <span class="string">'database.txt'</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> mytbl;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>D.使用 mysqlimport 导入数据<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlimport -u root -p <span class="comment">--local database_name database.txt</span></span><br></pre></td></tr></table></figure></p></blockquote><h2 id="四、多表查询"><a href="#四、多表查询" class="headerlink" title="四、多表查询"></a>四、<strong>多表查询</strong></h2><p>多表查询需要用到各种连接查询，包括内连接和外链接。</p><h3 id="1-多表的建表原则"><a href="#1-多表的建表原则" class="headerlink" title="(1)多表的建表原则"></a>(1)多表的建表原则</h3><blockquote><p>在事务性数据库中，table一般有三种关系：1 to 1, n to m, 1 to n。</p></blockquote><p>（a）<strong>1 to 1</strong></p><ul><li>当作是一对多情况，在任意一张表添加一个唯一外键,指向另外一张表。</li><li>直接将两张表合并成一张表</li></ul><p>（b）<strong>n to m</strong></p><ul><li>建立一张中间表,将多对多的关系,拆分成一对多的关系,中间表至少要有两个外键,分别指向原来的那两张表</li></ul><p>（c）<strong>1 to n</strong></p><ul><li>在多的一方添加一个外键,指向一的一方的主键</li></ul><h3 id="2-内连接"><a href="#2-内连接" class="headerlink" title="(2)内连接"></a>(2)内连接</h3><blockquote><p>隐式内连接<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> atable a,btable b</span><br><span class="line"><span class="keyword">WHERE</span> a.col1=b.col2;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>显式内连接<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> atable a <span class="keyword">INNER</span> <span class="keyword">JOIN</span> btable b</span><br><span class="line"><span class="keyword">ON</span> a.col1=b.col2;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>区别<br>    隐式内连接: 在查询出结果的基础上去做的WHERE条件过滤<br>    显示内连接: 带着条件去查询结果, 执行效率要高</p></blockquote><h3 id="3-外连接"><a href="#3-外连接" class="headerlink" title="(3)外连接"></a>(3)外连接</h3><p>外连接可分为：左连接、右连接、完全外连接、交叉连接。</p><blockquote><p>左连接:<code>left join</code> 或<code>left outer join</code>.<br>左外连接包含join左表所有行，如果左表中某行在右表没有匹配，则结果中对应行右表的部分全部为空(NULL).</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> a_table <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> b_table</span><br><span class="line"><span class="keyword">ON</span> a.col1=b.col2;</span><br></pre></td></tr></table></figure><blockquote><p>右连接: <code>right join</code>或<code>right outer join</code><br>右外连接包含right join右表所有行，如果左表中某行在右表没有匹配，则结果中对应左表的部分全部为空(NULL)。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> a_table <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> b_table</span><br><span class="line"><span class="keyword">ON</span> a.col1=b.col2;</span><br></pre></td></tr></table></figure><blockquote><p>完全外连接 <code>full join</code> 或 <code>full outer join</code>.<br>完全外连接包含full join左右两表中所有的行，如果右表中某行在左表中没有匹配，则结果中对应行右表的部分全部为空(NULL)，如果左表中某行在右表中没有匹配，则结果中对应行左表的部分全部为空(NULL)。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> a_table <span class="keyword">FULL</span> <span class="keyword">JOIN</span> b_table</span><br><span class="line"><span class="keyword">ON</span> a.col1=b.col2;</span><br></pre></td></tr></table></figure><font color="red">注意：<strong>内外连接中INNER、OUTER都可以省略</strong></font><h3 id="4-交叉连接"><a href="#4-交叉连接" class="headerlink" title="(4)交叉连接"></a>(4)交叉连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--cross join</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> a_table <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> b_table</span><br></pre></td></tr></table></figure><p>等效于<code>笛卡尔积</code>：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> a_tabl,b_table;</span><br></pre></td></tr></table></figure></p><p>如果加上条件，ON a.col1=b.col2，则效果等价于INNER JOIN.</p><h2 id="五、SQL注入"><a href="#五、SQL注入" class="headerlink" title="五、SQL注入"></a>五、<strong>SQL注入</strong></h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p><strong>SQL注入</strong>是未经授权的人可以访问各种关键和私人数据的漏洞。在SQL注入中，攻击者使用各种命令与DB服务器交互，并从中获取各种数据。SQL注入不是Web或数据库服务器中的缺陷，而是由于编程实践较差且缺乏经验而导致的。它是从远程位置执行的最致命和最容易的攻击之一。</p></blockquote><h3 id="常见SQL注入"><a href="#常见SQL注入" class="headerlink" title="常见SQL注入"></a>常见SQL注入</h3><h4 id="（1）绕过登陆"><a href="#（1）绕过登陆" class="headerlink" title="（1）绕过登陆"></a>（1）绕过登陆</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span> <span class="keyword">from</span> <span class="keyword">database</span> <span class="keyword">WHERE</span> username =<span class="string">'admin'</span> <span class="keyword">AND</span> <span class="keyword">password</span> =<span class="string">'admin'</span></span><br></pre></td></tr></table></figure><p>username和password字段为用户在登陆表单的输入，若服务器将这个命令评估为True，则将授予用户访问权限。</p><p>攻击者可以在登录表单中输入以下用户数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username:a or 1=1--</span><br><span class="line">password:blank</span><br></pre></td></tr></table></figure></p><p>查询变为了：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span> <span class="keyword">from</span> <span class="keyword">database</span></span><br><span class="line"><span class="keyword">WHERE</span> username=<span class="string">'a'</span> <span class="keyword">or</span> <span class="number">1</span>=<span class="number">1</span></span><br><span class="line"><span class="comment">-- AND password=''</span></span><br></pre></td></tr></table></figure></p><p>这条语句始终为True，因此用户可以访问该数据库。</p><h4 id="（2）获得数据库中隐私数据"><a href="#（2）获得数据库中隐私数据" class="headerlink" title="（2）获得数据库中隐私数据"></a>（2）获得数据库中隐私数据</h4><p>对于一个页面：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site.com/article.php?id=50</span><br></pre></td></tr></table></figure></p><p>网站后台如果没有经过过滤，可能包含这样的SQL查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * from [表名] where id=50</span><br></pre></td></tr></table></figure></p><p>如果我们将URL修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site.com/article.php?id=5+UPDATE+article+SET+title=&apos;Hacked&apos;</span><br></pre></td></tr></table></figure></p><p>则SQL变成了<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> [表名] <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">50</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> article <span class="keyword">SET</span> title=<span class="string">'Hacked'</span>;</span><br></pre></td></tr></table></figure></p><p>甚至可以改为：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site.com/article.php?id=5+SHUTDOWN+WITH+NOWAIT;</span><br></pre></td></tr></table></figure></p><p>从而关闭服务器。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ul><li>1).永远不要信任用户的输入。对用户的输入进行<code>校验</code>，可以通过正则表达式，或限制长度；对单引号和 双”-“进行转换等。</li><li>2).永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。</li><li>3).永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。</li><li>4).不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。</li><li>5).应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装</li><li>6).sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky，网站平台就有亿思网站安全平台检测工具。MDCSOFT SCAN等。采用MDCSOFT-IPS可以有效的防御SQL注入，XSS攻击等。</li></ul><hr><p><strong>参考资料：</strong><br><a href="http://www.runoob.com/mysql/mysql-transaction.html" target="_blank" rel="noopener">史上最完整的MySQL注入</a><br><a href="http://www.runoob.com/mysql/mysql-transaction.html" target="_blank" rel="noopener">MySQL 事务</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/03/14/AAvGd0.jpg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;MySQL特性，多表查询与&lt;code&gt;SQL注入&lt;/code&gt;的介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="Database" scheme="https://yoursite.com/categories/Database/"/>
    
    
      <category term="数据库" scheme="https://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>数据库(1)-SQL初识</title>
    <link href="https://yoursite.com/2018/08/05/%E6%95%B0%E6%8D%AE%E5%BA%93(1)-SQL%E5%88%9D%E8%AF%86/"/>
    <id>https://yoursite.com/2018/08/05/数据库(1)-SQL初识/</id>
    <published>2018-08-05T02:48:20.000Z</published>
    <updated>2019-03-17T02:21:20.421Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/03/14/AAvGd0.jpg" alt="此处输入图片的描述"><br>SQL语法总结。增、删、改、查，与内建函数。<br><a id="more"></a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>SQL:Structure Query Langeage 结构化查询语言</strong></p><blockquote><p>DDL：数据定义，定义数据库、数据表结构，<strong>create,drop,alter,show</strong><br>DML：数据操纵，用来操作数据，<strong>insert,update,delete</strong><br>DCL：数据控制，访问权限和安全，<strong>grant</strong><br>DQL：数据查询<strong>，select,from,where…</strong></p></blockquote><h2 id="0-用户操作"><a href="#0-用户操作" class="headerlink" title="(0)用户操作"></a>(0)用户操作</h2><blockquote><p>用户权限相关数据保存在mysql数据库的user表中，所以也可以直接对其进行操作</p></blockquote><blockquote><p>创建用户<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">'用户名'</span>@<span class="string">'IP地址'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'密码'</span>;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>删除用户<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> <span class="string">'用户名'</span>@<span class="string">'IP地址'</span>;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>修改用户<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rename</span> <span class="keyword">user</span> <span class="string">'用户名'</span>@<span class="string">'IP地址'</span>; to '新用户名'@'IP地址';;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>修改密码<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">password</span> <span class="keyword">for</span> <span class="string">'用户名'</span>@<span class="string">'IP地址'</span> = <span class="keyword">Password</span>(<span class="string">'新密码'</span>)</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>用户权限设置<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--授权</span></span><br><span class="line"><span class="keyword">grant</span> all <span class="keyword">privileges</span> <span class="keyword">on</span> db1.tb1 <span class="keyword">TO</span> <span class="string">'用户名'</span>@<span class="string">'IP'</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> db1.* <span class="keyword">TO</span> <span class="string">'用户名'</span>@<span class="string">'IP'</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>,<span class="keyword">insert</span> <span class="keyword">on</span> *.* <span class="keyword">TO</span> <span class="string">'用户名'</span>@<span class="string">'IP'</span></span><br><span class="line"><span class="comment">--取消</span></span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">select</span> <span class="keyword">on</span> db1.tb1 <span class="keyword">from</span> <span class="string">'用户名'</span>@<span class="string">'IP'</span></span><br></pre></td></tr></table></figure></p></blockquote><h2 id="1-数据库操作"><a href="#1-数据库操作" class="headerlink" title="(1)数据库操作"></a>(1)数据库操作</h2><blockquote><p><a href="https://www.cnblogs.com/ayyl/p/5978418.html" target="_blank" rel="noopener">安装教程</a></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">初始化后第一次使用数据库要修改密码：</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">'root'</span>@<span class="string">'localhost'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'新密码'</span>;</span><br><span class="line">exit;（退出mysql）</span><br></pre></td></tr></table></figure><blockquote><p>创建数据库</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">name</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">name</span> <span class="built_in">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">name</span> <span class="built_in">character</span> <span class="keyword">set</span> utf8 <span class="keyword">collate</span> utf8_bin;</span><br></pre></td></tr></table></figure><blockquote><p>查看数据库</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查看所有数据库</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line"><span class="comment">--查看数据库的定义</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><blockquote><p>修改数据库</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--修改字符集</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">name</span> <span class="built_in">character</span> <span class="keyword">set</span> 字符集;</span><br></pre></td></tr></table></figure><blockquote><p>删除数据库</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><blockquote><p>切换数据库</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><blockquote><p>查看当前数据库</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">database</span>();</span><br></pre></td></tr></table></figure><h2 id="2-表的操作"><a href="#2-表的操作" class="headerlink" title="(2)表的操作"></a>(2)表的操作</h2><font color="red"><strong>create, drop, alter, show</strong></font><blockquote><p>创建</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> tabel tabel_name(</span><br><span class="line">    列名  列的类型(长度)  约束,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建表的索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_name</span><br><span class="line"><span class="keyword">ON</span> table_name (column_name <span class="keyword">DESC</span>)</span><br></pre></td></tr></table></figure><p><strong>数据类型有：</strong></p><ul><li>int</li><li>byte</li><li>char</li><li>varchar</li><li>double</li><li>float</li><li>boolean</li><li>date: YYYY-MM-DD</li><li>time: hh:mm:ss</li><li>datetime: YYYY-MM-DD hh:mm:ss(默认null)</li><li>timestamp: YYYY-MM-DD hh:mm:ss(默认当前时间)</li><li>text  文本-memo(大数量文本)</li><li>blob  二进制</li></ul><p><strong>约束有：</strong></p><ul><li>primary key</li><li>unique</li><li>not null</li><li>foreign key</li><li>check</li><li>default</li><li>AUTO_INCREMENT:每次插入新记录时，自动地创建主键字段的值。</li></ul><blockquote><p>查看</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查看所有表</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line"><span class="comment">--查看指定表</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">name</span>;</span><br><span class="line"><span class="comment">--查看表结构</span></span><br><span class="line">desc name;</span><br></pre></td></tr></table></figure><blockquote><p>修改表</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--修改表名字</span></span><br><span class="line"><span class="keyword">rename</span> <span class="keyword">table</span> table_name <span class="keyword">to</span> new_name;</span><br><span class="line"><span class="comment">--添加列col</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> col_name <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">--修改列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">modify</span> 属性 <span class="built_in">char</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">-- 修改列名</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">change</span> old_name new_name <span class="built_in">int</span> notnull;</span><br><span class="line"><span class="comment">--删除列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">drop</span> col_name;</span><br></pre></td></tr></table></figure><p>##（3）表数据的CRUD操作</p><font color="red"><strong>insert, delete, update, select</strong></font><blockquote><p>插入数据<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name <span class="keyword">values</span>(value1,value2,value3);</span><br><span class="line"><span class="comment">--当只插入部分字段时,列名不能省略</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name(col1,col2) <span class="keyword">values</span>(value1,value2);</span><br><span class="line"><span class="comment">--批量插入</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name <span class="keyword">values</span></span><br><span class="line">(value1,value2,value3),</span><br><span class="line">(value4,value5,value6),</span><br><span class="line">(value7,value8,value9);</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>删除记录<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table_name [<span class="keyword">where</span>]；</span><br><span class="line"><span class="comment">--同时，truncate也可以删除表，但是和delete有区别。</span></span><br><span class="line">//<span class="keyword">delete</span>:DML 一条一条删除数据；(适合删除数据少)</span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> 表名;</span><br><span class="line">//<span class="keyword">truncate</span>：<span class="keyword">DDL</span> 先删除表再重建表。(适合删除数据多)</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>修改记录<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> table_name <span class="keyword">set</span> col_name = new_value[<span class="keyword">where</span> ] ;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>查询<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">distinct  去重</span><br><span class="line">AND &amp; OR  条件</span><br><span class="line">Order by (Desc &amp; Asc)  排序</span><br><span class="line">Top   查询个数</span><br><span class="line">Like+通配符 模糊查询</span><br><span class="line">In (1，2，3) 范围匹配</span><br><span class="line">Aliases，即as   别名，可省略</span><br><span class="line">Between</span><br><span class="line">Union：合并两个或多个 <span class="keyword">SELECT</span> 语句的结果集。<span class="keyword">Union</span> ALL允许重复。</span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">into</span>：从一个表中选取数据，然后把数据插入另一个表中。</span><br><span class="line"></span><br><span class="line"><span class="keyword">View</span>:基于 <span class="keyword">SQL</span> 语句的结果集的可视化的表。</span><br><span class="line"></span><br><span class="line"><span class="keyword">Nulls</span></span><br><span class="line"><span class="keyword">isnull</span>()</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`sql</span></span><br><span class="line"><span class="string">[**Join：引用多个表**][1]</span></span><br><span class="line"><span class="string">&gt;JOIN: 如果表中有至少一个匹配，则返回行</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">sql</span></span><br><span class="line"><span class="keyword">select</span> column_name(s)</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">table</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="keyword">table</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">ON</span></span><br><span class="line"><span class="keyword">table</span> <span class="number">1.</span>column_name=<span class="keyword">table</span> <span class="number">2.</span>column_name</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name(s)</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">table</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="keyword">table</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">table</span> <span class="number">1.</span>column_name=<span class="keyword">table</span> <span class="number">2.</span>column_name</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行.</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name(s)</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">table</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> <span class="keyword">table</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">table</span> <span class="number">1.</span>column_name=<span class="keyword">table</span> <span class="number">2.</span>column_name</span><br></pre></td></tr></table></figure><blockquote><p>FULL OUTER JOIN: 会从左表和右表那里返回所有的行。如果其中一个表的数据行在另一个表中没有匹配的行，那么对面的数据用NULL代替</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name(s)</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">table</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> <span class="keyword">table</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">table</span> <span class="number">1.</span>column_name=<span class="keyword">table</span> <span class="number">2.</span>column_name</span><br></pre></td></tr></table></figure><h2 id="（4）函数"><a href="#（4）函数" class="headerlink" title="（4）函数"></a>（4）函数</h2><p>用法：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">function</span>(列) <span class="keyword">FROM</span> 表</span><br></pre></td></tr></table></figure></p><p>包括：</p><ul><li>avg()</li><li>count()</li><li>first()</li><li>last()</li><li>max()</li><li>min()</li><li>sum()</li><li>group by 分组</li><li>having条件过滤[后面可以接聚合函数]</li><li>ucase():把字段的值转换为大写。</li><li>lcase():把字段的值转换为小写。</li><li><p>mid():用于从文本字段中提取字符。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们使用如下 SQL 语句从 "City" 列中提取前 3 个字符。</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MID</span>(City,<span class="number">1</span>,<span class="number">3</span>) <span class="keyword">as</span> SmallCity <span class="keyword">FROM</span> Persons</span><br></pre></td></tr></table></figure></li><li><p>len()</p></li><li>round()：ROUND 函数用于把数值字段舍入为指定的小数位数。</li><li><p>now()：NOW 函数返回当前的日期和时间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ProductName, UnitPrice, <span class="keyword">Now</span>() <span class="keyword">as</span> PerDate <span class="keyword">FROM</span> Products</span><br></pre></td></tr></table></figure></li><li><p>format():FORMAT 函数用于对字段的显示进行格式化。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ProductName, UnitPrice, <span class="keyword">FORMAT</span>(<span class="keyword">Now</span>(),<span class="string">'YYYY-MM-DD'</span>) <span class="keyword">as</span> PerDate</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>参考链接：</strong><br><a href="http://www.w3school.com.cn/sql/sql_quickref.asp" target="_blank" rel="noopener">SQL 快速参考</a><br><a href="https://shockerli.net/post/1000-line-mysql-note/" target="_blank" rel="noopener">一千行MySQL学习笔记</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/03/14/AAvGd0.jpg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;SQL语法总结。增、删、改、查，与内建函数。&lt;br&gt;
    
    </summary>
    
      <category term="Database" scheme="https://yoursite.com/categories/Database/"/>
    
    
      <category term="数据库" scheme="https://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>CUDA安装问题解决</title>
    <link href="https://yoursite.com/2018/07/29/CUDA%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>https://yoursite.com/2018/07/29/CUDA安装问题解决/</id>
    <published>2018-07-29T06:38:20.000Z</published>
    <updated>2018-12-27T03:33:38.367Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>CUDA安装失败问题解决。</p><p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRkXxUeuvvVGryPwRjR_fSlc7YHFVRj7oq-475WcJFVBQ2zZII6" alt="此处输入图片的描述"><br><a id="more"></a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>CUDA安装失败都是由于其中Visual Studio(VS) Intergration无法安装导致：</li></ul><p><img src="https://s1.ax1x.com/2018/12/27/F2XPTx.png" alt="此处输入图片的描述"></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul><li>择自定义安装，并不要安装VS组件：</li></ul><p><img src="https://s1.ax1x.com/2018/12/27/F2XFk6.png" alt="此处输入图片的描述"></p><ul><li><p>将<strong>“CUDAVisualStudioIntegration\extras\visual_studio_integration\MSBuildExtensions”</strong>下的文件直接拷贝到<strong>“C:\Program Files (x86)\MSBuild\Microsoft.Cpp\v4.0\V140\BuildCustomizations”</strong>文件夹中。<br> <strong>“CUDAVisualStudioIntegration”</strong>这个可以在默认文件：<strong>“C:\Users\用户名\AppData\Local\Temp\CUDA”</strong>下找到，但是如果你把NVIDIA安装程序关闭了，那么这个默认文件就会消失的，所以可以等NVIDIA安装程序将数据解压完毕后再去找，肯定能找到。</p></li><li><p>复制解压后的cudnn文件到cuda对应目录下即可。最后验证安装成功：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\wufan&gt;nvcc -V</span><br><span class="line">nvcc: NVIDIA (R) Cuda compiler driver</span><br><span class="line">Copyright (c) 2005-2017 NVIDIA Corporation</span><br><span class="line">Built on Fri_Sep__1_21:08:32_Central_Daylight_Time_2017</span><br><span class="line">Cuda compilation tools, release 9.0, V9.0.176</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;CUDA安装失败问题解决。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRkXxUeuvvVGryPwRjR_fSlc7YHFVRj7oq-475WcJFVBQ2zZII6&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Tools" scheme="https://yoursite.com/categories/Tools/"/>
    
    
      <category term="cuda" scheme="https://yoursite.com/tags/cuda/"/>
    
  </entry>
  
  <entry>
    <title>Linux之路</title>
    <link href="https://yoursite.com/2018/07/22/Linux%E4%B9%8B%E8%B7%AF/"/>
    <id>https://yoursite.com/2018/07/22/Linux之路/</id>
    <published>2018-07-22T06:38:00.000Z</published>
    <updated>2019-02-21T13:15:03.747Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>记录使用Linux遇到的问题与解决办法。</p><p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRkXxUeuvvVGryPwRjR_fSlc7YHFVRj7oq-475WcJFVBQ2zZII6" alt="此处输入图片的描述"><br><a id="more"></a></p><h2 id="无法解析或打开软件包的列表或是状态文件问题的解决方案"><a href="#无法解析或打开软件包的列表或是状态文件问题的解决方案" class="headerlink" title="无法解析或打开软件包的列表或是状态文件问题的解决方案"></a>无法解析或打开软件包的列表或是状态文件问题的解决方案</h2><p>在通过sudo apt-get install安装软件的时候，可能会出现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">正在读取软件包列表... 有错误！</span><br><span class="line">E: Encountered a section with no Package: header</span><br><span class="line">E: Problem with MergeList /var/lib/apt/lists/??</span><br><span class="line">E: 无法解析或打开软件包的列表或是状态文件。</span><br></pre></td></tr></table></figure></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>执行下面两条语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /var/lib/apt/lists/* -vf #删掉apt下的lists文件下的内容</span><br><span class="line">sudo apt-get update # 更新软件源</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;记录使用Linux遇到的问题与解决办法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRkXxUeuvvVGryPwRjR_fSlc7YHFVRj7oq-475WcJFVBQ2zZII6&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Operating Systems" scheme="https://yoursite.com/categories/Operating-Systems/"/>
    
    
      <category term="linux" scheme="https://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>JupyterNotebook教程</title>
    <link href="https://yoursite.com/2018/07/15/JupyterNotebook%E6%95%99%E7%A8%8B/"/>
    <id>https://yoursite.com/2018/07/15/JupyterNotebook教程/</id>
    <published>2018-07-15T05:40:42.000Z</published>
    <updated>2018-12-27T04:07:35.966Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要</strong>：简单总结Jupyter Notebook的教程,方便以后使用。</p><p><img src="https://qiot.qnap.com/blog/wp-content/uploads/2018/08/JupyterHub-2.png" alt="此处输入图片的描述"><br><a id="more"></a></p><h2 id="notebook-界面组成"><a href="#notebook-界面组成" class="headerlink" title="notebook 界面组成"></a>notebook 界面组成</h2><ol><li>notebook 的名称</li><li>主工具栏，提供了保存、导出、重载 notebook，以及重启内核等选项</li><li>快捷键</li><li>notebook 主要区域，包含了 notebook 的内容编辑区</li></ol><h2 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h2><p>Command mode 和 Edit mode。 在一个cell中，按下Enter,进入Edit模式，按下Esc,进入Command 模式</p><p>运行当前cell，并移动到下一个Cell<br>在一个cell中（在command模式下）,  Shift + Enter  </p><h2 id="创建Cell"><a href="#创建Cell" class="headerlink" title="创建Cell"></a>创建Cell</h2><p>在一个cell中（在command模式下）</p><ol><li>按下 a ,即可在这个cell之前创建一个新的cell；</li><li>按下 b,即可在这个cell之后创建一个新的cell;</li></ol><h2 id="Cell中-Code-和-Markdown的切换"><a href="#Cell中-Code-和-Markdown的切换" class="headerlink" title="Cell中 Code 和 Markdown的切换"></a>Cell中 Code 和 Markdown的切换</h2><p>在一个cell中（在command模式下）</p><ol><li>按下y, 进入Code;</li><li>按下m, 进入Markdown;</li></ol><h2 id="显示Cell中的行数"><a href="#显示Cell中的行数" class="headerlink" title="显示Cell中的行数"></a>显示Cell中的行数</h2><p>在一个cell中（在command模式下），按下 l</p><h2 id="删除Cell"><a href="#删除Cell" class="headerlink" title="删除Cell"></a>删除Cell</h2><p>在一个cell中（在command模式下）, 按两次d</p><h2 id="保存Notebook"><a href="#保存Notebook" class="headerlink" title="保存Notebook"></a>保存Notebook</h2><p>在一个cell中（在command模式下）, 按下s</p><h2 id="启动命令面板"><a href="#启动命令面板" class="headerlink" title="启动命令面板"></a>启动命令面板</h2><p>在一个cell中（在command模式下）, 按下 Ctrl + Shift + P<br>界面中的小键盘图标也可以启动。</p><p>可以通过这个命令面板快速的执行命令。比如我这里将一个cell移动到它下一个cell的下面：在一个cell中（在command模式下），然后按下 Ctrl + Shift + P ，输入 move ，键盘方向键选择要执行的命令即可，然后按下回车即可执行。</p><h2 id="Matplotlib-集成"><a href="#Matplotlib-集成" class="headerlink" title="Matplotlib 集成"></a>Matplotlib 集成</h2><p>如果你用 Python 绘制过图形，那你肯定知道 matplotlib。Matplotlib 是一个用于创建漂亮图形的 Python 库，结合 Jupyter notebook 使用时体验更佳。</p><p>要想在 Jupyter notebook 中使用 matplotlib，需要告诉 Jupyter 获取 matplotlib 生成的所有图形，并将其嵌入 notebook 中。为此，需要计算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure></p><p>译注：要想执行成功，需要先<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install matplotlib。</span><br></pre></td></tr></table></figure></p><p>运行这个指令可能要花个几秒钟，但是在 notebook 中需要执行一次即可。接下来，我们来绘制一个图形，看看具体的集成效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">x = np.arange(20)</span><br><span class="line">y = x**2</span><br><span class="line"></span><br><span class="line">plt.plot(x, y)</span><br></pre></td></tr></table></figure><p>上面的代码将绘制方程式 y=x^2 。计算单元格后，会得到如下图形：<br><img src="https://www.packtpub.com/sites/default/files/new_blog_images/Extra_Blogs/Jupyter_01_11.png" alt="此处输入图片的描述"></p><h2 id="终极奥义"><a href="#终极奥义" class="headerlink" title="终极奥义"></a><font color="red">终极奥义</font></h2><p>按下键盘的 h。查看所有快捷键~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;：简单总结Jupyter Notebook的教程,方便以后使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://qiot.qnap.com/blog/wp-content/uploads/2018/08/JupyterHub-2.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Guidances" scheme="https://yoursite.com/categories/Guidances/"/>
    
    
      <category term="python" scheme="https://yoursite.com/tags/python/"/>
    
      <category term="jupyter notebook" scheme="https://yoursite.com/tags/jupyter-notebook/"/>
    
  </entry>
  
</feed>
