<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何自己签发Https证书]]></title>
    <url>%2F2019%2F06%2F08%2F%E9%85%8D%E7%BD%AEHTTPS%E8%AF%81%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[本文介绍如何利用Open-SSL工具和Java的keytool生成自签名证书。 关于什么是https及https的加密过程、通信过程，可以参考博客，接下来的内容介绍生成https证书的详细步骤。 Open-SSL 工具OpenSSL 是一个开源项目，其组成主要包括以下三个组件： OpenSSL：多用途的命令行工具 libcrypto：加密算法库 libssl：加密模块应用库，实现了ssl及tlsOpenSSL可以实现：秘钥证书管理、对称加密和非对称加密 。 生成秘钥和证书的过程废话不多说，利用OpenSSL的命令行工具生成秘钥和证书的详细过程如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138D:\OpenSSL-Win64\bin&gt;dir 驱动器 D 中的卷是 App 卷的序列号是 C67B-0BC3 D:\OpenSSL-Win64\bin 的目录2019/06/04 15:08 &lt;DIR&gt; .2019/06/04 15:08 &lt;DIR&gt; ..2019/05/28 22:36 7,813 CA.pl2019/05/28 22:36 69,120 capi.dll2019/05/28 22:36 44,544 dasync.dll2019/06/04 15:08 2,527 keystore.p122019/05/28 22:36 3,407,360 libcrypto-1_1-x64.dll2019/05/28 22:36 681,472 libssl-1_1-x64.dll2019/05/28 22:36 542,720 openssl.exe2019/05/28 22:36 44,032 ossltest.dll2019/05/28 22:36 39,936 padlock.dll2019/05/31 16:01 &lt;DIR&gt; PEM2019/05/28 22:36 5,562 progs.pl2019/05/28 22:36 6,779 tsget.pl 11 个文件 4,851,865 字节 3 个目录 379,711,356,928 可用字节D:\OpenSSL-Win64\bin&gt;openssl genrsa -out server.pemGenerating RSA private key, 2048 bit long modulus (2 primes)...+++++................................................+++++e is 65537 (0x010001)D:\OpenSSL-Win64\bin&gt;openssl req -x509 -new -key server.pem -out server.crtYou are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter '.', the field will be left blank.-----Country Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:beijingLocality Name (eg, city) []:beijingOrganization Name (eg, company) [Internet Widgits Pty Ltd]:MyServerOrganizational Unit Name (eg, section) []:MySeverCommon Name (e.g. server FQDN or YOUR name) []:www.baidu.comEmail Address []:D:\OpenSSL-Win64\bin&gt;openssl genrsa -out htx-server.pemGenerating RSA private key, 2048 bit long modulus (2 primes)...................................................+++++........+++++e is 65537 (0x010001)D:\OpenSSL-Win64\bin&gt;openssl req -new -key htx-server.pem -out htx-server.csrYou are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter '.', the field will be left blank.-----Country Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:beijingLocality Name (eg, city) []:beijingOrganization Name (eg, company) [Internet Widgits Pty Ltd]:MySever2Organizational Unit Name (eg, section) []:Mysever2Common Name (e.g. server FQDN or YOUR name) []:www.baidu.comEmail Address []:Please enter the following 'extra' attributesto be sent with your certificate requestA challenge password []:An optional company name []:D:\OpenSSL-Win64\bin&gt;openssl x509 -req -in htx-server.csr -CA server.crt -CAkey server.pem -CAcreateserial -days 3650 -out htx-server.crtSignature oksubject=C = CN, ST = beijing, L = beijing, O = MySever2, OU = Mysever2, CN = www.baidu.comGetting CA Private KeyD:\OpenSSL-Win64\bin&gt;openssl pkcs12 -export -in htx-server.crt -inkey htx-server.pem -out htx-server.p12Enter Export Password:Verifying - Enter Export Password:D:\OpenSSL-Win64\bin&gt;keytool -importkeystore -srckeystore htx-server.p12 -destkeystore htx-server.jks -srcstoretype pkcs12正在将密钥库 htx-server.p12 导入到 htx-server.jks...输入目标密钥库口令:再次输入新口令:它们不匹配。请重试输入目标密钥库口令:再次输入新口令:输入源密钥库口令:已成功导入别名 1 的条目。已完成导入命令: 1 个条目成功导入, 0 个条目失败或取消Warning:JKS 密钥库使用专用格式。建议使用 "keytool -importkeystore -srckeystore htx-server.jks -destkeystore htx-server.jks -deststoretype pkcs12" 迁移到行业标准格式 PKCS12。D:\OpenSSL-Win64\bin&gt;keytool -importcert -keystore htx-server.jks -file server.crt输入密钥库口令:所有者: CN=www.baidu.com, OU=MySever, O=MyServer, L=beijing, ST=beijing, C=CN发布者: CN=www.baidu.com, OU=MySever, O=MyServer, L=beijing, ST=beijing, C=CN序列号: 2086ab43ad3a294d722f1b14a0e4a3fa704e5087有效期为 Tue Jun 04 15:33:51 CST 2019 至 Thu Jul 04 15:33:51 CST 2019证书指纹: MD5: 94:3D:FB:DF:15:27:63:7F:3B:8F:A9:78:A8:A0:48:C0 SHA1: 67:9D:FC:69:BB:E1:C9:F9:B2:DC:C8:3C:10:73:1C:EF:F0:DE:8C:71 SHA256: 5F:FB:EC:AE:C0:32:85:BF:3B:39:62:63:BB:F7:26:06:AA:37:67:B8:C9:9F:05:CD:67:23:B2:E0:B6:96:1C:FE签名算法名称: SHA256withRSA主体公共密钥算法: 2048 位 RSA 密钥版本: 3扩展:#1: ObjectId: 2.5.29.35 Criticality=falseAuthorityKeyIdentifier [KeyIdentifier [0000: 2A BC AE CE DB E9 7A F2 56 FC 1A B2 8D 22 AF 9D *.....z.V...."..0010: B5 04 47 CB ..G.]]#2: ObjectId: 2.5.29.19 Criticality=trueBasicConstraints:[ CA:true PathLen:2147483647]#3: ObjectId: 2.5.29.14 Criticality=falseSubjectKeyIdentifier [KeyIdentifier [0000: 2A BC AE CE DB E9 7A F2 56 FC 1A B2 8D 22 AF 9D *.....z.V...."..0010: B5 04 47 CB ..G.]]是否信任此证书? [否]: y证书已添加到密钥库中Warning:JKS 密钥库使用专用格式。建议使用 "keytool -importkeystore -srckeystore htx-server.jks -destkeystore htx-server.jks -deststoretype pkcs12" 迁移到行业标准格式 PKCS12。 更详细的版本可以参考下面的命令： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135D:\OpenSSL-Win64\bin&gt;openssl genrsa -out server.key 2048 ZGenerating RSA private key, 2048 bit long modulus (2 primes).........................................+++++......+++++e is 65537 (0x010001)D:\OpenSSL-Win64\bin&gt;openssl rsa -in server.key -pubout -out server.pemwriting RSA keyD:\OpenSSL-Win64\bin&gt;openssl genrsa -out client.key 2048Generating RSA private key, 2048 bit long modulus (2 primes)................................................................+++++.+++++e is 65537 (0x010001)D:\OpenSSL-Win64\bin&gt;openssl rsa -in client.key -pubout -out client.pemwriting RSA keyD:\OpenSSL-Win64\bin&gt;openssl genrsa -out ca.key 2048Generating RSA private key, 2048 bit long modulus (2 primes)......+++++...............................+++++e is 65537 (0x010001)D:\OpenSSL-Win64\bin&gt;openssl req -new -key ca.key -out ca.csrYou are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &apos;.&apos;, the field will be left blank.-----Country Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:beijingLocality Name (eg, city) []:beijingOrganization Name (eg, company) [Internet Widgits Pty Ltd]:MyCAOrganizational Unit Name (eg, section) []:MyCACommon Name (e.g. server FQDN or YOUR name) []:www.baidu.comEmail Address []:Please enter the following &apos;extra&apos; attributesto be sent with your certificate requestA challenge password []:An optional company name []:D:\OpenSSL-Win64\bin&gt;openssl x509 -req -in ca.csr -signkey ca.key -out ca.crtSignature oksubject=C = CN, ST = beijing, L = beijing, O = MyCA, OU = MyCA, CN = www.baidu.comGetting Private keyD:\OpenSSL-Win64\bin&gt;openssl req -new -key server.key -out server.csrYou are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &apos;.&apos;, the field will be left blank.-----Country Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:beijingLocality Name (eg, city) []:beijingOrganization Name (eg, company) [Internet Widgits Pty Ltd]:MyServerOrganizational Unit Name (eg, section) []:MyServerCommon Name (e.g. server FQDN or YOUR name) []:www.baidu.comEmail Address []:Please enter the following &apos;extra&apos; attributesto be sent with your certificate requestA challenge password []:An optional company name []:D:\OpenSSL-Win64\bin&gt;openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in server.csr -out server.crtSignature oksubject=C = CN, ST = beijing, L = beijing, O = MyServer, OU = MyServer, CN = www.baidu.comGetting CA Private KeyD:\OpenSSL-Win64\bin&gt;openssl req -new -key client.key -out client.csrYou are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &apos;.&apos;, the field will be left blank.-----Country Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:beijingLocality Name (eg, city) []:beijingOrganization Name (eg, company) [Internet Widgits Pty Ltd]:MyClientOrganizational Unit Name (eg, section) []:MyclientCommon Name (e.g. server FQDN or YOUR name) []:www.baidu.comEmail Address []:Please enter the following &apos;extra&apos; attributesto be sent with your certificate requestA challenge password []:An optional company name []:D:\OpenSSL-Win64\bin&gt;openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in client.csr -out client.crtSignature oksubject=C = CN, ST = beijing, L = beijing, O = MyClient, OU = Myclient, CN = www.baidu.comGetting CA Private KeyD:\OpenSSL-Win64\bin&gt;dir 驱动器 D 中的卷是 App 卷的序列号是 C67B-0BC3 D:\OpenSSL-Win64\bin 的目录2019/06/04 14:29 &lt;DIR&gt; .2019/06/04 14:29 &lt;DIR&gt; ..2019/06/04 14:27 1,236 ca.crt2019/06/04 14:27 1,022 ca.csr2019/06/04 14:25 1,706 ca.key2019/05/28 22:36 7,813 CA.pl2019/06/04 14:29 42 ca.srl2019/05/28 22:36 69,120 capi.dll2019/06/04 14:29 1,250 client.crt2019/06/04 14:28 1,030 client.csr2019/06/04 14:25 1,702 client.key2019/06/04 14:25 460 client.pem2019/05/28 22:36 44,544 dasync.dll2019/05/28 22:36 3,407,360 libcrypto-1_1-x64.dll2019/05/28 22:36 681,472 libssl-1_1-x64.dll2019/05/28 22:36 542,720 openssl.exe2019/05/28 22:36 44,032 ossltest.dll2019/05/28 22:36 39,936 padlock.dll2019/05/31 16:01 &lt;DIR&gt; PEM2019/05/28 22:36 5,562 progs.pl2019/06/04 14:28 1,250 server.crt2019/06/04 14:28 1,030 server.csr2019/06/04 14:24 1,706 server.key2019/06/04 14:25 460 server.pem2019/05/28 22:36 6,779 tsget.pl 22 个文件 4,862,232 字节 3 个目录 379,711,369,216 可用字节 注意A整个过程可以概括为： 生成服务器的公钥和私钥 生成客户端的公钥和私钥 创建CSR文件，生成CA证书 B在配置过程中，Common Name应该是你需要配置的域名，例如下面是生成百度的证书： 1Common Name (e.g. server FQDN or YOUR name) []:www.baidu.com code在keystore/JKS文件里，事实上包含两种数据： 密钥实体（Key entity）——密钥（secret key）又或者是私钥和配对公钥（采用非对称加密） 可信任的证书实体（trusted certificate entries）——只包含公钥 参考链接： springcloud zuul配置https实现安全的app接口访问 Open-SSL]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud - 什么是Zuul网关(1)]]></title>
    <url>%2F2019%2F06%2F02%2FSpring-Cloud%E4%B9%8Bzuul%E7%BD%91%E5%85%B3%2F</url>
    <content type="text"><![CDATA[本文介绍 Spring Cloud 微服务架构中的网关实现- Zuul 。 一、 ZuulZuul 是netflix开源的一个API Gateway 服务器, 本质上是一个web servlet应用。在Spring Cloud微服务架构中，是整个微服务架构的网关实现，作为整个后台系统的入口。 API Gateway (网关)是微服务架构体系中的一类型特殊服务，它是所有微服务的入口，它的职责是执行路由请求、协议转换、聚合数据、认证、限流、熔断等。 通俗地讲，网关相当于微服务内网与请求客户端外网（如浏览器，APP）之间的门户，所有对微服务系统的访问都会经过这个网络，扮演了一个“反向代理”和“智能网关”的角色。 一个系统可以有一个或者多个网关，来针对性地响应不同的请求: 二、 Zuul 作用当使用单体应用程序架构时，客户端通过向后端应用程序发起一次REST调用来获取数据。负载均衡器将请求路由给N个相同的应用程序实例中的一个。然后应用程序会查询各种数据库表，并将响应返回给客户端。 微服务架构下，单体应用被切割成多个微服务，如果将所有的微服务直接对外暴露，势必会出现安全方面的各种问题。 客户端可以直接向每个微服务发送请求，其问题主要如下： 客户端需求和每个微服务暴露的细粒度API不匹配。 部分服务使用的协议不是Web友好协议。可能使用Thrift二进制RPC，也可能使用AMQP消息传递协议。 微服务难以重构。如果合并两个服务，或者将一个服务拆分成两个或更多服务，这类重构就非常困难了。 为了解决上述问题，Zuul的功能主要包括： 接口管理: 如果微服务中有很多个独立服务都要对外提供服务，那么对于开发人员或者运维人员来说，如何去管理这些接口?特别是当项目非常大非常庞杂的情况下要如何管理? 在Zuul上管理接口，可以配置不同的请求路由到不同的微服务上，既可以避免将微服务的接口直接暴露给客户端，也可以方便运维，即是后端微服务发生了变化，网关定义的REST调用路径依然可以不改变。 权限管理: 在微服务中，一个独立的系统被拆分成很多个独立的模块，为了确保安全，我难道需要在每一个模块上都添加上相同的鉴权代码来确保系统不被非法访问?如果是这样的话，那么工作量就太大了，而且维护也非常不方便。而因为Zuul等网关位于所有微服务的前端，因此可以很方便地实现权限认证，比如实现 cookie 或 token 的认证。 其他功能可以参考博客。 请求路由和版本控制 方便单体应用到微服务的过渡 数据聚合 协议转换 缓存和限流 三、 Zuul 的使用Zuul的大部分应用场景是作为Spring Cloud的微服务体系的网关，作为一个特殊的微服务发布到Eureka注册中心。 事实单独的Zuul上也能完全承担反向代理的角色。 3.1 pom 配置首先需要引入相关依赖：1234567891011121314151617181920212223242526272829&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR1&lt;/spring-cloud.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 如果需要用到Eureka，还需要引入如下依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; 3.2 配置入口类在入口类上添加@EnableZuulProxy注解表示开启Zuul的API网关服务功能:1234567@SpringBootApplication@EnableZuulProxypublic class ZuulApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulApplication.class, args); &#125;&#125; 1234567@EnableCircuitBreaker@EnableDiscoveryClient@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Import(&#123;ZuulProxyConfiguration.class&#125;)public @interface EnableZuulProxy &#123;&#125; 注意坑1：配置入口类的时候，通常会遇到两个注解：@EnableZuulProxy 和 @EnableZuulServer，虽然很多人说前者是后者的增强版，当Zuul与Eureka、Ribbon等组件配合使用时，使用@EnableZuulProxy。 但是在测试过程中，如果不依赖于Eureka，使用@EnableZuulServer 实现的路由转发会遇到客户端无法收到Response的问题。 研究了两者的区别，发现@EnableZuulProxy相比于@EnableZuulServer，增加了如下过滤器： pre类型过滤器 PreDecorationFilter：该过滤器根据提供的RouteLocator确定路由到的地址，以及怎样去路由。该路由器也可为后端请求设置各种代理相关的header。 route类型过滤器 SimpleHostRoutingFilter：该过滤器通过Apache HttpClient向指定的URL发送请求。URL在RequestContext.getRouteHost()中。 而SimpleHostRoutingFilter是实现请求发送的关键。 3.3 编辑配置文件Zuul 的路由策略默认通过配置文件实现，也可以通过插件读取配置中心或者数据库内的配置。 这里只考虑配置文件：bootstrap.yml或者application.yml。 当 Zuul 不配合 Eureka 服务发现服务的时候，Zuul 的路由就要基于 URL 去路由，示例配置如下，实现对当前端口9999请求的转发： 123456789101112spring: application: name: zuul-gatewayserver: port: 9999zuul: routes: baidu: path: /** url: http://www.baidu.com 注意坑2：yml配置文件的key-value中间包含了一个空格！另外缩进是两个空格，格式不能错！ 注意坑3：如果需要指定下一级路由，比如讲localhost:9999/test/**的所有请求转发到www.testsite.com/test/**,需要如下配置：123456zuul: routes: baidu: path: /test/** url: http://www.testsite.com/test/ # url: http://www.testsite.com 这是错误的 四、 过滤器Filter过滤器是Zuul的核心，借助不同的过滤器，Zuul可以实现路由的不同功能。 4.1 过滤器类型 Zuul中定义了四种标准过滤器类型，这些过滤器类型对应于请求的典型生命周期。 PRE：这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等。 ROUTE：这种过滤器将请求路由到微服务。这种过滤器用于构建发送给微服务的请求，并使用Apache HttpClient或Netfilx Ribbon请求微服务。 POST：这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等。 ERROR：在其他阶段发生错误时执行该过滤器。 也可以自定义特殊的STATIC的Filter。 其生命周期如下图： 4.2 自定义一个过滤器 自定义一个过滤器需要继承抽象类ZuulFilter，并实现四个抽象方法： filterType方法的返回值为过滤器的类型，过滤器的类型决定了过滤器在哪个生命周期执行，pre表示在路由之前执行过滤器，其他可选值还有post、error、route和static，当然也可以自定义。 filterOrder方法表示过滤器的执行顺序，当过滤器很多时，这个方法会有意义。 shouldFilter方法用来判断过滤器是否执行，true表示执行，false表示不执行，在实际开发中，我们可以根据当前请求地址来决定要不要对该地址进行过滤。 run方法则表示过滤的具体逻辑。 1234567891011121314151617181920212223@Componentpublic class TestFilter extends ZuulFilter &#123; @Override public String filterType() &#123; return "pre"; &#125; @Override public int filterOrder() &#123; return 0; &#125; @Override public boolean shouldFilter() &#123; return true; &#125; @Override public Object run() &#123; RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); // 打印请求URL System.err.println(request.getRequestURL().toString()); return null; &#125;&#125; 配置过滤器Bean最后需要在入口类中将自定义的过滤器交给Bean容器管理。 1234567891011@SpringBootApplication@EnableZuulProxypublic class ZuulApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulApplication.class, args); &#125; @Bean TestFilter testFilter() &#123; return new TestFilter(); &#125;&#125; 其他其他关于Zuul知识点包括熔断，负载均衡，后续再总结吧。 参考文献： 1. 微服务网关netflix-Zuul2. 微服务 API Gateway 介绍3. Spring Cloud中的API网关服务Zuul]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java源码</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTPD配置重定向与过滤器]]></title>
    <url>%2F2019%2F05%2F18%2FHTTPD%E9%85%8D%E7%BD%AE%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[本文介绍如何配置HTTPD服务器的反向代理服务，实现目标网页的控制和过滤。 一、简介Apache HTTP Server（简称Apache或httpd）是Apache软件基金会的一个开放源代码的网页服务器软件，旨在为unix，windows等操作系统中提供开源httpd服务。由于其安全性、高效性及可扩展性，被广泛使用，自1996年4月以来，Apache一直是Internet上最流行的HTTP服务器。它快速、可靠并且可通过简单的API扩充，将Perl／Python等解释器等编译到httpd的相关模块中。 如果要实现对用户访问网页资源的控制和过滤，可以通过两种方式实现：重定向与过滤器。 二、设置重定向通过在配置文件中设置RewriteRule实现。HTTPD的服务器配置文件conf/httpd.conf中，通过如下设置： 去掉Module的注释，或者添加如下配置： 1LoadModule rewrite_module modules/mod_rewrite.so` 开启RewriteEngine(也可以自定义配置文件，注意需要在httpd.conf中添加相关路径) 配置ServerName 利用正则配置重定向路径规则1RewriteRule old-URL new-URL 在自定义的配置文件中，完整的配置如下： 1234567891011121314&lt;Directory target-file-path&gt; #target-file-path：为目标资源路径名 AllowOverride NONE Require all granted&lt;/Directory&gt;&lt;VirtualHost *:80&gt; RewriteEngine on ServerName test.com RewriteRule ^/test.js target-file-path ProxyPreserveHost On ProxyRequests off ProxyPass / http://test.com/ ProxyPassReverse / http://test.com/&lt;/VirtualHost&gt; 对于配置中的问题，可以在var/log/errorlog中查看错误日志： 12345678[Fri May 17 20:53:36.109491 2019] [auth_digest:notice] [pid 18476] AH01757: generating secret for digest authentication ...[Fri May 17 20:53:36.109917 2019] [lbmethod_heartbeat:notice] [pid 18476] AH02282: No slotmem from mod_heartmonitor[Fri May 17 20:53:36.131890 2019] [mpm_prefork:notice] [pid 18476] AH00163: Apache/2.4.6 (CentOS) PHP/5.6.40 configured -- resuming normal operations[Fri May 17 20:53:36.131908 2019] [core:notice] [pid 18476] AH00094: Command line: &apos;/usr/sbin/httpd -D FOREGROUND&apos;[Fri May 17 20:53:46.777123 2019] [mpm_prefork:notice] [pid 18476] AH00170: caught SIGWINCH, shutting down gracefully[Fri May 17 20:53:47.824784 2019] [suexec:notice] [pid 18529] AH01232: suEXEC mechanism enabled (wrapper: /usr/sbin/suexec)[Fri May 17 20:53:47.827118 2019] [so:warn] [pid 18529] AH01574: module rewrite_module is already loaded, skippingAH00558: httpd: Could not reliably determine the server&apos;s fully qualified domain name, using --------. Set the &apos;ServerName&apos; directive globally to suppress this message 三、过滤器过滤器用来对 server 收到/发送的数据进行再加工。过滤器分两种：input filters 用于处理 server 从 client 收到的数据，output filters 用于处理 server 向 client 发送的数据。一个数据流上可以挂多个过滤器。这些过滤器可以通过显式指定来确定执行顺序。 注意: InputFilter 只能拦截客户端的POST请求，对于GET请求，需要设置如下的过滤方式。 3.1 JS注入为了实现对网页的过滤，可以利用过滤器得到网页，通过JS注入的方式改变网页DOM数结构。而过滤器实现可以通过PHP或者Python等脚本语言。 首先配置过滤器，配置文件如下： 123456789ExtFilterDefine testOutFilter mode=output cmd=&quot;/usr/bin/php /etc/httpd/filters/test.php&quot;&lt;VirtualHost *:80&gt; ServerName test.com ProxyPreserveHost On ProxyRequests off ProxyPass / http://test.com/ ProxyPassReverse / http://test.com/ SetOutputFilter testOutFilter&lt;/VirtualHost&gt; 利用PHP脚本JS注入 123456789101112131415&lt;?php# test.php $stream = file_get_contents("php://stdin"); $stream = gzdecode($stream); $jsContent = file_get_contents("/etc/httpd/filters/test.js"); $dom = new DOMDocument(); $dom -&gt; loadHTML($stream); $nodes = $dom -&gt; getElementsByTagName('body'); foreach($nodes as $node)&#123; $script = $dom -&gt; createElement('script',$jsContent); $script -&gt; setAttribute( "type","text/javascript"); $js = $node -&gt; appendChild($script); &#125; echo gzencode($dom -&gt; saveHTML());?&gt; JavaScript的脚本test.js实现对HTML页面的DOM树修改。 1234&lt;script type=&quot;text/javascript&quot;&gt;// test.jsalert(&apos;0&apos;);&lt;/script&gt; 3.2 脚本过滤 也可以直接用PHP对拦截的数据流直接处理，首先是修改配置文件，示例如下： 1234567891011ExtFilterDefine testOutFilter2 mode=output cmd=&quot;/usr/bin/php /etc/httpd/filters/test2.php&quot;&lt;VirtualHost *:80&gt; ServerName newkeeper-web.jd.com ProxyPreserveHost On ProxyRequests off ProxyPass / http://test.com/ ProxyPassReverse / http://test.com/ &lt;Location &quot;/static/js/test.js&quot;&gt; SetOutputFilter testOutFilter2 &lt;/Location&gt;&lt;/VirtualHost&gt; 用PHP脚本替换拦截的JS文件内容： 12345678&lt;?php# test2.php $stream = file_get_contents("php://stdin"); $stream = gzdecode($stream); $stream = preg_replace('old_string', 'new_string', $stream); $stream = gzencode($stream); echo $stream;?&gt; 参考链接[HTTPD] Linux（Apache）Httpd服务器安装，启动及httpd.conf配置详解Apache HTTP Server - Dev]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发(3)-线程安全]]></title>
    <url>%2F2019%2F04%2F05%2FJava%E5%B9%B6%E5%8F%91(3)-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[volatile, synchronized, Lock? 详解Java的线程安全与锁！ 一、内存模型高速缓存因为CPU执行速度和内存数据读写速度差距很大，因此CPU往往包含高速缓存结构。当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。 缓存不一致问题执行下面的代码：12int i = 0;i = i + 1; 当线程执行这个语句时，会先从主存当中读取i的值i = 0，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。 可能存在情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。 也就是说，如果一个变量在多个CPU中都存在缓存（多线程情况），那么就可能存在缓存不一致的问题。 缓存不一致的解决一般有两种解决办法： 总线加锁 因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。 缓存一致性协议 由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。所以就出现了缓存一致性协议。最出名的就是Intel的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。MESI协议核心思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。 二、线程安全问题产生原因从前面的分析，在并发编程（多线程编程）中，可能出现线程安全的问题： 多个线程在操作共享的数据。 操作共享数据的线程代码有多条。 当一个线程在执行操作共享数据的多条代码过程中，其他线程参与了运算。 并发的核心概念三个核心概念：原子性、可见性、顺序性。 原子性：跟数据库事务的原子性概念差不多，即一个操作（有可能包含有多个子操作）要么全部执行（生效），要么全部都不执行（都不生效）。 锁和同步（同步方法和同步代码块）、CAS（CPU级别的CAS指令cmpxchg）。 可见性：当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即看到。 volatile关键字来保证可见性。 JVM使用happens-before的概念来阐述多线程之间的内存可见性: 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作； 锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作； volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作； 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C； 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作； 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生； 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行； 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始； 顺序性：程序执行的顺序按照代码的先后顺序执行。因为处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的-即指令重排序。 volatile在一定程序上保证顺序性，另外还可以通过synchronized和锁来保证顺序性。 三、Java对象头的结构Java对象可以作为并发编程中的锁。而锁实际上存在于Java对象头里。如果对象是数组类型，则虚拟机用 3 个 Word（字宽）存储对象头，如果对象是非数组类型，则用 2 字宽存储对象头。在 64 位虚拟机中，一字宽等于八字节，即 64bit。 Java 对象头里的 Mark Word 里默认存储对象的 HashCode，分代年龄和锁标记位。32 位 JVM 的 Mark Word 的默认存储结构如下： - 25 bit 4bit 偏向锁标志位(1bit) 锁标志位(2bit) 无锁状态 对象的hashCode 对象分代年龄 01 64 位JVM的存储结构如下： 锁状态 25bit 31bit 1bit 4bit 1bit 2bit cms_free 分代年龄 偏向锁 锁标志位 无锁 unused hashCode 01 偏向锁 ThreadID(54bit) Epoch(2bit) 1 01 在运行期间 Mark Word 里存储的数据会随着锁标志位的变化而变化。 在了解了相关概念后，接下来介绍Java是如何保证并发编程中的安全的。 四、synchronized用法 修饰同步代码块 将多条操作共享数据的线程代码封装起来，当有线程在执行这些代码的时候，其他线程时不可以参与运算的。必须要当前线程把这些代码都执行完毕后，其他线程才可以参与运算。 1234 synchronized(对象)&#123;需要被同步的代码 ；&#125; 修饰同步函数(方法) 12 修饰符 synchronized 返回值 方法名()&#123;&#125; 修饰一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； 修饰一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。 synchronized的作用主要有三个：（1）确保线程互斥的访问同步代码（2）保证共享变量的修改能够及时可见（3）有效解决重排序问题。 锁对象 对于同步方法，锁是当前实例对象。 对于静态同步方法，锁是当前对象的 Class 对象。 对于同步方法块，锁是 synchonized 括号里配置的对象。 实现原理在编译的字节码中加入了两条指令来进行代码的同步。 (1)monitorenter ：每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下： 如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。 如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1. 如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。 (2)monitorexit：执行monitorexit的线程必须是objectref所对应的monitor的所有者。指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor的所有权。 synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。 好处和弊端好处：解决了线程的安全问题。 弊端：相对降低了效率，因为同步外的线程的都会判断同步锁。获得锁和释放锁带来性能消耗。 编译器对synchronized优化Java6 为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java6 里锁一共有四种状态：无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级。 偏向锁：大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后（线程的id会记录在对象的Mark Wod中），消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。 轻量级锁（CAS）：轻量级锁是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁；轻量级锁的意图是在没有多线程竞争的情况下，通过CAS操作尝试将MarkWord更新为指向LockRecord的指针，减少了使用重量级锁的系统互斥量产生的性能消耗。 重量级锁：虚拟机使用CAS操作尝试将MarkWord更新为指向LockRecord的指针，如果更新成功表示线程就拥有该对象的锁；如果失败，会检查MarkWord是否指向当前线程的栈帧，如果是，表示当前线程已经拥有这个锁；如果不是，说明这个锁被其他线程抢占，此时膨胀为重量级锁。 锁状态对应的Mark Word以32位JVM为例： 锁状态 25 bit 4bit 1bit 2bit 23bit 2bit 是否是偏向锁 锁标志位 轻量级锁 指向栈中锁记录的指针 00 重量级锁 指向互斥量（重量级锁）的指针 10 GC标记 空 11 偏向锁 线程ID Epoch 对象分代年龄 1 01 五、volatilevolatile是Java中的一个关键字，用来修饰共享变量（类的成员变量、类的静态成员变量）。 被修饰的变量包含两层语义： 保证可见性 线程写入变量时不会把变量写入缓存，而是直接把值刷新回主存。同时，其他线程在读取该共享变量的时候，会从主内存重新获取值，而不是使用当前缓存中的值。（因此会带来一部分性能损失）。注意：往主内存中写入的操作不能保证原子性。 禁止指令重排 禁止指令重排序有两层意思： 1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行； 2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 底层实现：观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令。 六、Lock应用场景如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况： 获取锁的线程执行完了该代码块，然后线程释放对锁的占有； 线程执行发生异常，此时JVM会让线程自动释放锁。 如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，会让程序效率很差。 因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。 源码分析与Lock相关的接口和类位于J.U.C的java.util.concurrent.locks包下。 (1)Lock接口12345678public interface Lock &#123; void lock(); void lockInterruptibly() throws InterruptedException; boolean tryLock(); boolean tryLock(long time, TimeUnit unit) throws InterruptedException; void unlock(); Condition newCondition();&#125; 获取锁lock()：获取锁，如果锁被暂用则一直等待。tryLock(): 有返回值的获取锁。注意返回类型是boolean，如果获取锁的时候锁被占用就返回false，否则返回true。tryLock(long time, TimeUnit unit)：比起tryLock()就是给了一个时间期限，保证等待参数时间。lockInterruptibly()：当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。 注意：当一个线程获取了锁之后，是不会被interrupt()方法中断的。因为本身在前面的文章中讲过单独调用interrupt()方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。 释放锁unlock():释放锁。 (2)ReentrantLock类ReentrantLock，意思是“可重入锁”。ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法，基于AQS(AbstractQueuedSynchronizer)来实现的。 并且，ConcurrentHashMap并没有采用synchronized进行控制，而是使用了ReentrantLock。 构造方法ReentrantLock 分为公平锁和非公平锁，可以通过构造方法来指定具体类型：123456public ReentrantLock() &#123; sync = new NonfairSync();&#125;public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync();&#125; 以非公平锁为例： 获取锁123public void lock() &#123; sync.lock();&#125; 而sync是一个abstract内部类：1234abstract static class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = -5179523762034025860L; abstract void lock();&#125; 其lock()方法用的是构造得到的FairSync对象，即sync的实现类。123456789101112131415public ReentrantLock() &#123; sync = new NonfairSync();&#125;//删去了一些方法static final class NonfairSync extends Sync &#123; final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); &#125; protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125;&#125; 而compareAndSetState是AQS的一个方法，也就是基于CAS操作。12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 尝试进一步获取锁（调用继承自父类sync的final方法）：123456789101112131415161718final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125; 首先会判断 AQS 中的 state 是否等于 0，0表示目前没有其他线程获得锁，当前线程就可以尝试获取锁。如果 state 大于 0 时，说明锁已经被获取了，则需要判断获取锁的线程是否为当前线程(ReentrantLock 支持重入)，是则需要将 state + 1，并将值更新。 如果 tryAcquire(arg) 获取锁失败，则需要用addWaiter(Node.EXCLUSIVE) 将当前线程写入队列中。写入之前需要将当前线程包装为一个 Node对象(addWaiter(Node.EXCLUSIVE))。 即回到：12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 释放锁 1234567891011121314151617181920212223242526272829公平锁和非公平锁的释放流程都是一样的：public void unlock() &#123; sync.release(1);&#125;public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) //唤醒被挂起的线程 unparkSuccessor(h); return true; &#125; return false;&#125;//尝试释放锁protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free;&#125; (3)ReadWriteLock接口与ReentrantReadWriteLock类 定义1234public interface ReadWriteLock &#123; Lock readLock(); Lock writeLock();&#125; 在ReentrantLock中，线程之间的同步都是互斥的，不管是读操作还是写操作，但是在一些场景中读操作是可以并行进行的，只有写操作才是互斥的，这种情况虽然也可以使用ReentrantLock来解决，但是在性能上也会损失，ReadWriteLock就是用来解决这个问题的。 实现-ReentrantReadWriteLock类 在ReentrantReadWriteLock中分别定义了读锁和写锁，与ReentrantLock类似，读锁和写锁的功能也是通过Sync实现的，Sync存在公平和非公平两种实现方式，不同的是表示锁状态的state的定义，在ReentrantReadWriteLock中具体定义如下：123456789101112131415161718192021222324252627282930static final int SHARED_SHIFT = 16;static final int SHARED_UNIT = (1 &lt;&lt; SHARED_SHIFT);static final int MAX_COUNT = (1 &lt;&lt; SHARED_SHIFT) - 1;static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;//获取读锁的占有次数static int sharedCount(int c) &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125;//获取写锁的占有次数static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125;//线程的id和对应线程获取的读锁的数量static final class HoldCounter &#123; int count = 0; // Use id, not reference, to avoid garbage retention final long tid = Thread.currentThread().getId();&#125;//线程变量保存线程和线程中获取的读写的数量static final class ThreadLocalHoldCounter extends ThreadLocal&lt;HoldCounter&gt; &#123; public HoldCounter initialValue() &#123; return new HoldCounter(); &#125;&#125;private transient ThreadLocalHoldCounter readHolds;//缓存最后一个获取读锁的线程private transient HoldCounter cachedHoldCounter;//保存第一个获取读锁的线程private transient Thread firstReader = null; private transient int firstReaderHoldCount; 其中，包含两个静态内部类：ReadLock()与WriteLock(),都实现了Lock接口。 获取读锁： 如果不存在线程持有写锁，则获取读锁成功。 如果其他线程持有写锁，则获取读锁失败。 如本线程持有写锁，并且不存在等待写锁的其他线程，则获取读锁成功。 如本线程持有写锁，并且存在等待写锁的其他线程，则如果本线程已经持有读锁，则获取读锁成功，如果不能存在读锁，则此次获取读锁失败。 获取写锁： 判断是否有线程持有锁，包括读锁和写锁，如果有，则执行步骤2，否则步骤3; 如果写锁为空(此时由于1步骤判断存在锁，则存在持有读锁的线程)，或者持有写锁的不是本线程,直接返回失败，如果写锁数量大于MAX_COUNT，返回失败，否则更新state，并且返回true; 如果需要写锁堵塞判断，或者CAS失败直接返回false，否则设置持有写锁的线程为本线程，并且返回true; 通过writerShouldBlock写锁堵塞判断.1234567891011final boolean writerShouldBlock() &#123; return hasQueuedPredecessors(); &#125;//判断是否堵塞public final boolean hasQueuedPredecessors() &#123; Node t = tail; Node h = head; Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread()); &#125; 七、比较Lock和synchronizedsynchronized是基于JVM层面实现的，而Lock是基于JDK层面实现的。Lock需要lock和release，比synchronized复杂，但Lock可以做更细粒度的锁，支持获取超时、获取中断，这是synchronized所不具备的。Lock的实现主要有ReentrantLock、ReadLock和WriteLock,读读共享，写写互斥，读写互斥。 Lock是一个接口，而synchronized是Java中的关键字，是内置的语言实现； synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁； Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断； 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。 Lock可以提高多个线程进行读操作的效率。 Lock实现和synchronized不一样，后者是一种悲观锁，它胆子很小，它很怕有人和它抢吃的，所以它每次吃东西前都把自己关起来。而Lock底层其实是CAS 乐观锁的体现，它无所谓，别人抢了它吃的，它重新去拿吃的就好啦，所以它很乐观。底层主要靠volatile和CAS操作实现的。 synchronized和volatile volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取; synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住; volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的; volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性; volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞; volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。 八、死锁问题死锁有四个必要条件，打破一个即可去除死锁。 四个必要条件： 互斥条件 一个资源每次只能被一个进程使用。 请求与保持条件 一个线程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件 线程已获得的资源，在末使用完之前，不能强行剥夺。 循环等待条件 若干线程之间形成一种头尾相接的循环等待资源关系。 死锁的例子同步嵌套时，两个线程互相锁住，都不释放，造成死锁。举例：创建两个字符串a和b，再创建两个线程A和B，让每个线程都用synchronized锁住字符串（A先锁a，再去锁b；B先锁b，再锁a），如果A锁住a，B锁住b，A就没办法锁住b，B也没办法锁住a，这时就陷入了死锁。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class DeadLock &#123; public static String obj1 = "obj1"; public static String obj2 = "obj2"; public static void main(String[] args)&#123; Thread a = new Thread(new Lock1()); Thread b = new Thread(new Lock2()); a.start(); b.start(); &#125; &#125;class Lock1 implements Runnable&#123; @Override public void run()&#123; try&#123; System.out.println("Lock1 running"); while(true)&#123; synchronized(DeadLock.obj1)&#123; System.out.println("Lock1 lock obj1"); Thread.sleep(3000);//获取obj1后先等一会儿，让Lock2有足够的时间锁住obj2 synchronized(DeadLock.obj2)&#123; System.out.println("Lock1 lock obj2"); &#125; &#125; &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125;class Lock2 implements Runnable&#123; @Override public void run()&#123; try&#123; System.out.println("Lock2 running"); while(true)&#123; synchronized(DeadLock.obj2)&#123; System.out.println("Lock2 lock obj2"); Thread.sleep(3000); synchronized(DeadLock.obj1)&#123; System.out.println("Lock2 lock obj1"); &#125; &#125; &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 九、相关锁的概念在 java 中锁的实现主要有两类：内部锁 synchronized（对象内置的monitor锁）和显示锁java.util.concurrent.locks.Lock。 可重入锁 指的是同一线程外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响，执行对象中所有同步方法不用再次获得锁。synchronized和Lock都具备可重入性。 可中断锁 synchronized就不是可中断锁，而Lock是可中断锁。 公平锁 按等待获取锁的线程的等待时间进行获取，等待时间长的具有优先获取锁权利。synchronized就是非公平锁；对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。 读写锁 对资源读取和写入的时候拆分为2部分处理，读的时候可以多线程一起读，写的时候必须同步地写。ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。 自旋锁 让线程去执行一个无意义的循环，循环结束后再去重新竞争锁，如果竞争不到继续循环，循环过程中线程会一直处于running状态，但是基于JVM的线程调度，会让出时间片，所以其他线程依旧有申请锁和释放锁的机会。自旋锁省去了阻塞锁的时间空间（队列的维护等）开销，但是长时间自旋就变成了“忙式等待”，忙式等待显然还不如阻塞锁。所以自旋的次数一般控制在一个范围内，例如10,100等，在超出这个范围后，自旋锁会升级为阻塞锁。 独占锁 是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。 乐观锁 每次不加锁，假设没有冲突去完成某项操作，如果因为冲突失败就重试，直到成功为止。 悲观锁 导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。 关于JUC包含了两个子包：atomic以及lock，另外在concurrent下的阻塞队列以及executors，以后再深入学习源码吧，下面这个图很是经典： 参考链接 Java并发编程：volatile关键字解析 Java SE1.6 中的 Synchronized Java并发编程：Lock Java并发机制的底层实现 Java死锁 深入理解JVM 初识Lock与AbstractQueuedSynchronizer(AQS)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>Java源码</tag>
        <tag>Java并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法之美-剑指Offer题解(Java实现)]]></title>
    <url>%2F2019%2F03%2F21%2F%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3(Java%E5%AE%9E%E7%8E%B0)%2F</url>
    <content type="text"><![CDATA[剑指Offer的所有题目和分类，Solution用Java语言实现。 剑指Offer题解点击每个题目对应的分类即可看到题目和解答 # 名称 分类 1 左旋转字符串 字符串 2 实现 Singleton 设计模式 3 数组中重复的数字 数组 4 二维数组中的查找 数组 5 替换空格 字符串 6 从尾到头打印链表 链表 7 重建二叉树 树 8 二叉树的下一个节点 树 9 用两个栈实现队列 栈、队列 10.1 斐波那契数列 动态规划、递归 10.2 （变态）跳台阶 动态规划、递归 10.3 矩形覆盖 动态规划、递归 10.4 背包问题详解 动态规划、递归 11 旋转数组的最小数字 数组 12 矩阵中的路径 回溯 13 机器人的运动范围 回溯 14 剪绳子 动态规划、贪心算法 15 二进制中 1 的个数，附源码解析 位运算 16 数值的整数次方 递归 17 打印从 1 到最大的 n 位数 回溯 18.1 在 O(1) 时间内删除链表节点 链表 18.2 删除链表中重复的结点 链表,回溯 19 正则表达式匹配 递归，动态规划 20 表示数字的字符串 正则 21 调整数组顺序使奇数位于偶数前面 数组 22 链表中倒数第 K 个结点 链表，双指针 23 链表中环的入口结点 双指针 24 反转链表 递归，链表 25 合并两个排序的链表 链表，递归 26 树的子结构 递归，树 27 二叉树的镜像 树，递归 28 对称的二叉树 树，递归 29 顺时针打印矩阵 逻辑能力 30 包含 min 函数的栈 栈,类似9 31 栈的压入、弹出序 栈 32.1 从上往下打印二叉树 队列 32.2 分层打印二叉树 队列 32.3 之字形打印二叉树 队列 33 二叉搜索树的后序遍历序列 树的遍历，递归 34 二叉树中和为某一值的路径 树，递归 35 复杂链表的复制 复杂链表 36 二叉搜索树与双向链表 二叉树、链表 37 序列化二叉树 二叉树、递归 38 字符串的排列 回溯 39 数组中出现次数超过一半的数字 多数投票问题 40 最小的 K 个数 快排，大根堆小根堆 41.1 数据流中的中位数 大根堆小根堆 41.2 字符流中第一个不重复的字符 数据流 42 连续子数组的最大和 数组 43 从 1 到 n 整数中 1 出现的次数，leetcode-233（Hard） 逻辑 44 数字序列中的某一位数字 逻辑 45 把数组排成最小的数 排序，逻辑 46 把数字翻译成字符串 动态规划 47 礼物的最大价值 动态规划 48 最长不含重复字符的子字符串 双指针 49 丑数 动态规划，逻辑 50 第一个只出现一次的字符位置 BitSet 51 数组中的逆序对 排序问题 52 两个链表的第一个公共结点 链表，双指针 53 数字在排序数组中出现的次数 二分查找 54 二叉查找树的第 K 个结点 二叉树，中序遍历 55.1 二叉树的深度 回溯 55.2 平衡二叉树 回溯 56 数组中只出现一次的数字 位运算 57.1 和为S的两个数字 数组，双指针 57.2 和为 S 的连续正数序列 数组，双指针 58 翻转单词顺序列 字符串 59 滑动窗口的最大值 大根堆，滑动窗口 60 动态规划解法 动态规划，旋转数组 61 扑克牌顺子 数组 62 圆圈中最后剩下的数 约瑟夫环 63 股票的最大利润 数组 64 求 1+2+3+…+n 递归，&amp;&amp;短路 65 不用加减乘除做加法 位运算，BigInteger 66 构建乘积数组 逻辑 67 把字符串转换成整数 字符串 68 树中两个节点的最低公共祖先 二分查找树，递归 参考 何海涛. 剑指 Offer[M]. 电子工业出版社, 2012. 题目顺序参考：CS-Notes-剑指offer题解]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>algorithms</tag>
        <tag>Java算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法之美-用两个X实现一个Y]]></title>
    <url>%2F2019%2F02%2F21%2F%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E2%80%94%E7%94%A8%E4%B8%A4%E4%B8%AAX%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAY%2F</url>
    <content type="text"><![CDATA[对于经典面试题：“两个栈实现队列”和“两个队列实现栈”,应该怎么考虑呢？ 两个栈实现队列思路: 利用inStack作为进队的缓存。出队时，因为考虑到“先进先出”，可以利用另一个栈outStack转存当前的缓存。出队时，为了保证再入队依旧满足规律，若outStack为空，先全部倒入outStack；若不为空，则outStack直接出栈。 12345678910111213141516171819202122232425private Stack&lt;Integer&gt; inStack = new Stack&lt;&gt;();private Stack&lt;Integer&gt; outStack = new Stack&lt;&gt;();void push(Integer in)&#123; inStack.push(in);&#125;Integer pop() throws Exception &#123; if(outStack.isEmpty())&#123; while(!inStack.isEmpty())&#123; outStack.push(inStack.pop()); &#125; &#125; if(outStack.isEmpty())&#123; throw new Exception("no data"); &#125; return outStack.pop();&#125;public static void main(String[] args) throws Exception &#123; Solution9 test = new Solution9(); test.push(8); test.push(9); test.push(99); System.out.println(test.pop()); test.push(999);&#125; 两个队列实现栈思路： 利用一个队存储，另一个队作为缓存。当出栈时，让非空的队列先出队n-1，最后剩下的一个出队则完成了栈的“先入先出”的功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051LinkedList&lt;Integer&gt; queue1=new LinkedList&lt;Integer&gt;(); LinkedList&lt;Integer&gt; queue2=new LinkedList&lt;Integer&gt;(); public void push(int value)//入栈 &#123; queue1.addLast(value); &#125; public int pop()//出栈 必须是非空的栈才能出栈啊 &#123; if(sSize()!=0)//栈不为空 &#123; //移动一个队的n-1个到另一个中 if(!queue1.isEmpty())//q1 空 &#123; putN_1ToAnthor(); return queue1.removeFirst(); &#125; else //q2 空 &#123; putN_1ToAnthor(); return queue2.removeFirst(); &#125; &#125; else &#123; System.out.println("栈已经为空啦，不能出栈"); return -1; &#125; &#125; public int sSize() &#123; return queue1.size()+queue2.size(); &#125; public void putN_1ToAnthor()//从非空中出队n-1个到另一个队列 因为队列总是一空一非空 &#123; if(!queue1.isEmpty()) &#123; while(queue1.size()&gt;1) &#123; queue2.addLast(queue1.removeFirst()); &#125; &#125; else if(!queue2.isEmpty()) &#123; while(queue2.size()&gt;1) &#123; queue1.addLast(queue2.removeFirst()); &#125; &#125; &#125; 其他类似题目（更新中。。） 包含 min 函数的栈题目描述：定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。12345678910111213141516171819202122232425262728293031 private Stack&lt;Integer&gt; datastack = new Stack&lt;&gt;(); private Stack&lt;Integer&gt; minstack = new Stack&lt;&gt;(); public void push(int node) &#123; datastack.push(node);// if(minstack.isEmpty())&#123;// minstack.push(node);// &#125;else&#123;// if(minstack.peek()&lt;node)&#123;// minstack.push(minstack.peek());// &#125;else&#123;// minstack.push(node);// &#125;// &#125; //注意minstack栈顶始终存储的当前栈的最小值，且长度和datastack一样 minStack.push(minStack.isEmpty() ? node : Math.min(minStack.peek(), node)); &#125; public void pop() &#123; datastack.pop(); minstack.pop();//注意这里 &#125; public int top() &#123; return datastack.peek(); &#125; public int min() &#123; return minstack.peek(); &#125; 数据流中的中位数题目描述：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 两个栈实现：123456789101112131415161718192021222324252627282930313233343536373839404142//用两个栈实现的 Stack&lt;Integer&gt; min = new Stack&lt;&gt;(); Stack&lt;Integer&gt; max = new Stack&lt;&gt;(); int number = 0; public void Insert(Integer num) &#123; number++; if(min.size() == 0 &amp;&amp; (max.size() == 0 || num &lt;= max.peek()))&#123; min.push(num); return; &#125; if(max.size() == 0 &amp;&amp; (min.size() == 0 || num &gt;= min.peek()))&#123; max.push(num); return; &#125; if(num &gt; max.peek())&#123; while(max.size() != 0 &amp;&amp; num&gt;max.peek())&#123; min.push(max.pop()); &#125; &#125; if(num &lt; min.peek())&#123; while( min.size() != 0&amp;&amp; num&lt;min.peek() )&#123; max.push(min.pop()); &#125; &#125; min.push(num); &#125; public Double GetMedian() &#123; while(min.size()&lt;number/2)&#123; min.push(max.pop()); &#125; while(min.size()&gt;number/2)&#123; max.push(min.pop()); &#125; if(number%2==0)&#123; return (min.peek()+max.peek())/2.0; &#125; else&#123; return (double)max.peek(); &#125; &#125; 两个大根堆实现： 1234567891011121314151617181920212223242526272829 //用堆实现的 /* 大顶堆，存储左半边元素 */ private PriorityQueue&lt;Integer&gt; left = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1); /* 小顶堆，存储右半边元素，并且右半边元素都大于左半边 */ private PriorityQueue&lt;Integer&gt; right = new PriorityQueue&lt;&gt;(); /* 当前数据流读入的元素个数 */ private int N = 0; public void Insert2(Integer val) &#123; /* 插入要保证两个堆存于平衡状态 */ if (N % 2 == 0) &#123;/* N 为偶数的情况下插入到右半边。* 因为右半边元素都要大于左半边，但是新插入的元素不一定比左半边元素来的大，* 因此需要先将元素插入左半边，然后利用左半边为大顶堆的特点，取出堆顶元素即为最大元素，此时插入右半边 */ left.add(val); right.add(left.poll()); &#125; else &#123; right.add(val); left.add(right.poll()); &#125; N ++; &#125; public Double GetMedian2() &#123; if (N % 2 == 0) return (left.peek() + right.peek()) / 2.0; else return (double) right.peek(); &#125;]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>algorithms</tag>
        <tag>Java算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库(4)-事务与数据库连接池]]></title>
    <url>%2F2019%2F02%2F17%2F%E6%95%B0%E6%8D%AE%E5%BA%93(4)-%E4%BA%8B%E5%8A%A1%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[本文总结数据库事务、安全问题与隔离级别，以及数据库连接池的相关知识。 一、MySQL事务(Transaction) MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务。 MYSQL 事务处理主要有两种方法： 1、用 BEGIN, ROLLBACK, COMMIT来实现 1234BEGIN 开始一个事务//START TRANSACTIONROLLBACK 事务回滚COMMIT 事务确认 2、直接用 SET 来改变 MySQL 的自动提交模式: 12SET AUTOCOMMIT=0 禁止自动提交SET AUTOCOMMIT=1 开启自动提交 在JDBC代码中，需要有两个声明：123456789//调用Connection对象的setAutoCommit();Connection conn = DriverManager.getConnection("jdbc:mysql://localhost/database_name", "user", "password");conn.setAutoCommit(false);//随后执行数据库操作...//最后提交conn.commit()//并且在异常处理中回滚conn.rollback(); 注意：setAutoCommit()只针对Connection对象，如果新建一个连接对象，仍然是默认提交。 二、事务的特性 事务是必须满足4个条件（ACID）：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 三、数据库的安全问题和隔离级别（1）安全问题-读脏读、 不可重复读、幻读 脏读:一个事务读到了另一个事务未提交的数据。 不可重复读:一个事务读到了另一个事务提交的数据，多次查询结果不一致。 幻读:一个事务读到了另一个事务已提交的插入的数据，导致多次查询结果不一致。 （2）安全问题-写 丢失更新问题，指一个事务去修改数据库， 另一个事务也修改数据库，最后的那个事务，不管是提交还是回滚都会造成前面一个事务的数据更新丢失 主要解决办法是加锁：乐观锁、悲观锁。 悲观锁：指事务在一开始就认为丢失更新一定会发生， 这是一件很悲观的事情。类似synchronized加锁。悲观锁通过在查询条件后面加for udate实现。 乐观锁:指从来不会觉得丢失更新会发生。通过手动在数据库中设置字段，利用CAS操作实现。 （3）不可重复读和幻读的区别幻读更加关注于insert操作,事务在插入已经检查过不存在的记录时，惊奇的发现这些数据已经存在了，之前的检测获取到的数据如同鬼影一般。 （4）隔离级别-四种 读未提交:Read Uncommitted 引发问题： 脏读 读已提交:Read Committed 解决： 脏读 ， 引发： 不可重复读 可重复读:Repeatable Read 解决： 脏读 、 不可重复读 ， 未解决： 幻读 可串行化:Serializable 解决： 脏读、 不可重复读 、 幻读。 mySql 默认的隔离级别是 可重复读Oracle 默认的隔离级别是 读已提交 （5）设置隔离级别12345678//读未提交set session transaction isolation level read uncommited;//读已提交set session transaction isolation level read commited;//可重复读set session transaction isolation level repeatable read;//可串行化set session transaction isolation level serializable; 四、数据库连接池（1）作用 1． 资源重用 由于数据库连接得到重用，避免了频繁创建、释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增进了系统运行环境的平稳性（减少内存碎片以及数据库临时进程/线程的数量）。 2． 更快的系统响应速度 数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而缩减了系统整体响应时间。 3． 新的资源分配手段 对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接的配置，实现数据库连接池技术，几年钱也许还是个新鲜话题，对于目前的业务系统而言，如果设计中还没有考虑到连接池的应用，那么…….快在设计文档中加上这部分的内容吧。某一应用最大可用数据库连接数的限制，避免某一应用独占所有数据库资源。 4． 统一的连接管理，避免数据库连接泄漏 在较为完备的数据库连接池实现中，可根据预先的连接占用超时设定，强制收回被占用连接。从而避免了常规数据库连接操作中可能出现的资源泄漏。一个最小化的数据库连接池实现： （2）常用数据库连接池常用的数据库连接池包括DBCP,C3P0,Druid。关键配置： 最小连接数: 是数据库一直保持的数据库连接数，所以如果应用程序对数据库连接的使用量不大，将有大量的数据库资源被浪费。 初始化连接数： 连接池启动时创建的初始化数据库连接数量。 最大连接数： 是连接池能申请的最大连接数，如果数据库连接请求超过此数，后面的数据库连接请求被加入到等待队列中。 最大等待时间： 当没有可用连接时，连接池等待连接被归还的最大时间，超过时间则抛出异常，可设置参数为0或者负数使得无限等待(根据不同连接池配置)。 A. DBCP使用1234567891011121314151617181920212223242526public void testDBCP01()&#123;Connection conn = null; PreparedStatement ps = null; try &#123; //1. 构建数据源对象 BasicDataSource dataSource = new BasicDataSource(); //连的是什么类型的数据库， 访问的是哪个数据库 ， 用户名， 密码。。 //jdbc:mysql://localhost/bank 主协议：子协议 ://本地/数据库 dataSource.setDriverClassName("com.mysql.jdbc.Driver"); dataSource.setUrl("jdbc:mysql://localhost/databasename"); dataSource.setUsername("root"); dataSource.setPassword("root"); //2. 得到连接对象 conn = dataSource.getConnection(); String sql = "insert into account values(null , ? , ?)"; ps = conn.prepareStatement(sql); ps.setString(1, "admin"); ps.setInt(2, 1000); ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; //3.释放连接对象 JDBCUtil.release(conn, ps); &#125; &#125; B.C3P0使用1234567891011121314151617181920212223Connection conn = null;PreparedStatement ps = null;try &#123; //1. 创建datasource ComboPooledDataSource dataSource = new ComboPooledDataSource(); //2. 设置连接数据的信息 dataSource.setDriverClass("com.mysql.jdbc.Driver"); dataSource.setJdbcUrl("jdbc:mysql://localhost/database_name"); dataSource.setUser("root"); dataSource.setPassword("root"); //3. 得到连接对象 conn = dataSource.getConnection(); String sql = "insert into account values(null , ? , ?)"; ps = conn.prepareStatement(sql); ps.setString(1, "admin"); ps.setInt(2, 100); ps.executeUpdate();&#125; catch (Exception e) &#123; e.printStackTrace();&#125;finally &#123; //释放资源 JDBCUtil.release(conn, ps);&#125; 注意，在使用c3p0连接池的时候，可能遇到无法连接的问题，而此时，可以尝试将配置文件c3p0-config.xml改为如下内容： 1234567891011121314151617181920212223242526272829&lt;c3p0-config&gt; &lt;!-- 使用默认的配置读取连接池对象 --&gt; &lt;default-config&gt; &lt;!-- 连接参数 --&gt; &lt;property name="driverClass"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;!-- 主要注意这行内容，需要用 &amp;amp; 代替 &amp; --&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql://localhost:3306/stu?serverTimezone=GMT&amp;amp;characterEncoding=UTF-8&amp;amp;useSSL=false&lt;/property&gt; &lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;root&lt;/property&gt; &lt;!-- 连接池参数 --&gt; &lt;property name="initialPoolSize"&gt;5&lt;/property&gt; &lt;property name="maxPoolSize"&gt;10&lt;/property&gt; &lt;property name="checkoutTimeout"&gt;3000&lt;/property&gt; &lt;/default-config&gt; &lt;named-config name="otherc3p0"&gt; &lt;!-- 连接参数 --&gt; &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql://localhost:3306/??&lt;/property&gt; &lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;root&lt;/property&gt; &lt;!-- 连接池参数 --&gt; &lt;property name="initialPoolSize"&gt;5&lt;/property&gt; &lt;property name="maxPoolSize"&gt;8&lt;/property&gt; &lt;property name="checkoutTimeout"&gt;1000&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; （3）自定义数据库连接池 使用栈来存放数据库连接，每次都从上面取出连接，使用完也放回上面。假如使用的频率特别低会导致栈底部的连接长时间未使用，则可以直接释放以节省资源。 连接容器中超时连接的释放有两种方式：（1）在往容器中添加或者取出连接的时候释放。（2）单独开一个线程不断轮询所有连接释放超时的连接。一般采用第一种方式。 栈中连接的使用时间是有序的。所以每次释放的时候，只需要从底部向上开始扫描，遇到超时的连接则进行释放，遇上非超时的连接则停止扫描，如果栈中连接均未超时，则只需要扫描最后一个就可以了。 参考文献常用数据库连接池 (DBCP、c3p0、Druid) 配置说明数据库连接池的实现及原理]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法之美-回溯]]></title>
    <url>%2F2019%2F01%2F21%2F%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E5%9B%9E%E6%BA%AF%2F</url>
    <content type="text"><![CDATA[N皇后的问题应该怎么解决？回溯法来帮忙！ 什么是回溯？回溯法思路的简单描述是：把问题的解空间转化成了图或者树的结构表示，然后使用深度优先搜索策略进行遍历，遍历的过程中记录和寻找所有可行解或者最优解。基本思想类同于图的深度优先搜索和二叉树的后序遍历。 回溯法按深度优先策略搜索问题的解空间树。首先从根节点出发搜索解空间树，当算法搜索至解空间树的某一节点时，先利用剪枝函数判断该节点是否可行（即能得到问题的解）。如果不可行，则跳过对该节点为根的子树的搜索，逐层向其祖先节点回溯；否则，进入该子树，继续按深度优先策略搜索。 回溯法的基本思想是按照输入数组的顺序，每一层递归处理一个元素，当处理到最后一层的时候，也就是把数组中的所有元素都处理完的时候，把当前结果加入到最后的返回结果中。值得注意的是，每次在递归到下一层之前，我们加入了某个要处理的元素X，在下一层递归返回之后，我们要把之前加入的元素X从当前结果中取出来。如果我们不把元素X取出来，那么在下一次循环中，我们还会加入新的元素Y。那么在这一层递归中就相当于处理了不止一个新元素。 经典题目实例(1) 矩阵中的路径题目描述：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。题解：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879private int rows;private int cols;public boolean hasPath(char[] array, int rows, int cols, char[] str) &#123; //异常情况判断 if(array.length == 0 || array.length != rows * cols)&#123; return false; &#125; if(str.length == 0)&#123; return true; &#125; char[][] matrix = new char[rows][cols]; boolean[][] mark = new boolean[rows][cols]; this.rows = rows; this.cols = cols; //把一维数组转化成二维矩阵 for (int r = 0, idx = 0; r &lt; rows; r++) &#123; //注意括号内的inx的定义方式 for (int c = 0; c &lt; cols; c++) &#123; matrix[r][c] = array[idx++]; &#125; &#125; //遍历数组每个元素，依次与字符串比较 for (int r = 0; r &lt; rows; r++) &#123; for (int c = 0; c &lt; cols; c++) &#123; if (matrix[r][c] == str[0]) &#123; mark[r][c] = true; if(helper(matrix, r, c, str,mark, 0))&#123; return true; &#125; mark[r][c] = false; &#125; &#125; &#125; return false;&#125;//回溯算法的主体，依次迭代，直到最后的结论；private boolean helper(char[][] matrix, int r, int c, char[] str,boolean[][] mark, int number) &#123; if(number == str.length-1)&#123; return true; &#125; number += 1; if(r-1 &gt;=0)&#123; if(matrix[r-1][c] == str[number] &amp;&amp; !mark[r-1][c])&#123; mark[r-1][c] = true; if(helper(matrix, r-1, c, str, mark, number))&#123; return true; &#125; &#125; &#125; if(r+1 &lt; rows)&#123; if(matrix[r+1][c] == str[number] &amp;&amp; !mark[r+1][c])&#123; mark[r+1][c] = true; if(helper(matrix, r+1, c, str, mark, number))&#123; return true; &#125; &#125; &#125; if(c-1 &gt;= 0)&#123; if(matrix[r][c-1] == str[number] &amp;&amp; !mark[r][c-1])&#123; mark[r][c-1] = true; if(helper(matrix, r, c-1, str, mark, number))&#123; return true; &#125; &#125; &#125; if(c+1 &lt; cols)&#123; if(matrix[r][c+1] == str[number] &amp;&amp; !mark[r][c+1])&#123; mark[r][c+1] = true; if(helper(matrix, r, c+1, str, mark, number))&#123; return true; &#125; &#125; &#125; return false;&#125; （2）机器人的运动范围题目描述：地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k 的格子。例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,38)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？题解：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private int rows;private int cols;private int result = 0;private boolean[][] mark;public int movingCount(int threshold, int rows, int cols)&#123; this.rows = rows; this.cols = cols; this.mark = new boolean[rows][cols]; boolean[][] marktmp = new boolean[rows][cols]; //注意边界问题 if(!(threshold &lt;= 0 || rows &lt;=0 || cols &lt;=0))&#123; helper(threshold,rows,cols,0,0,marktmp); &#125; return result;&#125;//回溯法核心private void helper(int threshold, int rows, int cols, int r, int c, boolean[][] marktmp) &#123; if(judge(threshold,r,c) &amp;&amp; !marktmp[r][c])&#123; System.out.println(Integer.toString(threshold)+" "+Integer.toString(r)+" "+Integer.toString(c)); marktmp[r][c] = true; if(mark[r][c] == false)&#123; mark[r][c] = true; result++; &#125; if(r+1 &lt; rows)&#123; helper(threshold,rows,cols,r+1,c,marktmp); &#125; if(c+1&lt;cols)&#123; helper(threshold,rows,cols,r,c+1,marktmp); &#125; if(r-1 &gt;=0)&#123; helper(threshold,rows,cols,r-1,c,marktmp); &#125; if(c-1 &gt;=0)&#123; helper(threshold,rows,cols,r,c-1,marktmp); &#125; &#125;&#125;//判断是否符合规则private boolean judge(int threshold, int row, int col)&#123; int tmp = 0; while(row &gt;0)&#123; tmp += row%10; row/=10; &#125; while(col &gt;0)&#123; tmp += col%10; col/=10; &#125; return threshold &gt;= tmp?true:false;&#125; （3）N皇后问题题目描述：要求在一个n×n的棋盘上放置n个皇后，使得它们彼此不受攻击。按照国际象棋的规则，一个皇后可以攻击与之同一行或同一列或同一斜线上的任何棋子。因此，n皇后问题等价于：要求在一个n×n的棋盘上放置n个皇后，使得任意两个皇后不在同一行或同一列或同一斜线上。题解：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788 private static int SIZE = 0;//皇后的个数private static int count = 0;//记录摆放的方式数public static void main(String[] args) &#123; // TODO Auto-generated method stub Scanner input = new Scanner(System.in); System.out.println("请输入你要解决几个皇后的问题"); SIZE = input.nextInt(); input.close(); LinkedList&lt;Location&gt; list = new LinkedList&lt;Location&gt;(); NQueen(list, 0, 0); //从棋盘的第0行第0列开始 System.out.println(SIZE + "皇后共有 " + count + "种摆放方式");&#125;static class Location&#123; int x;//对应棋盘的行 int y;//对应棋盘的列 Location(int x,int y)&#123; this.x = x; this.y = y; &#125; public String toString() &#123; return "(" + x + "," + y + ")"; &#125;&#125;/** * 主要函数，用回溯法。 */ private static void NQueen(LinkedList&lt;Location&gt; list, int x, int y) &#123; if(list.size() == SIZE)&#123; //当list元素个数为SIZE时，表示SIZE个皇后都摆放完毕，打印后即可退出函数。 printLocation(list); //打印皇后摆放方式 return ; &#125; for(int i = x ; i &lt; SIZE ; i++)&#123; Location loc = new Location(i, y); if(isLegalLoc(list, loc))&#123; list.offer(loc); //将第y行的皇后摆放好 NQueen(list, 0, y+1); //开始摆放y+1行的皇后，同样从第0列开始摆放 list.pollLast(); //每次摆放完一个皇后后，都要将其撤回，再试探其它的摆法。 &#125; &#125; &#125;/** * 判断位置为loc的皇后是否合法 */ private static boolean isLegalLoc(LinkedList&lt;Location&gt; list, Location loc) &#123; for(Location each : list)&#123; if(loc.x == each.x || loc.y == each.y) //判断是否在同一行或同一列 return false; else if (Math.abs(loc.x - each.x) == Math.abs(loc.y - each.y)) //判断是否在同斜线上 return false; &#125; return true; &#125; /** * 打印皇后摆放方式 * @param list */ private static void printLocation(LinkedList&lt;Location&gt; list) &#123; String[][] show = new String[SIZE][SIZE]; for(int i = 0;i&lt;SIZE;i++) &#123; for(int j = 0;j&lt;SIZE;j++) &#123; show[i][j] = "0"; &#125; &#125; for(Location each : list)&#123; System.out.print(each.toString() + "\t"); show[each.x][each.y] = "1"; &#125; System.out.println(); for(int i =0;i&lt;SIZE;i++) &#123; for(int j=0;j&lt;SIZE;j++) &#123; System.out.print(show[i][j] + " "); &#125; System.out.println(); &#125; System.out.println(); count ++; &#125; (4)迷宫问题题目描述：以一个M×N的长方阵表示迷宫，0和1分别表示迷宫中的通路和障碍。设计一个程序，对任意设定的迷宫，求出一条从入口到出口的通路，或得出没有通路的结论。 （1） 根据二维数组，输出迷宫的图形。 （2） 探索迷宫的四个方向：RIGHT为向右，DOWN向下，LEFT向左，UP向上，输出从入口到出口的行走路径。题解：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152class Position&#123; public Position()&#123; &#125; public Position(int row, int col)&#123; this.col = col; this.row = row; &#125; public String toString()&#123; return "(" + row + " ," + col + ")"; &#125; int row; int col;&#125;class Maze&#123; public Maze()&#123; maze = new int[15][15]; stack = new Stack&lt;Position&gt;(); p = new boolean[15][15]; &#125; /* * 构造迷宫 */ public void init()&#123; Scanner scanner = new Scanner(System.in); System.out.println("请输入迷宫的行数"); row = scanner.nextInt(); System.out.println("请输入迷宫的列数"); col = scanner.nextInt(); System.out.println("请输入" + row + "行" + col + "列的迷宫"); int temp = 0; for(int i = 0; i &lt; row; ++i) &#123; for(int j = 0; j &lt; col; ++j) &#123; temp = scanner.nextInt(); maze[i][j] = temp; p[i][j] = false; &#125; &#125; &#125; /* * 回溯迷宫，查看是否有出路 */ public void findPath()&#123; // 给原始迷宫的周围家一圈围墙 int temp[][] = new int[row + 2][col + 2]; for(int i = 0; i &lt; row + 2; ++i) &#123; for(int j = 0; j &lt; col + 2; ++j) &#123; temp[0][j] = 1; temp[row + 1][j] = 1; temp[i][0] = temp[i][col + 1] = 1; &#125; &#125; // 将原始迷宫复制到新的迷宫中 for(int i = 0; i &lt; row; ++i) &#123; for(int j = 0; j &lt; col; ++j) &#123; temp[i + 1][j + 1] = maze[i][j]; &#125; &#125; // 从左上角开始按照顺时针开始查询 int i = 1; int j = 1; p[i][j] = true; stack.push(new Position(i, j)); while (!stack.empty() &amp;&amp; (!(i == (row) &amp;&amp; (j == col)))) &#123; if ((temp[i][j + 1] == 0) &amp;&amp; (p[i][j + 1] == false)) &#123; p[i][j + 1] = true; stack.push(new Position(i, j + 1)); j++; &#125; else if ((temp[i + 1][j] == 0) &amp;&amp; (p[i + 1][j] == false)) &#123; p[i + 1][j] = true; stack.push(new Position(i + 1, j)); i++; &#125; else if ((temp[i][j - 1] == 0) &amp;&amp; (p[i][j - 1] == false)) &#123; p[i][j - 1] = true; stack.push(new Position(i, j - 1)); j--; &#125; else if ((temp[i - 1][j] == 0) &amp;&amp; (p[i - 1][j] == false)) &#123; p[i - 1][j] = true; stack.push(new Position(i - 1, j)); i--; &#125; else &#123; stack.pop(); if(stack.empty())&#123; break; &#125; i = stack.peek().row; j = stack.peek().col; &#125; &#125; Stack&lt;Position&gt; newPos = new Stack&lt;Position&gt;(); if (stack.empty()) &#123; System.out.println("没有路径"); &#125; else &#123; System.out.println("有路径"); System.out.println("路径如下："); while (!stack.empty()) &#123; Position pos = new Position(); pos = stack.pop(); newPos.push(pos); &#125; &#125; /* * 图形化输出路径 * */ String resault[][]=new String[row+1][col+1]; for(int k=0;k&lt;row;++k)&#123; for(int t=0;t&lt;col;++t)&#123; resault[k][t]=(maze[k][t])+""; &#125; &#125; while (!newPos.empty()) &#123; Position p1=newPos.pop(); resault[p1.row-1][p1.col-1]="#"; &#125; for(int k=0;k&lt;row;++k)&#123; for(int t=0;t&lt;col;++t)&#123; System.out.print(resault[k][t]+"\t"); &#125; System.out.println(); &#125; &#125; int maze[][]; private int row = 9; private int col = 8; Stack&lt;Position&gt; stack; boolean p[][] = null;&#125;class hello&#123; public static void main(String[] args)&#123; Maze demo = new Maze(); demo.init(); demo.findPath(); &#125;&#125;]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>algorithms</tag>
        <tag>Java算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法之美-十大排序算法]]></title>
    <url>%2F2019%2F01%2F21%2F%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[各种排序算法的Java实现。 排序算法分类比较类通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。 非比较类不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 算法的时间复杂度比较 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。 冒泡排序（Bubble Sort）重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 算法描述 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤1~3，直到排序完成。 实现123456789for (int i = testList.length-1; i &gt;= 1 ;i--) &#123; for (int j = 0; j &lt; i; j++) &#123; if(testList[j]&gt;testList[j+1])&#123; int temp = testList[j]; testList[j] = testList[j+1]; testList[j+1] = temp; &#125; &#125;&#125; 选择排序（Selection Sort）选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 算法描述n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： 初始状态：无序区为R[1..n]，有序区为空； 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； n-1趟结束，数组有序化了。 实现1234567891011121314151617181920//最小值选择排序public static int[] minSort(int[] list)&#123; if(list.length == 0 ) return list; for (int i = 0; i &lt; list.length-1; i++) &#123; int min = list[i], indexMin = i; for (int j = i+1; j &lt; list.length; j++) &#123; if(list[j] &lt; min)&#123; min = list[j]; indexMin = j; &#125; &#125; if(list[i] &gt; min)&#123; list[indexMin] = list[i]; list[i] = min; &#125; &#125; return list;&#125; 12345678910111213141516171819//最大值选择排序public static int[] maxSort(int[] list)&#123; if(list.length == 0 ) return list; for (int i = list.length- 1; i &gt; 0 ; i--) &#123; int maxIndex = i; for (int j = i -1 ; j &gt;= 0 ; j--) &#123; if(list[j] &gt; list[maxIndex])&#123; maxIndex = j; &#125; &#125; if(list[maxIndex] &gt; list[i])&#123; int temp = list[i]; list[i] = list[maxIndex]; list[maxIndex] = temp; &#125; &#125; return list;&#125; 插入排序（Insertion Sort）插入排序（Insertion-Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 算法描述一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 实现123456789101112131415public static int[] insertSort(int[] list)&#123; if(list.length&lt;=1)&#123; return list; &#125; for (int i = 1; i &lt; list.length ; i++) &#123; int temp = list[i]; int index = i-1; while(index&gt;=0 &amp;&amp; list[index]&gt;temp)&#123; list[index+1] = list[index]; index --; &#125; list[index+1] = temp; &#125; return list;&#125; 希尔排序（Shell Sort）1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。 算法描述先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 实现123456789101112131415private static int[] shellSort(int[] testList) &#123; for (int gap = testList.length/2; gap &gt;= 1; gap/=2) &#123; //对子序列插入排序 for (int i = gap; i &lt; testList.length; i++) &#123; int j = i; int current = testList[i]; while(j-gap&gt;=0 &amp;&amp; testList[j-gap]&gt;current)&#123; testList[j] = testList[j-gap]; j-=gap; &#125; testList[j] = current; &#125; &#125; return testList; &#125; 归并排序（Merge Sort）归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 算法描述 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 实现12345678910111213141516171819202122232425262728293031private static int[] mergeSort(int[] testList,int left,int right) &#123; if(left&lt;right)&#123; mergeSort(testList,left,(left+right)/2); mergeSort(testList,(left+right)/2+1,right); merge(testList,left,(left+right)/2,right); &#125; return testList;&#125;private static void merge(int[] testList, int left, int middle, int right)&#123; int[] temp = new int[right - left + 1]; int i = left; int j = middle+1; int k = 0; while(i&lt;=middle&amp;&amp;j&lt;=right)&#123; if (testList[i] &lt; testList[j]) &#123; temp[k++] = testList[i++]; &#125; else &#123; temp[k++] = testList[j++]; &#125; &#125; while(i&lt;=middle)&#123; temp[k++] = testList[i++]; &#125; while(j&lt;=right)&#123; temp[k++] = testList[j++]; &#125; for (int k2 = 0; k2 &lt; temp.length; k2++) &#123; testList[k2 + left] = temp[k2]; &#125;&#125; 快速排序（Quick Sort）快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 算法描述快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 实现12345678910111213141516171819202122232425//分治的方法private static int[] quickSort(int[] testList, int start, int end) &#123; if (testList == null || start &gt;= end) return testList; int i = start, j = end; int pivotKey = testList[start]; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; testList[j] &gt;= pivotKey) j--; if (i &lt; j)&#123; testList[i++] = testList[j]; System.out.println("i++"+Arrays.toString(testList)); &#125; while (i &lt; j &amp;&amp; testList[i] &lt;= pivotKey) i++; if (i &lt; j)&#123; testList[j--] = testList[i]; System.out.println("j--"+Arrays.toString(testList));&#125; &#125; testList[i] = pivotKey; quickSort(testList, start, i - 1); quickSort(testList, i + 1, end); return testList;&#125; 12345678910111213141516171819202122232425262728293031323334353637//经典的解法public static int[] quickSort2(int[] testList, int start, int end) &#123; if (testList == null || start &lt; 0 || end &gt; testList.length - 1) &#123; throw new IllegalArgumentException("Invalid Parameters"); &#125; if (start == end) return testList; int index = partition(testList, start, end); if (index &gt; start) &#123; quickSort2(testList, start, index - 1); &#125; if (index &lt; end) &#123; quickSort2(testList, index + 1, end); &#125; return testList;&#125;private static int partition(int[] testList, int start, int end) &#123; int index = start + (int)(Math.random() * (end - start + 1)); swap(testList, index, end); int small = start - 1; for (index = start; index &lt; end; index++) &#123; if (testList[index] &lt; testList[end]) &#123; small++; if (small != index) &#123; swap(testList, index, small); &#125; &#125; &#125; swap(testList, small + 1, end); return small + 1;&#125;private static void swap(int[] testList, int i, int j)&#123; int temp = testList[i]; testList[i] = testList[j]; testList[j] = temp;&#125; 堆排序（Heap Sort）堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 算法描述 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]； 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 实现123456789101112131415161718192021222324252627282930313233343536373839404142public static void heapify(int[] list, int currentindex, int length)&#123; if (currentindex &lt; length) &#123; int left = 2 * currentindex + 1; int right = 2 * currentindex + 2; int max = currentindex; if (left &lt;= length) &#123; if (list[max] &lt; list[left]) &#123; max = left; &#125; &#125; if (right &lt;= length) &#123; if (list[max] &lt; list[right]) &#123; max = right; &#125; &#125; //如果最大的不是根元素位置，那么就交换 if (max != currentindex) &#123; int temp = list[max]; list[max] = list[currentindex]; list[currentindex] = temp; heapify(list, max, length); &#125; &#125;&#125;public static void swap(int[] list,int index1, int index2)&#123; int temp = list[index2]; list[index2]= list[index1]; list[index1] = temp;&#125;public static void buildheap(int[] list)&#123; for (int i = list.length-1; i &gt;= 0 ; i--) &#123; heapify(list,i,list.length-1); &#125;&#125;public static void heapsort(int[] list)&#123; buildheap(list); System.out.println(Arrays.toString(list)); for (int i = list.length-1; i &gt;= 1 ; i--) &#123; swap(list,i,0); heapify(list,0,i-1); &#125;&#125; 计数排序（Counting Sort）计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 算法描述 找出待排序的数组中最大和最小的元素； 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 实现12345678910111213141516public static void countingSort(int[] list)&#123; int[] temp = new int[list.length]; int[] count = new int[list.length]; for(int i = 0;i &lt; list.length - 1;i++) &#123; for(int j = i + 1;j &lt; list.length;j++) &#123; if(list[i] &lt; list[j]) count[j]++; else count[i]++; &#125; &#125; for(int i = 0;i &lt; list.length;i++) temp[count[i]] = list[i]; for(int i = 0;i &lt; list.length;i++) list[i] = temp[i];&#125; 桶排序（Bucket Sort）桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。 算法描述 设置一个定量的数组当作空桶； 遍历输入数据，并且把数据一个一个放到对应的桶里去； 对每个不是空的桶进行排序； 从不是空的桶里把排好序的数据拼接起来。 实现123456789101112131415161718192021222324public static void bucketSort(int [] arr)&#123; int min = 0, max = 0; for(int i = 0; i &lt;= arr.length - 1; i++)&#123; if(arr[i] &lt; min)&#123; min = arr[i]; &#125; if(arr[i] &gt; max)&#123; max = arr[i]; &#125; &#125; int bucketCount = max - min + 1; int[] bucket = new int[bucketCount]; for(int i = 0; i &lt;= arr.length - 1; i++)&#123; bucket[arr[i] - min]++; &#125; for(int i = 1; i &lt; bucketCount; i++)&#123; bucket[i] = bucket[i] + bucket[i - 1]; &#125; int [] copy = new int[arr.length]; System.arraycopy(arr, 0, copy, 0, arr.length); for(int i = arr.length - 1; i &gt;= 0; i--)&#123; arr[--bucket[copy[i] - min]] = copy[i]; &#125;&#125; 基数排序（Radix Sort）基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。 算法描述 取得数组中的最大数，并取得位数； array为原始数组，从最低位开始取每个位组成radix数组； 对radix进行计数排序（利用计数排序适用于小范围数的特点）； 实现12345678910111213141516171819202122232425262728293031private static void radixSort(int[] array,int d)&#123; int n=1; int k=0; int length=array.length; int[][] bucket=new int[10][length]; int[] order=new int[length]; while(n&lt;d) &#123; for(int num:array) &#123; int digit=(num/n)%10; bucket[digit][order[digit]]=num; order[digit]++; &#125; for(int i=0;i&lt;length;i++) &#123; if(order[i]!=0) &#123; for(int j=0;j&lt;order[i];j++) &#123; array[k]=bucket[i][j]; k++; &#125; &#125; order[i]=0; &#125; n*=10; k=0; &#125;&#125; 参考链接：十大经典排序算法]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>algorithms</tag>
        <tag>Java算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的艺术-Java容器(2)之并发修改异常]]></title>
    <url>%2F2019%2F01%2F06%2FJava%E7%9A%84%E8%89%BA%E6%9C%AF-Java%E5%AE%B9%E5%99%A8(2)%E4%B9%8B%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[ConcurrentModificationException（并发修改异常）为什么会出现？怎么解决呢？ 什么时候出现“并发修改异常”？看下面这两段代码 (1)增强for 12345678ArrayList&lt;String&gt; res = new ArrayList&lt;&gt;();res.add("a");res.add("b");for (String s:res)&#123; if(s=="a")&#123; res.add("c"); &#125;&#125; (2)迭代器 12345678910ArrayList&lt;String&gt; res = new ArrayList&lt;&gt;();res.add("a");res.add("b");Iterator it = res.iterator();while(it.hasNext())&#123; String s =(String) it.next(); if(s == "a")&#123; res.add("c"); &#125;&#125; 上面的代码都会出现下面的异常： 12345Exception in thread "main" java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909) at java.util.ArrayList$Itr.next(ArrayList.java:859) at offer.Solution38.Permutation(Solution38.java:25) at offer.Solution38.main(Solution38.java:35) 为什么会出现“并发修改异常”？源码分析首先我们看ArrayList类的源码，其iterator()方法为：123public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; 返回一个新建的Itr对象，源码如下：1Itr() &#123;&#125; 是个没有内容内部类，我们只能看看ArrayList的父类AbstractList有没有对应的内容：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private class Itr implements Iterator&lt;E&gt; &#123; /** * Index of element to be returned by subsequent call to next. */ int cursor = 0; /** * Index of element returned by most recent call to next or * previous. Reset to -1 if this element is deleted by a call * to remove. */ int lastRet = -1; /** * The modCount value that the iterator believes that the backing * List should have. If this expectation is violated, the iterator * has detected concurrent modification. */ int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size(); &#125; public E next() &#123; checkForComodification(); try &#123; int i = cursor; E next = get(i); lastRet = i; cursor = i + 1; return next; &#125; catch (IndexOutOfBoundsException e) &#123; checkForComodification(); throw new NoSuchElementException(); &#125; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; AbstractList.this.remove(lastRet); if (lastRet &lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException e) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; 是一个实现了Iterator接口的私有内部类。 分析它的hasNext()方法，会发现一个成员变量cursor。分析发现，这个变量表示下一个要访问元素的索引，当索引大于集合的size()后，则hasNext()=false。并且，next()方法返回的元素调用了get(cursor),而get()方法在ArrayList中为： 1234public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125; 而elementData就是用来存储ArrayList的Object数组。 什么时候会出现ConcurrentModificationException呢？ 我们发现了Itr类的两个方法remove()和checkForComodification()会抛出这个异常： 123456789101112131415public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; AbstractList.this.remove(lastRet); if (lastRet &lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException e) &#123; throw new ConcurrentModificationException(); &#125; &#125; 以及1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; 我们观察上面抛出异常的代码：12345678910ArrayList&lt;String&gt; res = new ArrayList&lt;&gt;();res.add(&quot;a&quot;);res.add(&quot;b&quot;);Iterator it = res.iterator();while(it.hasNext())&#123; String s =(String) it.next(); if(s == &quot;a&quot;)&#123; res.add(&quot;c&quot;); &#125;&#125; 首先在next()方法中会调用checkForComodification()方法，然后根据cursor的值获取到元素，接着将cursor的值赋给lastRet，并对cursor的值进行加1操作。初始时，cursor为0，lastRet为-1，那么调用一次之后，cursor的值为1，lastRet的值为0。注意此时，modCount为0，expectedModCount也为0。 随后，代码调用了res.add(“c”)。 查看源码，ArrayList的add()方法如下：12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; 再查看ensureCapacityInternal()的源码: 1234567891011private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; 我们发现了关键一行： 1modCount++; 此时，modCount为1，expectedModCount为0。 在调用next()方法时，执行checkForComodification()显然就会抛出ConcurrentModificationException()！1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; 终于解决了这个疑惑！ 结论 分析源码，在多线程程序中，如果有多个线程都在使用一个集合对象X，线程继续迭代，当A线程调用迭代器的next()方法时，发现modCount不等于expectedModCount，因此就抛出了ConcurrentModificationException异常。这可能就是它为什么叫并发修改异常的原因。从这一点也能说明ArrayList不是线程安全的。 简单来说，调用list.remove(),list.add()方法导致modCount和expectedModCount的值不一致。使用for-each进行迭代实际上也会出现这种问题。 解决办法一般有2种解决办法： (1)不使用迭代器遍历集合,就可以在遍历的时候使用集合的方法进行增加或删除 123456789ArrayList&lt;String&gt; res = new ArrayList&lt;&gt;();res.add("a");res.add("b");for (int i = 0; i &lt; res.size(); i++) &#123; if(res.get(i) == "a") res.add("c");&#125;System.out.println(res);return res; (2)依然使用迭代器遍历,那么就需要使用Iterator的子接口ListIterator来实现向集合中添加 1234567ListIterator lit = res.listIterator();while(lit.hasNext()) &#123; String s = (String)lit.next(); if(s.equals("a")) &#123; lit.add("c"); &#125;&#125; 其他解决同步问题的办法： (3)在使用iterator迭代的时候使用synchronized或者Lock进行同步； (4)使用并发容器CopyOnWriteArrayList代替ArrayList和Vector。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>Java容器</tag>
        <tag>Java源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的艺术-Java容器(1)之容器基础]]></title>
    <url>%2F2019%2F01%2F05%2FJava%E7%9A%84%E8%89%BA%E6%9C%AF-Java%E5%AE%B9%E5%99%A8(1)%E4%B9%8B%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[简要介绍JAVA容器。 Java容器是什么？ 容器，顾名思义，就是盛东西的地方。我们的程序中经常要管理大量的对象，比如在学校的信息管理系统里，每一个学生的相关信息，都可以抽象成一个对象；再比如在web server的场景下，一个客户端可以抽象成一个对象。这些情况下，都会产生很多同类型的对象，这时候，我们就会把同一个类型的对象放到同一个容器中进行集中管理。 Java的容器是前人为我们设计好的一套存储对象和数据的一套轮子，通过使用Java中写好的容器API我们可以很方便的存储、操作我们的数据。 容器的作用：Java容器类库是用来保存对象的，他有两种不同的概念：（1）Collection，独立元素的序列，这些元素都服从一条或多条规则。List、Set以及Queue都是Collection的一种，List必须按照顺序保存元素，而Set不能有重复元素，Queue需要按照排队规则来确定对象的顺序。（2）Map，Map是键值对类型，允许用户通过键来查找对象。Hash表允许我们使用另一个对象来查找某个对象。 为什么需要容器呢？《thinking in java》书中说：“如果一个程序只包含固定数量的且生命周期都已知的对象，那么这是一个非常简单的数据。”但是事实上，我们平时接触的程序都不是如此简单的，很多程序都是在运行时才知道需要创建什么对象、创建多少对象，因此很可能我们需要在任意时刻任意位置创建任意数量的对象。因此，不能依靠创建命名的引用持有每一个对象，因为不确定性，我们必须要动态的创建对象，保存对象（其实是对象的引用）。 Java常见容器Java完整容器类结构 详细结构及概述结构Collection接口 ├List接口 │├LinkedList 双向链表，顺序访问，快速增删，栈、队列、双向队列 │├ArrayList 顺序结构动态数组实现，随机访问 │└Vector 向量 │└Stack 栈 ├Set接口 │├TreeSet 红黑树实现，有序，查找O(logN) │├HashSet 哈希表实现，无序，查找O(1) │└LinkedHashSet ├Queue接口 │├PriorityQueue 堆实现，可实现优先队列 │└LinkedList 双向链表，顺序访问，快速增删，栈、队列、双向队列Map接口 ├HashMap 哈希表实现，线程不安全 ├Hashtable 线程安全，现为ConcurrentHashMap替换，分段锁 ├LinkedHashMap 双向链表实现 ├TreeMap 红黑树实现 ├WeakHashMap └IdentityHashMap 一句话概括常用不同容器类 1.Set1.1 TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。1.2 HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。1.3 LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。 2.List2.1 ArrayList：基于动态数组实现，支持随机访问。2.2 Vector：和 ArrayList 类似，但它是线程安全的。2.3 LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。 3.Queue3.1 LinkedList：可以用它来实现双向队列。3.2 PriorityQueue：基于堆结构实现，可以用它来实现优先队列。 4.Map4.1 TreeMap：基于红黑树实现。4.2 HashMap：基于哈希表实现。4.3 HashTable：和 HashMap类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用ConcurrentHashMap 来支持线程安全，并且ConcurrentHashMap 的效率会更高，因为ConcurrentHashMap引入了分段锁。4.4 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（ LRU） 顺序。 接下来，详细比较不同容器的区别和联系！ 顶层接口-Collections接口Collection是序列容器的顶级接口，这个interface定义了序列容器必须实现的所有成员方法。 常用方法包括：容器容量，判断是否为空，检查容器元素，迭代器，增删等操作。 12345678910public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123; int size(); boolean isEmpty(); boolean contains(Object o); Iterator&lt;E&gt; iterator(); Object[] toArray(); boolean add(E e); boolean remove(Object o); boolean containsAll(Collection&lt;?&gt; c);&#125; List接口及常用实现类总结 实现List接口的常用类有LinkedList，ArrayList，Vector和Stack。 LinkedList、ArrayList都实现了List接口，都是不同步的，线程不安全，元素是有序的、可重复。 一般情况下使用LinkedList、ArrayList这两个就可以了，因为非同步，所以效率比较高。 ArrayList的随机访问效率较好，但是插入、删除元素较慢；LinkedList提供了优化的顺序访问，随机访问逊色于ArrayList，但插入、删除的代价较低。 总之，如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。 LinkedList 基于双向链表的数据结构，允许null元素，增加、删除、修改元素方面效率比ArrayList高。 LinkedList提供额外的get，remove，insert方法在 LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。 注意:LinkedList没有同步方法。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：List list = Collections.synchronizedList(new LinkedList(…)); ArrayList概述 基于顺序结构的动态数组的数据结构，不同步，线程不安全，查询（get，set）效率高。 size()，isEmpty()，get()，set()方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。 Array和ArrayList的区别及各自适用的场景： Array是数组，ArrayList是Array的加强版。 （1）array可以保存基本类型和对象类型，arrayList只能保存对象类型 （2）array数组的大小是固定的不能更改，而ArrayList的大小可以改变 （3）Array数组在存放的时候一定是同种类型的元素。ArrayList就不一定了，因为ArrayList可以存储Object。 （4）ArrayList有更加丰富的方法如addAll（）、removeAll()、iterator() 适用场景：如果想要保存一些在整个程序运行期间都会存在而且不变的数据，我们可以将它们放进一个全局数组里，但是如果我们单纯只是想要以数组的形式保存数据，而不对数据进行增加等操作，只是方便我们进行查找的话，那么，我们就选择ArrayList。 如果我们需要对元素进行频繁的移动或删除，或者是处理的是超大量的数据，那么，使用ArrayList就真的不是一个好的选择，因为它的效率很低，使用数组进行这样的动作就很麻烦，那么，我们可以考虑选择LinkedList。 Vector概述 Vector类似ArrayList，但是Vector是线程同步的。由Vector创建的Iterator，虽然和ArrayList创建的 Iterator是同一接口，但是，因为Vector是同步的，当一个Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出ConcurrentModificationException，因此必须捕获该异常。 Stack Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop方法，还有 peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。 Set接口及常用实现类概述 Set容器类主要有HashSet和TreeSet等。元素不重复。 HashSet概述 允许包含值为null的元素，但最多只能有一个null元素。 基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。 TreeSet TreeSet基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 LinkedHashSet LinkedHashSet的实现借助LinkedHashMap使用适配器模式实现的。具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。 Map接口及常用实现类总结 Map没有继承Collection接口，Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个value。Map接口提供3种集合的视图，Map的内容可以被当作一组key集合，一组value集合，或者一组key-value映射。 主要方法： 123boolean equals(Object o)//比较对象boolean remove(Object o)//删除一个对象put(Object key,Object value)//添加key和value TreeMapTreeMap 和 TreeSetTreeSet是借助TreeMap实现的的适配器模式的体现。TreeMap懂了TreeSet也了解了，TreeMap实现了SortedMap接口，会根据key的大小对Map中的元素进行排序。key的大小判断在没有传入比较器Comparator的情况下通过自身的自然顺序比较。TreeMap底层通过红黑树实现 红黑树是一颗近似平衡的二叉查找树，任何一个节点的左右子树高度差不会超过二者中较低的那个的一倍，TreeMap的每个节点即为一个键值对，红黑树的特性如下：1234567(1)每个节点要么是黑色，要么是红色(2)根节点必须为黑色(3)红色节点不能连续，即红色节点的孩子和父亲只能是黑色(4)任何节点到树的末端的任何路径包含的黑色节点个数相同(5)每次对红黑树操作后都要使其满足上述条件，调整红黑树的策略主要是： - 改变节点颜色； - 改变树的结构（左旋操作、右旋操作） HashMapHashTable和HashMap 第一、继承不同。 12 public class Hashtable extends Dictionary implements Map public class HashMap extends AbstractMap implements Map 第二、Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。 第三、Hashtable中，key和value都不允许出现null值。在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。 第四、两个遍历方式的内部实现上不同。Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。 第五、哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。 LinkedHashMapLinkedHashMap实现了Map接口，即允许放入key为null的元素，也允许插入value为null的元素。从名字上可以看出该容器是linked list和HashMap的混合体，也就是说它同时满足HashMap和linked list的某些特性。可将LinkedHashMap看作采用LinkedList增强的HashMap。 LinkedHashMap 和 LinkedHashSet: LinkedHashSet和LinkedHashMap在Java里也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说LinkedHashSet里面有一个LinkedHashMap（适配器模式）。 LinkedHashMap是HashMap的子类，二者唯一的区别是LinkedHashMap在HashMap的基础上，采用双向链表（doubly-linkedlist）的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同。上图给出了LinkedHashMap的结构图，主体部分跟HashMap完全一样，多了header指向双向链表的头部（是一个哑元），该双向链表的迭代顺序就是entry的插入顺序。 LinkedHashMap在遍历的时候不同于HashMap需要先遍历整个table，LinkedHashMap只需要遍历header指向的双向链表即可，因此LinkedHashMap的迭代时间只和entry数量相关。其他的包括初始容量、负载因子以及hashCode、equals方法基本和HashMap一致。 WeakHashMap WeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。 ConcurrentHashMap HashMap不是线程安全的，HashTable是线程安全的，但是其安全性由全局锁保证，因此效率很低。而ConcurrentHashMap 是将锁的范围细化来实现高效并发的。 基本策略是将数据结构分为一个一个 Segment（每一个都是一个并发可读的 hash table， 即分段锁）作为一个并发单元。 为了减少开销， 除了一处 Segment 是在构造器初始化的， 其他都延迟初始化。 并使用 volatile 关键字来保证 Segment 延迟初始化的可见性问题。 jdk1.8对ConcurrentHashMap做了一些改进： 改进一：取消segments字段，直接采用transient volatile HashEntry&lt; K,V&gt;[] table保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。 改进二：将原先table数组＋单向链表的数据结构，变更为table数组＋单向链表＋红黑树的结构。在冲突链表长度过长的情况，如果还是采用单向链表方式，那么查询某个节点的时间复杂度为O(n)；因此，对于个数超过8(默认值)的列表，jdk1.8中采用了红黑树的结构，那么查询的时间复杂度可以降低到O(logN)，可以改进性能。 容器的遍历迭代器模式Collection 实现了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。1234Iterator it = container.iterator();while(it.hasNext()) &#123; Object obj = it.next();&#125; List遍历主要有三种：第一种：迭代器+for1234for(Iterator iterator = list.iterator();iterator.hasNext();)&#123; int i = (Integer) iterator.next(); System.out.println(i); &#125; 第二种：迭代器12345Iterator iterator = list.iterator();while(iterator.hasNext())&#123; int i = (Integer) iterator.next();//注意next()返回的是Object对象！！ System.out.println(i);&#125; 第三种：增强for123for (Object object : list) &#123; System.out.println(object);&#125; 第四种：普通for1234for(int i = 0 ;i&lt;list.size();i++) &#123; int j= (Integer) list.get(i); System.out.println(j); &#125; Map遍历有四种： 第一种：通过获取所有的key按照key来遍历1234//Set&lt;Integer&gt; set = map.keySet(); //得到所有key的集合for (Integer in : map.keySet()) &#123; String str = map.get(in);//得到每个key多对用value的值&#125; 第二种：通过Map.entrySet使用iterator遍历key和value12345Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = map.entrySet().iterator();while (it.hasNext()) &#123; Map.Entry&lt;Integer, String&gt; entry = it.next(); System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());&#125; 注意，用迭代器遍历Map时，Map没有iterator()方法，所以需要用entrySet()得到Set对象，再调用iterator()得到迭代器对象。 第三种：通过Map.entrySet遍历key和value，推荐，尤其是容量大时123456for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123; //Map.entry&lt;Integer,String&gt; 映射项（键-值对） 有几个方法：用上面的名字entry //entry.getKey() ;entry.getValue(); entry.setValue(); //map.entrySet() 返回此映射中包含的映射关系的 Set视图。 System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());&#125; 第四种：通过Map.values()遍历所有的value，但不能遍历key123for (String v : map.values()) &#123; System.out.println("value= " + v);&#125; 概述Java的容器类，有时间再补充详细的源码解析。 参考：Java常见的容器类及其区别Java中的容器一份涵盖大部分Java程序员所需要掌握的核心知识深入整理java集合容器Github]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>Java容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式(1)-单例模式]]></title>
    <url>%2F2019%2F01%2F05%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(1)-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[本文详细介绍单例模式的特点和8种实现方式。 常见的设计模式共有23种，本文介绍-单例模式。 概述 单例模式是一种常用的软件设计模式。通过单例模式可以保证系统中，应用该模式的一个类只有一个实例。其定义是单例对象的类只能允许一个实例存在。 单例模式特点：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。 需要注意的问题：一是线程安全；二是资源使用。 作用 对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID(序号)生成器。如在Windows中就只能打开一个任务管理器。如果不使用机制对窗口对象进行唯一化，将弹出多个窗口，如果这些窗口显示的内容完全一致，则是重复对象，浪费内存资源；如果这些窗口显示的内容不一致，则意味着在某一瞬间系统有多个状态，与实际不符，也会给用户带来误解，不知道哪一个才是真实的状态。因此有时确保系统中某个对象的唯一性即一个类只能有一个实例非常重要。 适用场景： 需要频繁的进行创建和销毁的对象； 创建对象时耗时过多或耗费资源过多，但又经常用到的对象； 工具类对象； 频繁访问数据库或文件的对象。 实现单例模式的八种方法1.饿汉式(2种)123456789101112/*饿汉式1：静态常量：实例在未调用前就创建，且不会再次创建。*/public class Singleton1 &#123; private final static Singleton1 instance = new Singleton1() ; private Singleton1()&#123; &#125; public static Singleton1 getInstance()&#123; return instance ; &#125;&#125; 123456789101112131415/*饿汉式2：静态代码块：实例在未调用前就创建，且不会再次创建。*/public class Singleton1 &#123; private static Singleton1 instance; static&#123; instance = new Singleton1(); &#125; private Singleton1()&#123; &#125; public static Singleton1 getInstance()&#123; return instance ; &#125;&#125; 缺点：因为没有调用就创建了实例，所以容易造成资源浪费。 2.懒汉式1234567891011121314/*在调用时判断实例是否已经创建。*/public class Singleton2 &#123; private static Singleton2 instance ; private Singleton2()&#123; &#125; public static Singleton2 get()&#123; if ( instance == null ) &#123; instance = new Singleton2() ; &#125; return instance ; &#125;&#125; 缺点：线程不安全，多线程中可能出现多个实例。 3. 利用synchronized关键字1234567891011121314/*在调用时判断实例是否已经创建,同时方法块加synchronized锁。*/public class Singleton3 &#123; private static Singleton3 instance ; private Singleton3()&#123; &#125; public synchronized static Singleton3 get()&#123; if ( instance == null ) &#123; instance = new Singleton3() ; &#125; return instance ; &#125;&#125; 缺点：经过synchronized修饰的方法和代码块速度很慢，多次调用时性能很低。 4. 双重校验提高性能（常用）123456789101112131415161718/*在调用时判断实例是否已经创建,不存在时再加锁创建对象，避免同时创建多个对象。*/public class Singleton4 &#123; private static Singleton4 instance ; private Singleton4()&#123; &#125; public static Singleton4 get()&#123; if ( instance == null ) &#123; synchronized(Singleton4.class)&#123; if(instance == null)&#123; instance = new Singleton4(); &#125; &#125; &#125; return instance ; &#125;&#125; 缺点：第一次加载时反应不快，由于java内存模型一些原因偶尔失败。假设两个线程A、B，都是第一次调用该单例方法，线程A先执行instance = new Singleton4()，该构造方法是一个非原子操作，编译后生成多条字节码指令，由于JAVA的指令重排序，可能会先执行 instance 的赋值操作，该操作实际只是在内存中开辟一片存储对象的区域后直接返回内存的引用，之后 instance便不为空了，但是实际的初始化操作却还没有执行，如果就在此时线程B进入，就会看到一个不为空的但是不完整 （没有完成初始化）的instance对象。 5. volatile关键字，解决双重校验的弊端（常用）123456789101112131415161718/*加入volatile关键字，禁止指令重排序优化，从而安全的实现单例。*/public class Singleton5 &#123; private static volatile Singleton5 instance = null; private Singleton5()&#123; &#125; public static Singleton5 get()&#123; if ( instance == null ) &#123; synchronized(Singleton5.class)&#123; if(instance == null)&#123; instance = new Singleton5(); &#125; &#125; &#125; return instance ; &#125;&#125; 加入volatile关键字，禁止指令重排序优化，从而安全的实现单例。 6. 静态内部类（常用）12345678910111213141516/*避免了线程不安全，延迟加载，效率高。*/public class Singleton6 &#123; private Singleton6()&#123; &#125; private static class SingleLetonHolder&#123; /** * 静态初始化器，由JVM来保证线程安全 */ private static Singleton6 instance = new Singleton6(); &#125; public staic Singleton6 get()&#123; return SingleLetonHolder.instance; &#125;&#125; 相比饿汉式只要Singleton类被装载就会实例化，没有Lazy-Loading的作用；静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用get()方法，才会装载SingleLetonHolder类，从而完成Singleton的实例化。 7. 枚举类实现(JDK1.5后)1234567891011/** * 能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。 */public enum Singleton7&#123; INSTANCE; public void otherMethod()&#123; /** * 可以用任何方法。 */ &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[keras模型拼接]]></title>
    <url>%2F2018%2F12%2F25%2Fkeras%E6%A8%A1%E5%9E%8B%E6%8B%BC%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[在模型测试过程中，如何让两个模型中间层的输入输出拼在一起呢？ 首先，加载训练好的模型后，我们可以用下面的方式获取模型的中间层输出：12model = load_model(&quot;model1.h5&quot;)First_model = Model(inputs=model.input, outputs=model.layers[7].output)#表示获取模型第7层的输出 然后如何把第7层的输出，作为下一个模型中间层的输入呢？用下面的方法是不可以的：12model2 = load_model(&quot;model2.h5&quot;)second_model = Model(inputs=model2.layers[8].input, outputs=model2.layers[-1].output) 这样会得到类似下面的错误：1RuntimeError: Graph disconnected: cannot obtain value for tensor Tensor(&quot;conv2d_1_input:0&quot;, shape=(?, 144, 144, 3), dtype=float32) at layer &quot;conv2d_1_input&quot;. The following previous layers were accessed without issue: [] 解决办法是声明一个新的Input Layer,用下面的方式拼接：12345second_input = Input(model.layers[8].input_shape[1:])second_model = second_inputfor layer in model.layers[8:]: second_model = layer(second_model)second_model = Model(inputs=second_input, outputs=second_model) 由此，便完成了模型的拼接！]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>keras</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库(3)-JDBC]]></title>
    <url>%2F2018%2F12%2F07%2F%E6%95%B0%E6%8D%AE%E5%BA%93(3)-JDBC%2F</url>
    <content type="text"><![CDATA[JAVA数据库连接JDBC、以及DAO模式的使用。 JDBC概述Java 数据库连接，（Java Database Connectivity，简称JDBC）是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。JDBC也是Sun Microsystems的商标。它JDBC是面向关系型数据库的。即用于执行SQL语句的JAVA API。 一、安装和配置直接按照教程，话不多说。MySQL安装图解 二、下载数据库对应的jar包 （1）在MySQL官网页面,选择对应系统的文件。如果是windows系统，选择Platform Independent对应的jar包即可。 （2）复制mysql-connector-java-8.0.15.jar包到你的\jre1.8.0_181\lib\ext文件夹下。 三、JDBC基本操作(1)使用的基本步骤 a.注册驱动12345DriverManager.registerDriver(new com.mysql.jdbc.Driver());//上面这种方法相当于注册两次驱动，因此没有必要，最好用下面这种代码：Class.forName("com.mysql.jdbc.Driver");//上面已经deprecatedClass.forName("com.mysql.cj.jdbc.Driver"); b.建立连接1234//1. 一个参数，用&amp;隔开DriverManager.getConnection("jdbc:mysql://localhost/database_name?user=user&amp;password=password");//2. 建立连接 参数一： 协议 + 访问的数据库 ， 参数二： 用户名 ， 参数三： 密码。conn = DriverManager.getConnection("jdbc:mysql://localhost/database_name", "user", "password"); c.创建statement12//3. 创建statement对象 ，很重要的一个类st = conn.createStatement(); d.执行sql ，得到ResultSet123//4. 执行查询 ， 得到结果集String sql = "select * from table_name";rs = st.executeQuery(sql); e.遍历结果集1234567//5. 遍历查询每一条记录while(rs.next())&#123; int id = rs.getInt("id"); String name = rs.getString("name"); int age = rs.getInt("age"); System.out.println("id="+id + "===name="+name+"==age="+age);&#125; f.释放资源123456if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException sqlEx) &#123; &#125; rs = null;&#125; (2)JDBC数据库CURD对应的SQL语句 通过代码示例了解如何通过JDBC对数据库进行增删改查的任务。 A. Insert1234567891011121314// 1. 获取连接对象conn = JDBCUtil.getConn();// 2. 根据连接对象，得到statement对象st = conn.createStatement();// 3. 执行添加String sql = "insert into t_stu values(null , 'wufan' , 99)";//返回影响的行数，如果大于0表明操作成功。否则失败int result = st.executeUpdate(sql);if(result &gt;0 )&#123; System.out.println("添加成功");&#125;else&#123; System.out.println("添加失败");&#125; B. Delete1234567891011121314// 1. 获取连接对象conn = JDBCUtil.getConn();// 2. 根据连接对象，得到statementst = conn.createStatement();// 3. 执行删除String sql = "delete from t_stu where name='wufan'";//返回影响的行数，如果大于0表明操作成功。否则失败int result = st.executeUpdate(sql);if(result &gt;0 )&#123; System.out.println("删除成功");&#125;else&#123; System.out.println("删除失败");&#125; C. Query1234567891011121314// 1. 获取连接对象conn = JDBCUtil.getConn();// 2. 根据连接对象，得到statementst = conn.createStatement();// 3. 执行返回ResultSet.String sql = "select * from t_stu";rs = st.executeQuery(sql);// 4. 遍历结果集while (rs.next()) &#123; String name = rs.getString("name"); int age = rs.getInt("age"); System.out.println(name + " " + age);&#125; D. Update1234567891011121314// 1. 获取连接对象conn = JDBCUtil.getConn();// 2. 根据连接对象，得到statementst = conn.createStatement();// 3. 执行更新String sql = "update t_stu set age = 16 where name ='wufan'";//返回影响的行数，如果大于0表明操作成功。否则失败int result = st.executeUpdate(sql);if(result &gt;0 )&#123; System.out.println("删除成功");&#125;else&#123; System.out.println("删除失败");&#125; 四、使用properties配置文件(1)关于Properties 在JDBC中，Properties()是一种很方便的方法，不需要将url、user、password、driverClass写在代码方法中，而是写入配置文件，并通过调用配置文件实现。 (2)使用properties链接数据库 1.在src声明一个配置文件XXX.properties，内容如下： 1234driverClass=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/database?useUnicode=true&amp;characterEncoding=utf8username=rootpassword=root 2.在工具类中，使用静态代码块读取属性。12345678910111213141516171819202122232425private static String driverClass;private static String url;private static String name;private static String password;static&#123; try &#123; //1. 创建一个属性配置对象 Properties properties = new Properties(); InputStream is = new FileInputStream("jdbc.properties"); //对应文件位于工程根目录 //方法1：使用当前类加载器，读取src底下的资源文件。 //InputStream is = JDBCUtil.class.getClassLoader().getResourceAsStream("jdbc.properties"); //方法2：导入输入流。 properties.load(is); //读取属性 driverClass = properties.getProperty("driverClass"); url = properties.getProperty("url"); name = properties.getProperty("name"); password = properties.getProperty("password"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 获取连接：12345678910public static Connection getConnection() &#123; Connection conn = null; try &#123; Class.forName(driverClass); conn = DriverManager.getConnection(url, username, password); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return conn; &#125; 释放资源：123456789101112131415161718192021222324public static void release(Connection conn, PreparedStatement pstmt, ResultSet rs) &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (pstmt != null) &#123; try &#123; pstmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 可以发现，这种方式能降低代码维护成本，解决了数据库更换的麻烦。 五、DAO模式 DAO: Data Access Object 数据访问对象 作用(1).隔离业务逻辑代码和数据访问代码,位于业务逻辑和持久化数据之间，实现对持久化数据的访问。(2).隔离不同数据库的实现。 组成部分(1).DAO接口(2).DAO实现类(3).实体类(4).数据库连接和关闭工具类 直接上代码(1).DAO接口12345package jdbc;public interface DAO &#123; void findeAll();&#125; (2).DAO实现类(实体类略去)123456789101112131415161718192021222324252627282930313233343536373839404142package jdbc;import java.sql.Connection;import java.sql.ResultSet;import java.sql.Statement;/** * @Author: wufan */public class UerDao implements DAO &#123; @Override public void findeAll() &#123; Connection conn = null; Statement st = null; ResultSet rs = null; try &#123; //1. 获取连接对象 conn = JDBCUtil.getConnection(); //2. 创建statement对象 st = conn.createStatement(); String sql = "select * from user"; rs = st.executeQuery(sql); while(rs.next())&#123; String phone = rs.getString("phone"); int id = rs.getInt("uid"); System.out.print(id+"\t"+phone); System.out.println(""); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUtil.release(conn, st, rs); &#125; &#125; public static void main(String[] args) &#123; UerDao ud = new UerDao(); ud.findeAll(); &#125;&#125; (4).数据库连接和关闭工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package jdbc;import java.io.FileInputStream;import java.io.InputStream;import java.sql.*;import java.util.Properties;/** * @Author: wufan */public class JDBCUtil &#123; private static String driverClass; private static String url; private static String username; private static String password; static&#123; try &#123; Properties properties = new Properties(); //InputStream is = JDBCUtil.class.getClassLoader().getResourceAsStream("JDBC.properties"); InputStream is = new FileInputStream("P:\\Java\\Database\\src\\JDBC.properties"); //对应文件位于工程根目录 properties.load(is); driverClass = properties.getProperty("driverClass"); url = properties.getProperty("url"); username = properties.getProperty("username"); password = properties.getProperty("password"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //获取连接 public static Connection getConnection() &#123; Connection conn = null; try &#123; Class.forName(driverClass); conn = DriverManager.getConnection(url, username, password); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return conn; &#125; //释放资源 public static void release(Connection conn, Statement pstmt, ResultSet rs) &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (pstmt != null) &#123; try &#123; pstmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 六、PrepareStatement 在需要传入参数的SQL语句中，替换Statement对象。 相比较以前的Statemen， 预先处理给定的sql语句，对其执行语法检查。 在sql语句里面使用?占位符来替代后续要传递进来的变量。后面进来的变量值，将会被看成是字符串，不会产生任何的关键字。12345678String sql = "insert into table_name values(? , ? , ?)";PrepareStatement ps = conn.prepareStatement(sql);//给占位符赋值//注意从左到右数过来，1 代表第一个问号， 永远从1开始。ps.setInt(1,id);ps.setString(2, userName);ps.setString(3, phone); PreparedStatement 和 Statement比较 A.PreparedStatement 尽最大可能提高性能sql 语句被数据库的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。PreparedStatement 会先初始化SQL，先把这个SQL提交到数据库中进行预处理，并缓存下来，多次使用可提高效率。如果仅仅执行了一次的话，和普通的对象差别不大，体现不出它预编译的优越性。Statement不会初始化，没有预处理，每次都是从0开始执行SQL。 B.极大地提高了安全性，防止SQL注入式攻击在使用参数化查询的情况下，数据库系统不会将参数的内容视为 SQL 指令的一部分来处理，而是在数据库完成 SQL 指令的编译后，才套用参数运行，因此就算参数中含有破坏性的指令，也不会被数据库所运行。 C.代码的可读性和可维护性更强 七、遇到的错误 (1)time zone错误123SQLException: The server time zone value &apos;ÖÐ¹ú±ê×¼Ê±¼ä&apos; is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.SQLState: 01S00VendorError: 0 这是由于数据库和系统时区差异所造成的，简单的方法是再url后面加上1serverTimezone=GMT 比如：1Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost/database_name?&quot;+&quot;user=root&amp;password=root&quot;+&quot;&amp;serverTimezone=GMT&quot;); (2) java.io.FileNotFoundException: JDBC.properties (系统找不到指定的文件。)解决办法1：使用类加载1InputStream is = JDBCUtil.class.getClassLoader().getResourceAsStream("JDBC.properties"); 办法2：改用全路径1InputStream is = new FileInputStream("P:\\Java\\Database\\src\\JDBC.properties"); 参考链接：1.mysql-8.0.13使用jdbc与java连接教程2.通过JDBC进行简单的增删改查（以MySQL为例）3.《高性能MySQL》]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的艺术-Java技术栈]]></title>
    <url>%2F2018%2F12%2F05%2FJava%E7%9A%84%E8%89%BA%E6%9C%AF-Java%E6%8A%80%E6%9C%AF%E6%A0%88%2F</url>
    <content type="text"><![CDATA[当学Java迷茫的时候，不妨看看，激励一下自己！ 基础篇面向对象→ 什么是面向对象面向对象、面向过程面向对象的三大基本特征和五大基本原则→ 平台无关性Java 如何实现的平台无关JVM 还支持哪些语言（Kotlin、Groovy、JRuby、Jython、Scala）→ 值传递值传递、引用传递为什么说 Java 中只有值传递→ 封装、继承、多态什么是多态、方法重写与重载Java 的继承与实现构造函数与默认构造函数类变量、成员变量和局部变量成员变量和方法作用域 Java 基础知识→ 基本数据类型8 种基本数据类型：整型、浮点型、布尔型、字符型整型中 byte、short、int、long 的取值范围什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？→ 自动拆装箱什么是包装类型、什么是基本类型、什么是自动拆装箱Integer 的缓存机制→ String字符串的不可变性JDK 6 和 JDK 7 中 substring 的原理及区别、replaceFirst、replaceAll、replace 区别、String 对“+”的重载、字符串拼接的几种方式和区别String.valueOf 和 Integer.toString 的区别、switch 对 String 的支持字符串池、常量池（运行时常量池、Class 常量池）、intern→ 熟悉 Java 中各种关键字transient、instanceof、final、static、volatile、synchronized、const 原理及用法→ 集合类常用集合类的使用、ArrayList 和 LinkedList 和 Vector 的区别 、SynchronizedList 和 Vector 的区别、HashMap、HashTable、ConcurrentHashMap 区别、Set 和 List 区别？Set 如何保证元素不重复？Java 8 中 stream 相关用法、apache 集合处理工具类的使用、不同版本的 JDK 中 HashMap 的实现的区别以及原因Collection 和 Collections 区别Arrays.asList 获得的 List 使用时需要注意什么Enumeration 和 Iterator 区别fail-fast 和 fail-safeCopyOnWriteArrayList、ConcurrentSkipListMap→ 枚举枚举的用法、枚举的实现、枚举与单例、Enum 类Java 枚举如何比较switch 对枚举的支持枚举的序列化如何实现枚举的线程安全性问题→ IO字符流、字节流、输入流、输出流、同步、异步、阻塞、非阻塞、Linux 5 种 IO 模型BIO、NIO 和 AIO 的区别、三种 IO 的用法与原理、netty→ 反射反射与工厂模式、反射有什么用Class 类、java.lang.reflect.→ 动态代理静态代理、动态代理动态代理和反射的关系动态代理的几种实现方式AOP*→ 序列化什么是序列化与反序列化、为什么序列化、序列化底层原理、序列化与单例模式、protobuf、为什么说序列化并不安全 → 注解元注解、自定义注解、Java 中常用注解使用、注解与反射的结合Spring 常用注解→ JMS什么是 Java 消息服务、JMS 消息传送模型→ JMXjava.lang.management.、 javax.management.→ 泛型泛型与继承、类型擦除、泛型中 KTVE? object 等的含义、泛型各种用法限定通配符和非限定通配符、上下界限定符 extends 和 superList 和原始类型 List 之间的区别?List&lt;?&gt; 和 List 之间的区别是什么?→ 单元测试junit、mock、mockito、内存数据库（h2）→ 正则表达式java.lang.util.regex.→ 常用的 Java 工具库commons.lang、commons.…、 guava-libraries、 netty→ API &amp; SPIAPI、API 和 SPI 的关系和区别如何定义 SPI、SPI 的实现原理→ 异常异常类型、正确处理异常、自定义异常Error 和 Exception异常链、try-with-resourcesfinally 和 return 的执行顺序→ 时间处理时区、冬令时和夏令时、时间戳、Java 中时间 API格林威治时间、CET,UTC,GMT,CST 几种常见时间的含义和关系SimpleDateFormat 的线程安全性问题Java 8 中的时间处理如何在东八区的计算机上获取美国时间→ 编码方式Unicode、有了 Unicode 为啥还需要 UTF-8GBK、GB2312、GB18030 之间的区别UTF8、UTF16、UTF32 区别URL 编解码、Big Endian 和 Little Endian如何解决乱码问题→ 语法糖Java 中语法糖原理、解语法糖语法糖：switch 支持 String 与枚举、泛型、自动装箱与拆箱、方法变长参数、枚举、内部类、条件编译、 断言、数值字面量、for-each、try-with-resource、Lambda 表达式 阅读源代码String、Integer、Long、Enum、BigDecimal、ThreadLocal、ClassLoader &amp; URLClassLoader、ArrayList &amp; LinkedList、HashMap &amp; LinkedHashMap &amp; TreeMap &amp; CouncurrentHashMap、HashSet &amp; LinkedHashSet &amp; TreeSet Java 并发编程→ 并发与并行什么是并发、什么是并行并发与并行的区别→ 什么是线程，与进程的区别线程的实现、线程的状态、优先级、线程调度、创建线程的多种方式、守护线程线程与进程的区别→ 线程池自己设计线程池、submit() 和 execute()、线程池原理为什么不允许使用 Executors 创建线程池→ 线程安全死锁、死锁如何排查、线程安全和内存模型的关系→ 锁CAS、乐观锁与悲观锁、数据库相关锁机制、分布式锁、偏向锁、轻量级锁、重量级锁、monitor、锁优化、锁消除、锁粗化、自旋锁、可重入锁、阻塞锁、死锁→ 死锁什么是死锁死锁如何解决→ synchronizedsynchronized 是如何实现的？synchronized 和 lock 之间关系、不使用 synchronized 如何实现一个线程安全的单例synchronized 和原子性、可见性和有序性之间的关系→ volatilehappens-before、内存屏障、编译器指令重排和 CPU 指令重volatile 的实现原理volatile 和原子性、可见性和有序性之间的关系有了 symchronized 为什么还需要 volatile→ sleep 和 wait→ wait 和 notify→ notify 和 notifyAll→ ThreadLocal→ 写一个死锁的程序→ 写代码来解决生产者消费者问题→ 并方包Thread、Runnable、Callable、ReentrantLock、ReentrantReadWriteLock、Atomic*、Semaphore、CountDownLatch、ConcurrentHashMap、Executors 底层篇JVM→ JVM 内存结构class 文件格式、运行时数据区：堆、栈、方法区、直接内存、运行时常量池、堆和栈区别Java 中的对象一定在堆上分配吗？ → Java 内存模型计算机内存模型、缓存一致性、MESI 协议可见性、原子性、顺序性、happens-before、内存屏障、synchronized、volatile、final、锁→ 垃圾回收GC 算法：标记清除、引用计数、复制、标记压缩、分代回收、增量式回收GC 参数、对象存活的判定、垃圾收集器（CMS、G1、ZGC、Epsilon）→ JVM 参数及调优-Xmx、-Xmn、-Xms、Xss、-XX:SurvivorRatio、-XX:PermSize、-XX:MaxPermSize、-XX:MaxTenuringThreshold→ Java 对象模型oop-klass、对象头→ HotSpot即时编译器、编译优化→ 虚拟机性能监控与故障处理工具jps, jstack, jmap, jstat, jconsole, jinfo, jhat, javap, btrace, TProfilerArthas 类加载机制classLoader、类加载过程、双亲委派（破坏双亲委派）、模块化（jboss modules、osgi、jigsaw） 编译与反编译什么是编译（前端编译、后端编译）、什么是反编译JIT、JIT 优化（逃逸分析、栈上分配、标量替换、锁优化）编译工具：javac反编译工具：javap 、jad 、CRF 进阶篇Java 底层知识→ 字节码、class 文件格式→ CPU 缓存，L1，L2，L3 和伪共享→ 尾递归→ 位运算用位运算实现加、减、乘、除、取余 设计模式设计模式的六大原则：开闭原则（Open Close Principle）、里氏代换原则（Liskov Substitution Principle）、依赖倒转原则（Dependence Inversion Principle）接口隔离原则（Interface Segregation Principle）、迪米特法则（最少知道原则）（Demeter Principle）、合成复用原则（Composite Reuse Principle）→ 了解 23 种设计模式创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter 模式）、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。→ 会使用常用设计模式单例的七种写法：懒汉——线程不安全、懒汉——线程安全、饿汉、饿汉——变种、静态内部类、枚举、双重校验锁工厂模式、适配器模式、策略模式、模板方法模式、观察者模式、外观模式、代理模式等必会→ 不用 synchronized 和 lock，实现线程安全的单例模式→ 实现 AOP→ 实现 IOC→ nio 和 reactor 设计模式 网络编程知识→ tcp、udp、http、https 等常用协议三次握手与四次关闭、流量控制和拥塞控制、OSI 七层模型、tcp 粘包与拆包→ http/1.0 http/1.1 http/2 之前的区别http 中 get 和 post 区别常见的 web 请求返回的状态码404、302、301、500分别代表什么→ http/3→ Java RMI，Socket，HttpClient→ cookie 与 sessioncookie 被禁用，如何实现 session→ 用 Java 写一个简单的静态文件的 HTTP 服务器→ 了解 nginx 和 apache 服务器的特性并搭建一个对应的服务器→ 用 Java 实现 FTP、SMTP 协议→ 进程间通讯的方式→ 什么是 CDN？如果实现？→ DNS什么是 DNS 、记录类型: A 记录、CNAME 记录、AAAA 记录等域名解析、根域名服务器DNS 污染、DNS 劫持、公共 DNS：114 DNS、Google DNS、OpenDNS→ 反向代理正向代理、反向代理反向代理服务器 框架知识→ Servlet生命周期线程安全问题filter 和 listenerweb.xml 中常用配置及作用→ Hibernate什么是 OR MappingHibernate 的懒加载Hibernate 的缓存机制Hibernate / Ibatis / MyBatis 之间的区别→ SpringBean 的初始化AOP 原理实现 Spring 的IOCSpring 四种依赖注入方式→ Spring MVC什么是 MVCSpring mvc 与 Struts mvc 的区别→ Spring BootSpring Boot 2.0、起步依赖、自动配置、Spring Boot 的 starter 原理，自己实现一个 starter→ Spring Security→ Spring Cloud服务发现与注册：Eureka、Zookeeper、Consul负载均衡：Feign、Spring Cloud Loadbalance服务配置：Spring Cloud Config服务限流与熔断：Hystrix服务链路追踪：Dapper服务网关、安全、消息 应用服务器知识→ JBoss→ tomcat→ jetty→ Weblogic 工具→ git &amp; svn→ maven &amp; gradle→ Intellij IDEA常用插件：Maven Helper 、FindBugs-IDEA、阿里巴巴代码规约检测、GsonFormatLombok plugin、.ignore、Mybatis plugin 高级篇新技术→ Java 8lambda 表达式、Stream API、时间 API→ Java 9Jigsaw、Jshell、Reactive Streams→ Java 10局部变量类型推断、G1 的并行 Full GC、ThreadLocal 握手机制→ Java 11ZGC、Epsilon、增强 var→ Spring 5响应式编程→ Spring Boot 2.0→ HTTP/2→ HTTP/3 性能优化使用单例、使用 Future 模式、使用线程池选择就绪、减少上下文切换、减少锁粒度、数据压缩、结果缓存 线上问题分析→ dump 获取线程 Dump、内存 Dump、gc 情况→ dump 分析分析死锁、分析内存泄露→ dump 分析及获取工具jstack、jstat、jmap、jhat、Arthas→ 自己编写各种 outofmemory，stackoverflow 程序HeapOutOfMemory、 Young OutOfMemory、MethodArea OutOfMemory、ConstantPool OutOfMemory、DirectMemory OutOfMemory、Stack OutOfMemory Stack OverFlow→ Arthasjvm 相关、class/classloader 相关、monitor/watch/trace 相关、options、管道、后台异步任务文档：https://alibaba.github.io/arthas/advanced-use.html→ 常见问题解决思路内存溢出、线程死锁、类加载冲突→ 使用工具尝试解决以下问题，并写下总结当一个 Java 程序响应很慢时如何查找问题当一个 Java 程序频繁 FullGC 时如何解决问题如何查看垃圾回收日志当一个 Java 应用发生 OutOfMemory 时该如何解决如何判断是否出现死锁如何判断是否存在内存泄露使用 Arthas 快速排查 Spring Boot 应用404/401问题使用 Arthas 排查线上应用日志打满问题利用 Arthas 排查 Spring Boot 应用 NoSuchMethodError 编译原理知识→ 编译与反编译→ Java 代码的编译与反编译→ Java 的反编译工具javap 、jad 、CRF→ 即时编译器→ 编译过程词法分析，语法分析（LL 算法，递归下降算法，LR 算法）语义分析，运行时环境，中间代码，代码生成，代码优化 操作系统知识→ Linux 的常用命令→ 进程间通信→ 进程同步生产者消费者问题、哲学家就餐问题、读者写者问题→ 缓冲区溢出→ 分段和分页→ 虚拟内存与主存→ 虚拟内存管理→ 换页算法 数据库知识→ MySQL 执行引擎→ MySQL 执行计划如何查看执行计划，如何根据执行计划进行 SQL 优化→ 索引Hash 索引、B 树索引（B+树、和B树、R树）普通索引、唯一索引覆盖索引、最左前缀原则、索引下推→ SQL 优化→ 数据库事务和隔离级别事务的隔离级别、事务能不能实现锁的功能→ 数据库锁行锁、表锁、使用数据库锁实现乐观锁、→ 连接内连接，左连接，右连接→ 数据库主备搭建→ binlog→ redolog→ 内存数据库h2→ 分库分表→ 读写分离→ 常用的 NoSql 数据库redis、memcached→ 分别使用数据库锁、NoSql 实现分布式锁→ 性能调优→ 数据库连接池 数据结构与算法知识→ 简单的数据结构栈、队列、链表、数组、哈希表、栈和队列的相同和不同之处栈通常采用的两种存储结构→ 树二叉树、字典树、平衡树、排序树、B 树、B+ 树、R 树、多路树、红黑树→ 堆大根堆、小根堆→ 图有向图、无向图、拓扑→ 排序算法稳定的排序：冒泡排序、插入排序、鸡尾酒排序、桶排序、计数排序、归并排序、原地归并排序、二叉排序树排序、鸽巢排序、基数排序、侏儒排序、图书馆排序、块排序不稳定的排序：选择排序、希尔排序、Clover 排序算法、梳排序、堆排序、平滑排序、快速排序、内省排序、耐心排序各种排序算法和时间复杂度→ 两个栈实现队列，和两个队列实现栈→ 深度优先和广度优先搜索→ 全排列、贪心算法、KMP 算法、hash 算法→ 海量数据处理分治，hash 映射，堆排序，双层桶划分，Bloom Filter，bitmap，数据库索引，mapreduce 等。 大数据知识→ Zookeeper基本概念、常见用法→ Solr，Lucene，ElasticSearch在 linux 上部署 solr，solrcloud，新增、删除、查询索引→ Storm，流式计算，了解 Spark，S4在 linux 上部署 storm，用 zookeeper 做协调，运行 storm hello world，local 和 remote 模式运行调试 storm topology。→ Hadoop，离线计算HDFS、MapReduce→ 分布式日志收集 flume，kafka，logstash→ 数据挖掘，mahout 网络安全知识→ XSSXSS 的防御→ CSRF→ 注入攻击SQL 注入、XML 注入、CRLF 注入→ 文件上传漏洞→ 加密与解密对称加密、非对称加密、哈希算法、加盐哈希算法MD5，SHA1、DES、AES、RSA、DSA彩虹表→ DDOS攻击DOS 攻击、DDOS 攻击memcached 为什么可以导致 DDos 攻击、什么是反射型 DDoS如何通过 Hash 碰撞进行 DOS 攻击→ SSL、TLS，HTTPS→ 用 openssl 签一个证书部署到 apache 或 nginx 架构篇分布式数据一致性、服务治理、服务降级→ 分布式事务2PC、3PC、CAP、BASE、 可靠消息最终一致性、最大努力通知、TCC→ Dubbo服务注册、服务发现，服务治理http://dubbo.apache.org/zh-cn/→ 分布式数据库怎样打造一个分布式数据库、什么时候需要分布式数据库、mycat、otter、HBase→ 分布式文件系统mfs、fastdfs→ 分布式缓存缓存一致性、缓存命中率、缓存冗余→ 限流降级Hystrix、Sentinal→ 算法共识算法、Raft 协议、Paxos 算法与 Raft 算法、拜占庭问题与算法、2PC、3PC 微服务SOA、康威定律→ ServiceMeshsidecar→ Docker &amp; Kubernets→ Spring Boot→ Spring Cloud 高并发→ 分库分表→ CDN 技术→ 消息队列ActiveMQ 监控→ 监控什么CPU、内存、磁盘 I/O、网络 I/O 等→ 监控手段进程监控、语义监控、机器资源监控、数据波动→ 监控数据采集日志、埋点→ Dapper 负载均衡tomcat 负载均衡、Nginx 负载均衡四层负载均衡、七层负载均衡 DNSDNS 原理、DNS 的设计 CDN数据一致性 扩展篇云计算IaaS、SaaS、PaaS、虚拟化技术、openstack、Serverlsess 搜索引擎Solr、Lucene、Nutch、Elasticsearch 权限管理Shiro 区块链哈希算法、Merkle 树、公钥密码算法、共识算法、Raft 协议、Paxos 算法与 Raft 算法、拜占庭问题与算法、消息认证码与数字签名→ 比特币挖矿、共识机制、闪电网络、侧链、热点问题、分叉→ 以太坊→ 超级账本 人工智能数学基础、机器学习、人工神经网络、深度学习、应用场景。→ 常用框架TensorFlow、DeepLearning4J loT量子计算AR &amp; VR其他语言Groovy、Python、Go、NodeJs、Swift、Rust 推荐书籍《深入理解 Java 虚拟机》《Effective Java》《深入分析 Java Web 技术内幕》《大型网站技术架构》《代码整洁之道》《架构整洁之道》《Head First 设计模式》《maven 实战》《区块链原理、设计与应用》《Java 并发编程实战》《鸟哥的 Linux 私房菜》《从Paxos 到 Zookeeper》《架构即未来》 转载自公众号：Hollis]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>技术栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的艺术-类和接口的多继承]]></title>
    <url>%2F2018%2F12%2F05%2FJava%E7%9A%84%E8%89%BA%E6%9C%AF-%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[Java也有多继承？来看看JDK8的这个新特性！ 接口（Interface）定义 Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。 特点(JDK8以前)接口中可以含有 变量和方法。但是要注意，接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误），而方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误） 并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。 Java8 新特性 但是，自从Java 8发布后，接口中也可以自定义方法了（default method）。这样如果为很多继承了同一个接口的类增加功能，不必对这些类重新设计。 123456789public interface Test &#123; //default关键字不能省略，否则提示Interface abstract methods cannot have body default String test(String str)&#123; return str; &#125; //默认为public,abstract的 int test2(); //default关键字不能与abstact同时修饰接口方法&#125; 同时，接口方法也可以被static修饰。 但是这也给Java带来了新问题——Java多继承的冲突。 接口中被default与static修饰的方法 非default、static方法不能有实现，否则编译错误：Abstract methods do not specify a body default、static方法必须有具体的实现，否则编译错误：This method requires a body instead of a semicolon 可以拥有多个default方法 可以拥有多个static方法 使用接口中类型时，仅仅需要实现抽象方法，default、static方法不需要强制自己新实现 Java多继承接口多继承冲突 比如有三个接口，Interface Test1,Interface Test2,Interface Test3。其中，Interface Test3继承自Test1和Test2。 如果Test1和Test2有相同签名的默认(default)方法，并且Test3没有override，则编译会出错。 12345678910111213interface Test1 &#123; default String test(String str)&#123; return str; &#125;&#125;interface Test2 &#123; default String test(String str)&#123; return str; &#125;&#125;interface Test3 extends Test1,Test2 &#123;&#125; 此时会报错：1multiextends.Test3 inherits unrelated defaults for test(String) from types multiextends.Test1 and multiextends.Test2 需要在子接口中覆盖这个方法，让子类知道默认调用哪个方法：12345interface Test3 extends Test1,Test2 &#123; default String test(String str)&#123; return str; &#125;&#125; 注意判断是否签名相同是根据传入的参数，而不是返回的参数。此时接口会根据传入的参数选择不同的default方法执行。比如下面的会报错：12345678910111213141516interface Test1 &#123; default int test(String str)&#123; return 0; &#125;&#125;interface Test2 &#123;//传入相同的String，返回不同的类型 default String test(String str)&#123; return str; &#125;&#125;//编译通过，不需要覆盖interface Test3 extends Test1,Test2 &#123;&#125; 但是下面的编译通过：12345678910111213141516interface Test1 &#123; default String test(int a)&#123; return null; &#125;&#125;interface Test2 &#123;//传入不同类型的参数，返回相同的类型 default String test(String str)&#123; return str; &#125;&#125;//报错，需要覆盖//interface Test3 extends Test1,Test2 &#123;//&#125; 超类多继承冲突 如果比如有两个接口，Interface Test1,Interface Test2，一个超类Class Test3，一个子类Class Test4其中，Class Test4实现Interface Test1和Interface Test2，继承Class Test3。 如果方法有冲突会怎么样？直接看代码：（注意注释中对静态方法和静态属性的 ） 123456789101112131415161718192021222324252627282930interface Test1 &#123; default String test(int a)&#123; return &quot;test&quot;; &#125;&#125;interface Test2 &#123;//传入不同类型的参数，返回相同的类型 default String test(String str)&#123; return &quot;test2&quot;; &#125;&#125;class Test3&#123;//如果public换成static会报错//但是如果只和一个Interface冲突，则可以用static修饰。//因为静态方法和属性可以被继承，但是不能被重写，而是被&quot;隐藏&quot;，直接通过父类名称调用。 public String test(String str)&#123; return &quot;test3&quot;; &#125;&#125;class Test4 extends Test3 implements Test1,Test2&#123; public static void main(String[] args) &#123; Test4 test = new Test4(); System.out.println(test.test(&quot;str&quot;)); &#125;&#125;//执行结果//test3 总结 接口冲突：如果一个类同时实现了具有相同方法签名的接口，则该类必须覆盖该抽象方法。 超类冲突：超类和接口提供相同方法签名的方法，此时子类要是不覆盖，则默认调用超类方法。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建博客时候问题小记]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%97%B6%E5%80%99%E9%97%AE%E9%A2%98%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[摘要：汇总搭建博客遇见的几个问题（持续更新。。。） nothing added to commit but untracked files present1234567891011121314$ git commit -m &quot;first commit&quot;On branch masterUntracked files: .gitignore _config.yml git git.pub package-lock.json package.json scaffolds/ source/ themes/nothing added to commit but untracked files present 这个错误原因有两个： 已经存在的项目？ 没有把需要提交的文件加载进来，所以需要用1git add （文件名） fatal: remote origin already exists.1fatal: remote origin already exists. 用到的解决办法： 删除远程仓库，再添加远程仓库 123$git remote rm origin$git remote add origin git@github.com:wufans/wufans.github.io.git 修改git的config文件的内容。 1$vi .git/config 删除[remote “origin”] github rejected123456To github.com:wufans/wufans.github.io.git ! [rejected] master -&gt; master (non-fast-forward) &apos;git@github.com:wufans/wufans.github.io.git&apos;hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: &apos;git pull ...&apos;) before pushing again. 这个方法就是因为本地仓库和github上面仓库的内容有冲突导致的我用的解决办法是删除了原来的repository，重新建立了一个仓库，问题解决。 创建流量统计功能的方法参考博客 附加功能的添加参考博客 解决公式显示不正常的问题参考博客 hexo设置侧边栏头像编辑站点的 _config.yml，新增字段 avatar， 值设置成头像的链接地址。 其中，头像的链接地址可以是： 完整的互联网 URL，例如：https://avatars1.githubusercontent.com/u/32269?v=3&amp;s=460 站点内的地址，例如： /uploads/avatar.jpg 需要将你的头像图片放置在 站点的 source/uploads/（可能需要新建uploads目录）/images/avatar.jpg 需要将你的头像图片放置在 主题的 source/images/ 目录下。 hexo部署失败，不能连接github的解决一直在解决这个问题，修改了本地文件的几个配置之后，突然发现生成的博客不能直接push到github上了，显示错误但是用12hexo generatehexo server 部署到本地的时候是没有问题的。然后用1ssh -T git@gihub.com 测试连接也出现了1ssh_exchange_identification: read:Connection reset by peer 和1Connection reset by 192.30.253.112 port 22 这样的错误尝试了以下解决办法： 因为前几次修改了hosts文件解决github不能加载CSS的问题，让电脑解析github的域名时用的是自定义的IP，所以可能有这个原因，因此在hosts里面注释掉了修改的部分，然后刷新DNS缓存123ipconfig /flushdns#这里还遇到了ipconfig和ping不是一个命令的错误，需要配置环境变量path#%SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem 最后发现没用。 删除了github上面的ssh配置，重新配置了github服务器端与本地的ssh秘钥，然后再使用1ssh -T git@gihub.com 结果能连上了，但是再用1hexo deploy 之后，又报了刚才的错误，而且再测试与github上面的连接居然也出错了~ 俗话说，重启治百病，于是重启了一下————是的，没用 用网上的解决办法，可能是网络防火墙设置的原因，用手机给电脑开热点再测试连接，结果也没用最后打算第二天重新部署博客了，然后奇迹发生了，起床之后再测试链接，work~ Github不能访问、不能正常加载CSS的解决修改了windows的hosts文件之后，经常会出现github访问异常，页面的CSS样式无法加载等的情况。解决办法给hosts文件增加github的CDN fastly.net,跳过域名解析，直接通过IP访问github。在hosts文件下增加一行：1185.31.17.184 github.global.ssl.fastly.net **问题** 使用1hexo deploy 部署博客时，出现下列错误：123456789101112131415161718fatal: TaskCanceledException encountered. ▒▒ȡ▒▒һ▒▒▒▒▒▒bash: /dev/tty: No such device or addresserror: failed to execute prompt script (exit code 1)fatal: could not read Username for &apos;https://github.com&apos;: No errorFATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: fatal: TaskCanceledException encountered. ��ȡ��һ������bash: /dev/tty: No such device or addresserror: failed to execute prompt script (exit code 1)fatal: could not read Username for &apos;https://github.com&apos;: No error at ChildProcess.&lt;anonymous&gt; (D:\blog\GIT\hexo\node_modules\hexo-util\lib\spawn.js:37:17) at emitTwo (events.js:125:13) at ChildProcess.emit (events.js:213:7) at ChildProcess.cp.emit (D:\blog\GIT\hexo\node_modules\cross-spawn\lib\enoent.js:40:29) at maybeClose (internal/child_process.js:927:16) at Process.ChildProcess._handle.onexit (internal/child_process.js:211:5) **解决** 如果开启了本地预览，先关闭然后用1hexo clean 清空缓存，再重新生成静态文件并部署，问题解决~ 另外用了上面的方法之后还出现了这个问题的话，重启一下电脑~~ 添加数学公式支持参考链接 添加版权声明添加版权声明 在Github上，Next主题的issues上有设置 Creative Commons 协议，这个就是设置版权声明，但是配置了以后图标比较小，没有文字说明（就是没逼格），而且还会出现在它不该出现的地方。 新建 passage-end-tag.swig 文件在路径\themes\next\layout_macro中添加passage-end-tag.swig文件，其内容为： 12345678910111213&#123;% if theme.passage_end_tag.enabled %&#125;&lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;------ 本文结束 ------&lt;/div&gt;&lt;br/&gt;&lt;div style=&quot;border: 1px solid black&quot;&gt;&lt;div style=&quot;margin-left:10px&quot;&gt;&lt;span style=&quot;font-weight:blod&quot;&gt;版权声明&lt;/span&gt;&lt;img src=&quot;http://creativecommons.org/images/deed/logo_deed.gif&quot;&gt;&lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;Fan Wu&apos;s Blog&lt;/a&gt; by &lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;Fan Wu&lt;/a&gt; is licensed under a &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; style=&quot;color:#258FC6&quot;&gt;Creative Commons BY-NC-ND 4.0 International License&lt;/a&gt;.&lt;br/&gt;由&lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;Fan Wu&lt;/a&gt;创作并维护的&lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;Fan Wu&apos;s Blog&lt;/a&gt;博客采用&lt;a href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; style=&quot;color:#258FC6&quot;&gt;创作共用保留署名-非商业-禁止演绎4.0国际许可证&lt;/a&gt;。&lt;br/&gt;本文首发于&lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;Fan Wu&apos;s Blog&lt;/a&gt; 博客（ &lt;a href=&quot;http://wufan.site/&quot; style=&quot;color:#258FC6&quot;&gt;http://wufan.site/&lt;/a&gt; ），版权所有，侵权必究。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endif %&#125; 如果觉得上面的样式不好看，也可以引用下面的内容：1234567891011121314151617&#123;% if theme.passage_end_tag.enabled %&#125;&lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-heart&quot;&gt;&lt;/i&gt;感谢阅读-------------&lt;/div&gt;&lt;ul class=&quot;post-copyright&quot;&gt; &lt;li class=&quot;post-copyright-author&quot;&gt; &lt;strong&gt;本文作者:&lt;/strong&gt;&#123;&#123; theme.author &#125;&#125; &lt;/li&gt; &lt;li class=&quot;post-copyright-link&quot;&gt; &lt;strong&gt;本文链接:&lt;/strong&gt; &lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.path &#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;post-copyright-license&quot;&gt; &lt;strong&gt;许可协议:&lt;/strong&gt; 除特殊声明外，本站博文均采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-sa/3.0/cn/&quot; rel=&quot;external nofollow&quot; target=&quot;_blank&quot;&gt;CC BY-NC-SA 4.0 CN&lt;/a&gt; 许可协议，转载请注明出处！ &lt;/li&gt;&lt;/ul&gt;&#123;% endif %&#125; 修改 post.swig 文件在\themes\next\layout_macro\post.swig中，post-body之后，post-footer之前添加如下代码：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 在主题配置文件中添加字段在主题配置文件”_config.yml”中添加以下字段开启此功能： 123#文章末尾添加“本文结束”标记passage_end_tag: enabled: true 完成以上设置之后，在每篇文章之后都会添加“版权声明”标记。 添加动画效果背景动画基于canvas，添加到博客上也比较简单，在\themes\next\layout_layout.swig的&lt;/body&gt;上面添加123&#123;% if theme.canvas_nest %&#125; &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 在\themes\next_config.yml中添加以下字段开启此功能：1234# background settings# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true 添加完了，发现博客背景是白色，会遮住动画，只留下两边一点点的位置看到动画效果，这时候可以去设置一下背景颜色，在\themes\next\source\css_schemes\Pisces_layout.styl中，把.content-wrap中的background修改为none。 这时候如果用手机打开，也能看到动画效果，但是带来的体验不好，显得页面比较乱，这是可以把.content-wrap的+mobile()中的background修改为white，这样手机端的体验就好很多，却又不影响电脑端的炫酷动画。 解决博客浏览统计功能突然失效的方法（hexo-theme-next-busuanzi_count）说明我这里是使用的hexo-theme-next主题，主题版本为：3.8.0(更新于10-31日) 原因分析由于定位到是不蒜子统计功能突然有问题了，所以前往不蒜子官网进行查看，发现官网有一段很重要的提示：“因七牛强制过期『dn-lbstatics.qbox.me』域名，与客服沟通无果，只能更换域名到『busuanzi.ibruce.info』！”所以定位到问题，原来是不蒜子使用的七牛的域名被强制过期。需要把 dn-lbstatics.qbox.me 域名更换为 busuanzi.ibruce.info 解决方案hexo-theme-next主题中使用了dn-lbstatics.qbox.me域名的文件位置为： 1themes\next\layout\_third-party\analytics\busuanzi-counter.swig 修改busuanzi-counter.swig 找到如下代码：1&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 修改为：1&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 重新预览，即可看到不蒜子统计功能已经生效原文 恢复你的博客，只需要三步如果你重装了系统或者更换了新电脑/新平台，怎么才能快速恢复原来的博客呢？如果你保留了原来博客文件夹下所有文件，那么恢复博客只需要三步： 安装必备组件包括：安装Git，安装Node.js Github配对打开git bash，在用户主目录下运行：1ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 把其中的邮件地址换成自己的邮件地址，然后一路回车,在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥登陆GitHub，打开「Settings」-&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容），最后点击「Add SSH Key」测试是否配对成功：1ssh -T git@github.com 安装hexo打开git bash客户端，输入1npm install hexo-cli -g ，开始安装hexo安装成功后，进入你原来的博客目录，就可以用hexo命令进行博客生成和部署啦~ 给博客自定义域名开启HttpsHTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer 或 Hypertext Transfer Protocol Secure，超文本传输安全协议），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。GitHub官方在5月1号宣布，GitHub Pages的自定义域名获得对HTTPS的支持。但是因为自己的域名是自定义的，购于阿里云，因此不能直接在Setting中设置Enforce HTTPS:而Github pages不支持SSL证书上传，因此，开启HTTPS需要借助CloudFlare的CDN代理。即用户到CDN服务器的连接为https，而CDN服务器到GithubPage服务器的连接为http，就是在CDN服务器那里加上反向代理。步骤如下： 首先注册并登陆CloudFlare,在域名购买的地方修改name sever，修改DNS解析地址。（启用动态DNS加速） 与域名绑定并激活成功后，设置CloudFlare 的 DNS： 设置CloudFlare 的 Crypto： 设置路由规则Page Rules：至此，等待一段时间，就可以用https协议访问你的自定义域名为了让博客完全开启Https，还需要修改文章内容中用http协议的链接，比如图片，这样，就能看到浏览器域名旁边的小绿锁啦！同时，修改了DNS解析服务器后，网站响应速度也更快了！一举两得！]]></content>
      <categories>
        <category>Guidances</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的艺术-注解]]></title>
    <url>%2F2018%2F11%2F28%2FJava%E7%9A%84%E8%89%BA%E6%9C%AF-%E6%B3%A8%E8%A7%A3%E7%B1%BB%E5%9E%8B(Annotation)%2F</url>
    <content type="text"><![CDATA[使用注解来进行开发，可以免去写XML配置。那么注解到底是什么呢？ 概念注解（Annotation） 也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。这些标记和注释可以在编译、类加载、运行时被读取，并执行响应的处理。通俗地讲，注解相当于给类、属性或者方法贴上一个标签。 注解的元注解 元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。元注解有五种：1@Retention、@Documented、@Target、@Inherited、@Repeatable 注解的基本用法定义注解通过@interface 关键字定义。12//创建一个名为AnnotationTest的注解。public @interface AnnotationTest&#123;&#125; 注解的属性注解的属性类似于类的成员变量。并且注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。可以通过default关键字给出默认值。举例：1234public @interface AnnotationTest&#123; int id(); String message() default "Hello World";&#125; 在使用的时候，赋值的方式是在注解的括号内以 value=””形式，多个属性之间用“,”隔开。12345678@AnnotationTest(id=0,message="God")public class Test&#123;&#125;//因为属性message有默认值，也可以不赋值@AnnotationTest(id=1)public class Test1&#123;&#125;//当所有属性都有默认值，括号内为空 甚至当注解没有属性时，可以不用括号：123456public @interface Check &#123;&#125;//没有属性的注解，不用括号@Checkpublic class Test2&#123;&#125; 注意 注解中所有方法（也就是属性）没有方法体，且只允许public和abstract修饰。缺省默认为public，且注解方法不允许有throws子句。 注解中方法的返回值只能为：基本数据类型，String，Class，美剧类型，注解和他们的一维数组。 注解的继承只能作用在类上，方法上的注解不会被继承，Interface中的所有注解不会被继承。 常见注解五种元注解前面我们提到，Java中有五种元注解。 @Retention 解释说明一个注解的存活时间。取值如下： RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。 RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。 RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。123@Retention(RetentionPolicy.RUNTIME)public @interface AnnotationTest &#123;&#125; @Documented 能够将注解中的元素包含到 Javadoc 中去。 @Target 限定注解运用的场景。取值如下： ElementType.ANNOTATION_TYPE 可以给一个注解进行注解 ElementType.CONSTRUCTOR 可以给构造方法进行注解 ElementType.FIELD 可以给属性进行注解 ElementType.LOCAL_VARIABLE 可以给局部变量进行注解 ElementType.METHOD 可以给方法进行注解 ElementType.PACKAGE 可以给一个包进行注解 ElementType.PARAMETER 可以给一个方法内的参数进行注解 ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举 @Inherited 如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。 123456789@Inherited@Retention(RetentionPolicy.RUNTIME)@interface Test &#123;&#125;@Testpublic class A &#123;&#125;//因为Test注解被@Inherited注解，所以继承了注解了Test的A类后的B类，也拥有Test这个注解。public class B extends A &#123;&#125; @Repeatable Repeatable 是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。 123456789101112131415@interface Persons &#123; Person[] value();&#125;@Repeatable(Persons.class)@interface Person&#123; String role default "";&#125;@Person(role="artist")@Person(role="coder")@Person(role="PM")public class SuperMan&#123;&#125; @Repeatable 注解了 Person。而 @Repeatable 后面括号中的类相当于一个容器注解。 什么是容器注解呢？就是用来存放其它注解的地方。它本身也是一个注解。 我们再看看代码中的相关容器注解。123@interface Persons &#123; Person[] value();&#125; 按照规定，它里面必须要有一个 value 的属性，属性类型是一个被 @Repeatable 注解过的注解数组，注意它是数组。 可以这样理解。Persons 是一张总的标签，上面贴满了 Person 这种同类型但内容不一样的标签。把 Persons 给一个 SuperMan 贴上，相当于同时给他贴了程序员、产品经理、画家的标签。 Java预置注解Java本身提供了现成的注解。 @Deprecated 用来标记过时的元素。 @Override 提示子类要复写父类中被@Override 修饰的方法 @SuppressWarnings 阻止警告。调用被 @Deprecated 注解的方法后，编译器会警告提醒，而有时候开发者会忽略这种警告，他们可以在调用的地方通过 @SuppressWarnings 达到目的。 @SafeVarargs 参数安全类型注解。它的目的是提醒开发者不要用参数做一些不安全的操作,它的存在会阻止编译器产生 unchecked 这样的警告。它是在 Java 1.7 的版本中加入的。 @FunctionalInterface 函数式接口注解，这个是 Java 1.8 版本引入的新特性。线程开发中常用的 Runnable 就是一个典型的函数式接口。函数式接口可以很容易转换为 Lambda 表达式。 注解的作用 编译检查 编译器可以利用注解来探测错误和警告信息；通过代码里标识的元数据让编译器能够实现基本的编译检查【Override】 编写文档 软件工具可以用来利用注解信息来生成代码、Html文档或者做其它相应处理。通过代码里标识的元数据生成文档【生成文档doc文档】 代码分析 某些注解可以在程序运行的时候接受代码的提取；通过代码里标识的元数据对代码进行分析【使用反射】 总之，当开发者使用了Annotation 修饰了类、方法、Field 等成员之后，这些 Annotation 不会自己生效，必须由开发者提供相应的代码来提取并处理 Annotation 信息。这些处理提取和处理 Annotation 的代码统称为 APT（Annotation Processing Tool)。而注解主要就是给编译器或者APT用的。 注解也就是代码添加元数据，描述信息。 相比使用单独的XML来描述这些元数据，使用注解要简单些，和代码在一起也更好维护。相比使用继承（如TesCase）或者方法前缀的约定（如testXXX是测试方法）要灵活些。 一些插件机制就是通过注解提供插件的元数据，在加载类后扫描所以带该注解的类就可以找到插件，减少了配置的麻烦。 注解的解析-反射注解的提取（解析）需要借助于 Java 的反射技术，反射比较慢，所以注解使用时也需要谨慎计较时间成本。 类的注解的解析 首先通过Class对象的isAnnotationPresent()方法判断他是否应用了某个注解：1public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)&#123;&#125; 然后通过getAnnotation()方法获取Annotation对象。1public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) &#123;&#125; 或者getAnnotations()方法：1public Annotation[] getAnnotations() &#123;&#125; 如果获取到的 Annotation 如果不为 null，则就可以调用它们的属性方法1234567891011121314151617@AnnotationTest()public class Test &#123; public static void main(String[] args) &#123; boolean hasAnnotation = Test.class.isAnnotationPresent(TestAnnotation.class); if ( hasAnnotation ) &#123; TestAnnotation testAnnotation = Test.class.getAnnotation(TestAnnotation.class); System.out.println("id:"+testAnnotation.id()); System.out.println("message:"+testAnnotation.message()); &#125; &#125;&#125; 也可以使用forName()方法加载类，使用isAnnotation(Annotation.class)判定对象是否存在注解，并使用getAnnotation(Description.class)得到带有@Description注解的类。 方法的注解的解析1234567891011121314151617181920public class Test &#123; @AnnotationTest() public void test_method(String str) &#123; System.out.println(str); &#125; public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; Test my_test = new Test(); Class test_class = Test.class; Method method = test_class.getDeclaredMethod("test_method",String.class); if (method.isAnnotationPresent(AnnotationTest.class)) &#123; //执行方法 method.setAccessible(true); method.invoke(my_test, "hello"); //解析注解元素 AnnotationTest a = method.getAnnotation(AnnotationTest.class); System.out.println(a.test()); &#125; &#125;&#125; 类的属性的注解的解析12345678910111213141516171819public class Test &#123; @AnnotationTest() public void test_method(String str) &#123; System.out.println(str); &#125; public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; Test my_test = new Test(); //利用反射，通过class对象的getDeclaredField(String str)获得元素Field对象 Field test_field = Test.class.getDeclaredField("value"); //判断元素是否是注解的对象 if(test_field.isAnnotationPresent(AnnotationTest.class))&#123; //修改权限（同一个类内部其实没有必要，肯定有访问权限。） test_field.setAccessible(true); //利用Field对象的getXXX()获取实例的值。 System.out.println(test_field.getInt(my_test)); &#125; &#125;&#125; 注意 一定要用@Retention元注解表示出注解的存活时间，不然在动态执行时可能判定某个类并没有受到注解。1234@Retention(RetentionPolicy.RUNTIME)public @interface AnnotationTest &#123; abstract int test() default 2019;&#125; 参考1参考2]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的艺术-浅谈反射机制]]></title>
    <url>%2F2018%2F11%2F25%2FJava%E7%9A%84%E8%89%BA%E6%9C%AF-%E6%B5%85%E6%9E%90%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[在运行时发现和使用类的信息 - Java反射。 什么是反射通俗的解释是：JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 动态语言动态语言，是指程序在运行时可以改变其结构：新的函数可以被引进，已有的函数可以被删除等在结构上的变化。 反射的作用参考假设我们有很多食材需要处理，猪肉，牛肉，羊肉；每一样食材对应一个类，这个类里面有处理食材的方法。123456789101112public class Pork&#123; //猪肉 public void cook()&#123; System.out.println("cook pork");&#125;public class Beef&#123; //牛肉 public void cook()&#123; System.out.println("cook beef");&#125;public class Mutton&#123; //羊肉 public void cook()&#123; System.out.println("cook mutton");&#125; 当我们在程序中需要根据食材的不同来实例化对应类的对象，再调用对应的方法要怎么做呢？1234567891011121314151617public class test&#123; public static void main(String[] args)&#123; String food=null; if(food.equals("Pork"))&#123; Pork pork=new Pork(); pork.cook(); &#125; else if(food.equals("Beef"))&#123; Beef beef=new Beef(); beef.cook(); &#125; else if(food.equals("Mutton"))&#123; Mutton mutton=new Mutton(); mutton.cook(); &#125; &#125;&#125; 以上的做法是很容易想到的，很直观，但是当我们的食材有几十种甚至上百种时，我们要怎么写上百个if else 来判断食材，再实例化对应的类，调用对应的方法。 有没有更简单的方法？答案是肯定的，我们可以利用反射机制来完成这一工作，在程序运行时根据类名实例化对应的对象，并调用对应的方法 步骤如下： 1、首先我们需要用到接口:123public interface IFood &#123; public void cook();&#125; 2、所有的食材类实现这一接口123456789101112public class Pork implements IFood&#123; //猪肉 public void cook()&#123; System.out.println("cook pork");&#125;public class Beef implements IFood&#123; //牛肉 public void cook()&#123; System.out.println("cook beef");&#125;public class Mutton implements IFood&#123; //羊肉 public void cook()&#123; System.out.println("cook mutton");&#125; 3、接下来我们看看怎么使程序更为简单123456789public class test&#123; public static void main(String[] args)&#123; String food="Pork"; //字符串food代表食物的类 Class c=Class.forName(food); //根据字符串food来载入类对象 Object object=c.newInstance(); //生成对象 IFood Ifood=(IFood)object; //强制转型 Ifood.cook(); //调用方法 &#125;&#125; 如此一来我们不需要写冗杂的if else 嵌套了 只需要利用 Class.forName()方法根据字符串来实例化对应的类，并调用其方法即可。 当我们需要处理其他的食材的时候只需要添加对应的类即可，而主程序中可以不改变一行代码。 反射的应用Class对象的获取加载完类之后, 在堆内存中会产生一个Class类型的对象(一个类只有一个Class对象), 这个对象包含了完整的类的结构信息,而且这个Class对象就像一面镜子,透过这个镜子看到类的结构,所以被称之为:反射。12java.lang.Object--java.lang.Class&lt;T&gt; 获取Class对象的方法一般有三种方法： 调用对象的getClass()方法;12StringBuffer sb = new StringBuffer("test");Class&lt;?&gt; class1 = sb.getClass(); 类名的.class(最安全/性能最好)属性，或者TYPE属性(继承自Object类);123Class&lt;?&gt; class1 = int.class;Class&lt;?&gt; class2 = Integer.class;Class&lt;?&gt; class3 = Integer.TYPE; 运用Class.forName(String className)动态加载类,className需要是类的全限定名(最常用)1Class&lt;?&gt; class1 = Class.forName("Integer"); 创建实例化对象得到了对应java.lang.Class对象，有两种方法通过反射生成对象：[都需要抛出异常] 使用Class对象的newInstance()方法来创建该Class对象对应类的实例(这种方式要求该Class对象的对应类有默认构造器)；相当于无参构造12Class&lt;?&gt; class1 = String.class;Object str = c.newInstance(); 先使用Class对象获取指定的Constructor对象, 再调用Constructor对象的newInstance()方法来创建该Class对象对应类的实例(通过这种方式可以选择指定的构造器来创建实例).适用于无参和有参的构造方法1Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) 123456//获取String所对应的Class对象Class&lt;?&gt; c = String.class;//获取String类带一个String参数的构造器Constructor constructor = c.getConstructor(String.class);//根据构造器创建实例Object obj = constructor.newInstance("test"); 另外可以用getConstructors()方法返回Constructor对象的一个数组。这些对象反映此 Class 对象所表示的类的所有公共构造方法。如果该类没有公共构造方法，或者该类是一个数组类，或者该类反映一个基本类型或 void，则返回一个长度为 0 的数组。 注意，此方法返回 Constructor 对象的数组（即取自此类构造方法的数组）时，此方法的返回类型是 Constructor&lt;?&gt;[]，不是预期的 Constructor[]。此少量信息的返回类型是必需的，因为从此方法返回之后，该数组可能被修改以保存不同类的 Constructor 对象，而这将违反 Constructor[] 的类型保证。12345Class&lt;?&gt; c = String.class;//获取Class对象Constructor&lt;?&gt; cons[] = c.getConstructors();for (Constructor&lt;?&gt; constructor : cons) &#123; System.out.println(constructor);&#125; 执行结果：123456789101112131415public java.lang.String(byte[],int,int)public java.lang.String(byte[],java.nio.charset.Charset)public java.lang.String(byte[],java.lang.String) throws java.io.UnsupportedEncodingExceptionpublic java.lang.String(byte[],int,int,java.nio.charset.Charset)public java.lang.String(byte[],int,int,java.lang.String) throws java.io.UnsupportedEncodingExceptionpublic java.lang.String(java.lang.StringBuilder)public java.lang.String(java.lang.StringBuffer)public java.lang.String(byte[])public java.lang.String(int[],int,int)public java.lang.String()public java.lang.String(char[])public java.lang.String(java.lang.String)public java.lang.String(char[],int,int)public java.lang.String(byte[],int)public java.lang.String(byte[],int,int,int) 此外，还可以用getDeclaredConstructors()方法获取所有的构造方法。 getConstructor()和getDeclaredConstructor()区别: getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)这个方法会返回制定参数类型的所有构造器，包括public的和非public的，当然也包括private的。getDeclaredConstructors()的返回结果就没有参数类型的过滤了。 getConstructor(Class&lt;?&gt;… parameterTypes)这个方法返回的是getDeclaredConstructor()方法返回结果的子集，只返回制定参数类型访问权限是public的构造器。getConstructors()的返回结果同样也没有参数类型的过滤。 获取方法获取某个Class对象的方法集合，主要有以下几种方法： getDeclaredMethods方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。1public Method[] getDeclaredMethods() throws SecurityException getMethods方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。1public Method[] getMethods() throws SecurityException getMethod 方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象。注意：如果不带方法参数对应的class对象，则无法根据方法名获取对应的方法1public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 调用方法 当我们从类中获取了一个方法后，我们就可以用 invoke() 方法来调用这个方法。invoke 方法的原型为:1public Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException invoke回调流程示例： 由Class对象动态构造对应类型对象； 利用Class对象的getMethod()、getMethods()、getDeclaredMethod()、getDeclaredMethods()等方法构造method对象； 类型对象，使其执行对应形参的方法（也就是需要传入一个动态执行方法的对象，以及对应方法的形参）。 举例：(利用反射调用String对象的toString()方法)1234Class test = String.class;Object ob = new String("abc");Method me = test.getDeclaredMethod("toString");System.out.println(me.invoke(ob,null)); invoke()的缺点: invoke的参数和返回值必需时Object类型的，这意味着必须进行多次的类型转换（特别是基本数据类型），而这将导致编译器错过检查代码的机会，有类型安全的风险，只有到了测试阶段才会发现这些错误，此时找到并改正他们将会更加困难。 使用反射获得方法指针的代码要比仅仅直接调用方法明显慢一些。 因此仅在必要时才使用Method对象，而最好使用接口和内部类，不建议Java开发者使用Method对象的回调功能，使用接口进行回调不仅会使代码的运行速度更快，还更易于维护。 访问成员变量通过Class对象的的getField()方法可以获取该类所包含的全部或指定的成员变量Field,Filed提供了如下两组方法来读取和设置成员变量值：getFiled：访问公有的成员变量getDeclaredField：所有已声明的成员变量，但不能得到其父类的成员变量 getXxx(Object obj): 获取obj对象的该成员变量的值, 此处的Xxx对应8中基本类型,如果该成员变量的类型是引用类型, 则取消get后面的Xxx;setXxx(Object obj, Xxx val): 将obj对象的该成员变量值设置成val值.此处的Xxx对应8种基本类型, 如果该成员类型是引用类型, 则取消set后面的Xxx; 注: getDeclaredXxx方法可以获取所有的成员变量,无论private/public; 反射与Spring框架设计反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射，运行时动态加载需要加载的对象。 Spring内部采用了很多反射机制。很多web框架的前端，实现URI请求映射到Action方法，也可以简单的通过反射来做。这部分内容后面再单独补充。 反射存在的问题 由于反射会额外消耗一定的系统资源，因此如果不需要动态地创建一个对象，那么就不需要用反射。 另外，反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法之美-二叉树的遍历]]></title>
    <url>%2F2018%2F10%2F21%2F%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[前序？后序？层序？递归？一问看尽二叉树应该怎么遍历。 二叉树的定义：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * @Author: WuFan * @Date: 2018/3/6 22:07 */package offer;//二叉树节点public class BinaryTreeNode &#123; private int data; private BinaryTreeNode left; private BinaryTreeNode right; public BinaryTreeNode() &#123;&#125; public BinaryTreeNode(int data, BinaryTreeNode left, BinaryTreeNode right) &#123; super(); this.data = data; this.left = left; this.right = right; &#125; public int getData() &#123; return data; &#125; public void setData(int data) &#123; this.data = data; &#125; public BinaryTreeNode getLeft() &#123; return left; &#125; public void setLeft(BinaryTreeNode left) &#123; this.left = left; &#125; public BinaryTreeNode getRight() &#123; return right; &#125; public void setRight(BinaryTreeNode right) &#123; this.right = right; &#125;&#125; 二叉树的遍历：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160/** * @Author: WuFan * @Date: 2018/3/6 22:19 */package offer;import java.util.LinkedList;import java.util.Queue;import java.util.Stack;public class BinaryTree &#123; //前序遍历递归的方式 public void preOrder(BinaryTreeNode root)&#123; if(null!=root)&#123; System.out.print(root.getData()+"\t"); preOrder(root.getLeft()); preOrder(root.getRight()); &#125; &#125; //前序遍历非递归的方式 public void preOrderNonRecursive(BinaryTreeNode root)&#123; Stack&lt;BinaryTreeNode&gt; stack=new Stack&lt;BinaryTreeNode&gt;(); while(true)&#123; while(root!=null)&#123; System.out.print(root.getData()+"\t"); stack.push(root); root=root.getLeft(); &#125; if(stack.isEmpty()) break; root=stack.pop(); root=root.getRight(); &#125; &#125; //中序遍历采用递归的方式 public void inOrder(BinaryTreeNode root)&#123; if(null!=root)&#123; inOrder(root.getLeft()); System.out.print(root.getData()+"\t"); inOrder(root.getRight()); &#125; &#125; //中序遍历采用非递归的方式 public void inOrderNonRecursive(BinaryTreeNode root)&#123; Stack&lt;BinaryTreeNode&gt; stack=new Stack&lt;BinaryTreeNode&gt;(); while(true)&#123; while(root!=null)&#123; stack.push(root); root=root.getLeft(); &#125; if(stack.isEmpty())break; root=stack.pop(); System.out.print(root.getData()+"\t"); root=root.getRight(); &#125; &#125; //后序遍历采用递归的方式 public void postOrder(BinaryTreeNode root)&#123; if(root!=null)&#123; postOrder(root.getLeft()); postOrder(root.getRight()); System.out.print(root.getData()+"\t"); &#125; &#125; //后序遍历采用非递归的方式 public void postOrderNonRecursive(BinaryTreeNode root)&#123; Stack&lt;BinaryTreeNode&gt; stack=new Stack&lt;BinaryTreeNode&gt;(); while(true)&#123; if(root!=null)&#123; stack.push(root); root=root.getLeft(); &#125;else&#123; if(stack.isEmpty()) return; if(null==stack.lastElement().getRight())&#123; root=stack.pop(); System.out.print(root.getData()+"\t"); while(root==stack.lastElement().getRight())&#123; System.out.print(stack.lastElement().getData()+"\t"); root=stack.pop(); if(stack.isEmpty())&#123; break; &#125; &#125; &#125; if(!stack.isEmpty()) root=stack.lastElement().getRight(); else root=null; &#125; &#125; &#125; //层序遍历 public void levelOrder(BinaryTreeNode root)&#123; BinaryTreeNode temp; Queue&lt;BinaryTreeNode&gt; queue=new LinkedList&lt;BinaryTreeNode&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; temp=queue.poll(); System.out.print(temp.getData()+"\t"); if(null!=temp.getLeft()) queue.offer(temp.getLeft()); if(null!=temp.getRight())&#123; queue.offer(temp.getRight()); &#125; &#125; &#125; public static void main(String[] args) &#123; BinaryTreeNode node10=new BinaryTreeNode(10,null,null); BinaryTreeNode node8=new BinaryTreeNode(8,null,null); BinaryTreeNode node9=new BinaryTreeNode(9,null,node10); BinaryTreeNode node4=new BinaryTreeNode(4,null,null); BinaryTreeNode node5=new BinaryTreeNode(5,node8,node9); BinaryTreeNode node6=new BinaryTreeNode(6,null,null); BinaryTreeNode node7=new BinaryTreeNode(7,null,null); BinaryTreeNode node2=new BinaryTreeNode(2,node4,node5); BinaryTreeNode node3=new BinaryTreeNode(3,node6,node7); BinaryTreeNode node1=new BinaryTreeNode(1,node2,node3); BinaryTree tree=new BinaryTree(); //采用递归的方式进行遍历 System.out.println("-----前序遍历------"); tree.preOrder(node1); System.out.println(); //采用非递归的方式遍历 tree.preOrderNonRecursive(node1); System.out.println(); //采用递归的方式进行遍历 System.out.println("-----中序遍历------"); tree.inOrder(node1); System.out.println(); //采用非递归的方式遍历 tree.inOrderNonRecursive(node1); System.out.println(); //采用递归的方式进行遍历 System.out.println("-----后序遍历------"); tree.postOrder(node1); System.out.println(); //采用非递归的方式遍历 tree.postOrderNonRecursive(node1); System.out.println(); //采用递归的方式进行遍历 System.out.println("-----层序遍历------"); tree.levelOrder(node1); System.out.println(); &#125;&#125;]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>algorithms</tag>
        <tag>Java算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发(2)-线程池]]></title>
    <url>%2F2018%2F10%2F09%2FJava%E5%B9%B6%E5%8F%91(2)-%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[本文介绍Java中线程池的相关概念和部分源码解析。 一、为什么需要线程池？ 因为服务器需要接受并处理请求，通常会给每一个请求分配一个线程来处理，假设每次请求都创建一个线程，如果并发的请求数量非常多，但每个线程执行的时间很短，这样就会频繁的创建和销毁线程，如此一来会大大降低系统的效率。可能出现服务器在为每个请求创建新线程和销毁线程上花费的时间和消耗的系统资源要比处理实际的用户请求的时间和资源更多。 线程池具有以下优点： 线程复用，降低资源消耗：重用线程池中的线程,减少因对象创建,销毁所带来的性能开销; 控制并发数量，提高响应速度：能有效的控制线程的最大并发数,提高系统资源利用率,同时避免过多的资源竞争,避免堵塞; 提高线程的可管理性：能够对线程进行简单的管理并提供定时执行、间隔执行、单线程、并发数控制等功能,使线程的使用简单、高效。 二、线程池原理线程池的特点 （1）线程复用：实现线程复用的原理应该就是要保持线程处于存活状态（就绪，运行或阻塞） （2）控制并发数量：（核心线程和最大线程数控制） （3）管理线程（设置线程的状态） 当往线程池中添加任务时 (1)线程数量未达到corePoolSize，则新建一个线程(核心线程)执行任务; (2)线程数量达到了corePoolSize，则将任务移入队列等待空闲线程将其取出去执行（通过getTask()方法从阻塞队列中获取等待的任务，如果队列中没有任务，getTask方法会被阻塞并挂起，不会占用cpu资源，整个getTask操作在自旋下完成） (4)队列已满，新建线程(非核心线程)执行任务 (5)队列已满，总线程数又达到了maximumPoolSize，就会执行任务拒绝策略。 线程池状态：一共五种 RUNNING ：能接受新提交的任务，并且也能处理阻塞队列中的任务； SHUTDOWN：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 RUNNING 状态时，调用shutdown()方法会使线程池进入到该状态。（finalize()方法在执行过程中也会调用shutdown()方法进入该状态）； STOP：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态； TIDYING：如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态。 TERMINATED：在terminated() 方法执行完后进入该状态，默认terminated()方法中什么也没有做。进入TERMINATED的条件如下： 线程池不是RUNNING状态； 线程池状态不是TIDYING状态或TERMINATED状态； 如果线程池状态是SHUTDOWN并且workerQueue为空； workerCount为0； 设置TIDYING状态成功。 三、Executor框架接口 JUC(Java.util.concurrent)中一共有三个Executor接口： Executor：一个运行新任务的简单接口； ExecutorService：扩展了Executor接口。添加了一些用来管理执行器生命周期和任务生命周期的方法； ScheduledExecutorService：扩展了ExecutorService。支持Future和定期执行任务。 Executor接口123public interface Executor &#123; void execute(Runnable command);&#125; 用execute方法替代创建或者启动线程的方法。12Thread t = new Thread();executor.execute(t); ExecutorService接口ExecutorService接口继承自Executor接口，提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成 Future的方法。增加了shutDown()，shutDownNow()，invokeAll()，invokeAny()和submit()等方法。如果需要支持即时关闭，也就是shutDownNow()方法，则任务需要正确处理中断。 ScheduledExecutorService接口ScheduledExecutorService扩展ExecutorService接口并增加了schedule方法。调用schedule方法可以在指定的延时后执行一个Runnable或者Callable任务。ScheduledExecutorService接口还定义了按照指定时间间隔定期执行任务的scheduleAtFixedRate()方法和scheduleWithFixedDelay()方法。 四、ThreadPoolExecutor类ThreadPoolExecutor继承自AbstractExecutorService，实现了ExecutorService接口。 重要字段12345678910private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));private static final int COUNT_BITS = Integer.SIZE - 3;private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1;// runState is stored in the high-order bitsprivate static final int RUNNING = -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;private static final int STOP = 1 &lt;&lt; COUNT_BITS;private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; ctl是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它包含两部分的信息: 线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，使用了Integer类型来保存，高3位保存runState，低29位保存workerCount。COUNT_BITS 就是29，CAPACITY就是1左移29位减1（29个1），这个常量表示workerCount的上限值，大约是5亿。 ThreadPoolExecutor构造方法123456789101112131415161718192021public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 构造方法的各个字段意义如下： corePoolSize：核心线程数（最小存活的工作线程数量） maxPoolSize：最大线程数 keepAliveTime：线程存活时间（在corePoreSize&lt;maxPoolSize情况下有用,线程的空闲时间超过了keepAliveTime就会销毁） timeUnit：存活时间的时间单位 workQueue：阻塞队列，用来保存等待被执行的任务（①synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务；②LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；③ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小） threadFactory：线程工厂，主要用来创建线程； handler：表示当拒绝处理任务时的策略（线程池提供了4种策略，都实现了RejectedExecutionHandler接口:AbortPolicy：直接抛出异常，这是默认策略；CallerRunsPolicy：用调用者所在的线程来执行任务；DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；DiscardPolicy：直接丢弃任务；） 重要的方法 execute()Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。适合不关注返回值的场景。12345678public class ThreadPool &#123; public static void main(String[] args) &#123; ExecutorService pool = Executors.newFixedThreadPool(10); pool.execute(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + "执行"); &#125;); &#125;&#125; submit()在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor中并没有对其进行重写，这个方法也是用来向线程池提交任务的，实际上它还是调用的execute()方法，只不过它利用了Future来获取任务执行结果。适用于需要关注返回值的场景.1234567public interface ExecutorService extends Executor &#123; ... &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result); Future&lt;?&gt; submit(Runnable task); ...&#125; shutdown()不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务。 shutdownNow()立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务。 判断线程池线程是否执行完 isTerminated()调用ExecutorService.shutdown()方法的时候，线程池不再接收任何新任务，但此时线程池并不会立刻退出，直到添加到线程池中的任务都已经处理完成，才会退出。在调用shutdown方法后我们可以在一个死循环里面用isTerminated()方法判断是否线程池中的所有线程已经执行完毕，如果子线程都结束了，我们就可以做关闭流等后续操作了。 使用闭锁(CountDownLatch)CountDownLatch是一种灵活的闭锁实现，它可以使一个或多个线程等待一组事件发生。闭锁状态包括一个计数器，该计数器被初始化为一个正数，表示需要等待的事件数量。countDown方法递减计数器，表示有一个事件已经发生了，而await方法等待计数器达到零，即表示需要等待的事情都已经发生。 使用信号量机制 五、常见的四种线程池的用法 Java通过Executors类提供四种线程池 1. CachedThreadPool()-可缓存线程池newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 1234567public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; 这种线程池内部没有核心线程，线程的数量是有没限制的。 在创建任务时，若有空闲的线程时则复用空闲的线程，若没有则新建线程。没有工作的线程（闲置状态）在超过了60S还不做事，就会销毁。 适用：执行很多短期异步的小程序或者负载较轻的服务器。 2. FixedThreadPool()-定长线程池newFixedThreadPool创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 12345678public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor( nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; 该线程池的最大线程数等于核心线程数，所以在默认情况下，该线程池的线程不会因为闲置状态超时而被销毁。 如果当前线程数小于核心线程数，并且也有闲置线程的时候提交了任务，这时也不会去复用之前的闲置线程，会创建新的线程去执行任务。如果当前执行任务数大于了核心线程数，大于的部分就会进入队列等待。等着有闲置的线程来执行这个任务。 适用：执行长期的任务，性能好很多。 3. SingleThreadPool()-单线程池newSingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 123456789public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService( new ThreadPoolExecutor( 1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; 有且仅有一个工作线程执行任务 所有任务按照指定顺序执行，即遵循队列的入队出队规则。 适用：一个任务一个任务执行的场景。 4. ScheduledThreadPool()-调度线程池newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行。123public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize); &#125; 其中ScheduledThreadPoolExecutor()的构造方法为：1234567public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());&#125; 同样是用到了父类ThreadPoolExecutor的构造方法。123456789public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125; DEFAULT_KEEPALIVE_MILLIS就是默认10L，这里就是10秒。这个线程池有点像是CachedThreadPool和FixedThreadPool 结合了一下。 不仅设置了核心线程数，最大线程数也是Integer.MAX_VALUE。 这个线程池是上述4个中唯一一个有延迟执行和周期执行任务的线程池。 适用：周期性执行任务的场景（定期的同步数据） 参考链接：深入理解 Java 线程池：ThreadPoolExecutor]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>Java源码</tag>
        <tag>Java并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的艺术-数据类型详解]]></title>
    <url>%2F2018%2F10%2F07%2FJava%E7%9A%84%E8%89%BA%E6%9C%AF-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一文道尽Java数据类型怎么用。 一、什么是数据类型 数据类型在计算机语言里面，是对内存位置的一个抽象表达方式，可以理解为针对内存的一种抽象的表达方式。 Java是强类型语言，所以Java对于数据类型的规范会相对严格。数据类型是语言的抽象原子概念，可以说是语言中最基本的单元定义，在Java里面，本质上讲将数据类型分为两种：基本类型和引用数据类型。 基本类型：简单数据类型是不能简化的、内置的数据类型、由编程语言本身定义，它表示了真实的数字、字符和整数。 引用数据类型：Java语言本身不支持C++中的结构（struct）或联合（union）数据类型，它的复合数据类型一般都是通过类或接口进行构造，类提供了捆绑数据和方法的方式，同时可以针对程序外部进行信息隐藏。 不同数据类型的变量在内存中分配的字节数不同，同时存储方式也是不同的。所以Java给变量赋值前需要先确定变量的类型，确定了变量的类型，即确定了数据需分配内存空间的大小，数据在内存的存储方式。 二、Java基本类型和对应的包装类型为了方便对基本类型进行操作，Java为每个基本类型提供了对应的包装类型（引用类型）。 基本数据类型byte：Java中最小的数据类型，在内存中占8位(bit)，即1个字节，取值范围-128~127，默认值0 short：短整型，在内存中占16位，即2个字节，取值范围-32768~32717，默认值0 int：整型，用于存储整数，在内在中占32位，即4个字节，取值范围-2147483648~2147483647，默认值0 long：长整型，在内存中占64位，即8个字节-2^63~2^63-1，默认值0L float：浮点型，在内存中占32位，即4个字节，用于存储带小数点的数字（与double的区别在于float类型有效小数点只有6~7位），默认值0 double：双精度浮点型，用于存储带有小数点的数字，在内存中占64位，即8个字节，默认值0 char：字符型，用于存储单个字符，占16位，即2个字节，取值范围0~65535，默认值为空 boolean：布尔类型，占1位，1个字节或者四个字节(存在不同解释角度)，用于判断真或假（仅有两个值，即true、false），默认值false。 Java中基本类型的存储是固定字节的，具体大小与对应的包装类型如下： 基本类型 存储位数 包装类型 boolean 1,8,32 Boolean byte 8 Byte char 16 Character short 16 Short int 32 Integer long 64 Long float 32 Float double 64 Double X X BigInteger X X BigDecimal 封装类型特征 每个基本类型都有一个包装类，这些包装类包含在java.lang包中。继承关系如下： Object Boolean Number Byte Short Integer Long Float Double BigInteger BigDecimal Character BigInteger、BigDecimal没有相对应的基本类型，主要应用于高精度的运算，BigInteger 支持任意精度的整数，BigDecimal支持任意精度带小数点的运算。 当整数类型的数据使用字面量赋值的时候，默认值为int类型，就是直接使用0或者其他数字的时候，默认值的类型为int类型，所以当使用 long a = 0这种赋值方式的时候，JVM内部存在数据转换。 浮点类型的数据使用字面量赋值的时候，默认值为double类型，就是当小数字面量出现的时候，JVM会使用double类型的数据类型。 从JDK 5.0开始，Java包含自动拆箱装箱的特性.调用valueOf()方法。 缓存池基本类型对应的缓冲池如下： -boolean values true and false all byte values short values between -128 and 127 int values between -128 and 127 char in the range \u0000 to \u007F 三、在内存中的存储方式 基本数据类型：所有的简单数据类型不存在“引用”的概念，基本数据类型都是直接存储在内存中的堆、栈上； 引用类型：引用类型继承于Object类（也是引用类型）都是按照Java里面存储对象的内存模型来进行数据存储的，使用Java内存堆和内存栈来进行这种类型的数据存储，简单地讲，“引用”是存储在有序的内存栈上的，而对象本身的值存储在内存堆上的； 关于基本数据类型存放的位置取决于基本类型声明的位置： 在方法中声明的变量，即该变量是局部变量，每当程序调用方法时，系统都会为该方法建立一个方法栈，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，其对应在该方法中声明的变量随着栈的销毁而结束，这就局部变量只能在方法中有效的原因。方法中声明的变量可以是基本类型的变量，也可以是引用类型的变量。（1）当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在方法栈中（2）当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在方法的栈中，该变量所指向的对象是放在堆类存中的。 在类中声明的变量是成员变量，也叫全局变量，放在堆中的（因为全局变量不会随着某个方法执行结束而销毁）。同样在类中声明的变量即可是基本类型的变量 也可是引用类型的变量。（1）当声明的是基本类型的变量其变量名及其值放在堆内存中的（2）引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中 基本类型和封装类型异同 基本类型不是对象 声明方式不同：包装类型需要用new。 存储方式和存储位置不同 初始值不同：boolean初始为false,int为0，而Boolean和Integer都为null。 使用方式和场景不同：基本类型数据存储相对简单，运算效率比较高。使用包装类型会牺牲一些转换效率，但可以避免持久化数据时产生的一些异常。同时，集合的元素必须是对象类型，满足了java一切皆是对象的思想。 销毁效率不同：基本类型定义的变量创建和销毁很快，而类定义的变量还需要JVM去销毁。 四、类型转换基本类型之自动类型转换注意，只能低精度转向高精度。12345char char1 = 'a';char char2 = 'b';int int1 = char1 + 1;//这里即自动类型转换。int int2 = char1 +char2;//这里也完成了自动类型转换。//char2 = int1;//出错 基本类型之强制类型转换12345char char1 = 'a';char char2 = 'b';int int1 = 5;char char3 =(char)int1;char char4 = (char)(char1 + char2);//这里也完成了强制类型转换。 基本类型→包装类型这主要是包括构造方法和装箱操作。还有valauOf()方法。 （1）拆箱与装箱编译器会在自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。123Integer a = 8;int b = 8;System.out.println(a == b);//true 注意区分拆箱和装箱，以及对象比较：1234567int int1 = 9;Integer a = 9;Integer c = new Integer(9);System.out.println(int1 == c);//true，比较值System.out.println(a == int1);//true，比较值System.out.println(a == c);//false，比较引用 （2）构造方法12//charCharacter(char value) 12345//booleanpublic Boolean(boolean value)public Boolean(String s)//注意，这个构造方法是输入的字符串是忽略大小写，相见源码：return ((s != null) &amp;&amp; s.equalsIgnoreCase("true")); 其余的Byte、Int、Double、Long、Short都包含两个构造方法，一个传入本身的基本类型，一个传入一个String类型。 注意，Float包含三个构造函数，除了上述两个，还可以传入double基本类型的值，源码如下：123public Float(double value) &#123; this.value = (float)value; &#125; （3）valueOf():使用上等价于构造方法valueOf()方法等价于构造方法，能用构造方法得到的包装对象也可以用同样的方法通过valueOf()得到。valueOf() 方法的实现是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。编译器会在自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。 （4）String →基本类型的其他方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//Integer to Stringpublic static int parseInt(String s) throws NumberFormatException &#123; return parseInt(s,10); &#125;public static int parseInt(String s, int radix) throws NumberFormatException &#123; /* * WARNING: This method may be invoked early during VM initialization * before IntegerCache is initialized. Care must be taken to not use * the valueOf method. */ if (s == null) &#123; throw new NumberFormatException("null"); &#125; if (radix &lt; Character.MIN_RADIX) &#123; throw new NumberFormatException("radix " + radix + " less than Character.MIN_RADIX"); &#125; if (radix &gt; Character.MAX_RADIX) &#123; throw new NumberFormatException("radix " + radix + " greater than Character.MAX_RADIX"); &#125; int result = 0; boolean negative = false; int i = 0, len = s.length(); int limit = -Integer.MAX_VALUE; int multmin; int digit; if (len &gt; 0) &#123; char firstChar = s.charAt(0); if (firstChar &lt; '0') &#123; // Possible leading "+" or "-" if (firstChar == '-') &#123; negative = true; limit = Integer.MIN_VALUE; &#125; else if (firstChar != '+') throw NumberFormatException.forInputString(s); if (len == 1) // Cannot have lone "+" or "-" throw NumberFormatException.forInputString(s); i++; &#125; multmin = limit / radix; while (i &lt; len) &#123; // Accumulating negatively avoids surprises near MAX_VALUE digit = Character.digit(s.charAt(i++),radix); if (digit &lt; 0) &#123; throw NumberFormatException.forInputString(s); &#125; if (result &lt; multmin) &#123; throw NumberFormatException.forInputString(s); &#125; result *= radix; if (result &lt; limit + digit) &#123; throw NumberFormatException.forInputString(s); &#125; result -= digit; &#125; &#125; else &#123; throw NumberFormatException.forInputString(s); &#125; return negative ? result : -result; &#125; 其他类包括了parseByte(),parseDouble()等。 包装类型→基本类型（1）包装类型到对应基本类型根据继承关系，继承自java.lang.Number的包装类型都包含了Number类的如下公共无参方法，源码如下：123456789101112131415161718public abstract int intValue(); public abstract long longValue(); public abstract float floatValue(); public abstract double doubleValue(); public byte byteValue() &#123; return (byte)intValue(); &#125; public short shortValue() &#123; return (short)intValue(); &#125; 类似的，对于Charcter类：123public char charValue() &#123; return value; &#125; 对于Boolean类：123public boolean booleanValue() &#123; return value; &#125; （2）包装类型→String类型 除此外，所有的包装类型都可以用toString()方法得到字符串类型的对象。 12345//Characterpublic String toString() &#123; char buf[] = &#123;value&#125;; return String.valueOf(buf);//实际上调用String类的valueOf()方法。 &#125; 1234//Booleanpublic String toString() &#123; return value ? "true" : "false"; &#125; 1234567//Floatpublic String toString() &#123; return Float.toString(value); &#125;public static String toString(float f) &#123; return FloatingDecimal.toJavaFormatString(f); &#125; 1234567//Double public String toString() &#123; return toString(value); &#125;public static String toString(double d) &#123; return FloatingDecimal.toJavaFormatString(d); &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//Integerpublic String toString() &#123; return toString(value); &#125;//注意看这里，java是如何把int类型的数转换成String的public static String toString(int i) &#123; if (i == Integer.MIN_VALUE) return "-2147483648"; int size = (i &lt; 0) ? stringSize(-i) + 1 : stringSize(i);//得到i的字符数 char[] buf = new char[size];//buf存储字符 getChars(i, size, buf); return new String(buf, true); &#125;static void getChars(int i, int index, char[] buf) &#123; int q, r; int charPos = index; char sign = 0; if (i &lt; 0) &#123; sign = '-'; i = -i; &#125; // Generate two digits per iteration while (i &gt;= 65536) &#123; q = i / 100; // really: r = i - (q * 100); r = i - ((q &lt;&lt; 6) + (q &lt;&lt; 5) + (q &lt;&lt; 2)); i = q; buf [--charPos] = DigitOnes[r]; buf [--charPos] = DigitTens[r]; &#125; // Fall thru to fast mode for smaller numbers // assert(i &lt;= 65536, i); for (;;) &#123; q = (i * 52429) &gt;&gt;&gt; (16+3); r = i - ((q &lt;&lt; 3) + (q &lt;&lt; 1)); // r = i-(q*10) ... buf [--charPos] = digits [r]; i = q; if (i == 0) break; &#125; if (sign != 0) &#123; buf [--charPos] = sign; &#125; &#125; 123456789101112//Long，与Integer类似的实现public String toString() &#123; return toString(value); &#125;public static String toString(long i) &#123; if (i == Long.MIN_VALUE) return "-9223372036854775808"; int size = (i &lt; 0) ? stringSize(-i) + 1 : stringSize(i); char[] buf = new char[size]; getChars(i, size, buf); return new String(buf, true); &#125; 12345678910111213//Shortpublic String toString() &#123; return Integer.toString((int)value); &#125;//所以也调用了Integer的这个静态方法public static String toString(int i) &#123; if (i == Integer.MIN_VALUE) return "-2147483648"; int size = (i &lt; 0) ? stringSize(-i) + 1 : stringSize(i);//得到i的字符数 char[] buf = new char[size];//buf存储字符 getChars(i, size, buf); return new String(buf, true); &#125; 1234//Bytepublic String toString() &#123; return Integer.toString((int)value); &#125; 总结常见的类型转换，以Integer为例： int → String (1)int后直接+””(2)s = String.valueOf(i);(3)Integer.toString(i); String→int(1) i = Integer.parseInt(s);(2) i = Integer.valueOf(s).intValue();(3) i = new Integer(s).intValue(); 五、枚举类型Java 5.0版本之后引入的除泛型之外的另外一个强大特性：枚举(Enums)。性能远高于静态类。解决一些固定常量集合的问题上枚举成为唯一首选和推荐的一种方式。枚举类解析 enum 不能使用 extends 关键字继承其他类，因为 enum 已经继承了 java.lang.Enum（java是单一继承）。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>Java源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发(1)-多线程初探]]></title>
    <url>%2F2018%2F10%2F05%2FJava%E5%B9%B6%E5%8F%91(1)-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[本文介绍Java中线程、进程、多线程的概念，详细介绍多线程的不同实现方式，从源码分析Callable()接口和Runnable()接口和FutureTask类。 一、进程与线程进程（Thread）：进程指正在运行的程序。当一个程序进入内存运行，即变成一个进程，进程是处于运行过程中的程序，并且具有一定独立功能，包括由操作系统分配的内存空间。线程(Process)：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。线程池(Thread Pool):基本思想是一种对象池的思想，开辟一块内存空间，里面存放了众多(未死亡)的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省系统资源。并行（Parallen）与并发(Concurrent)：并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。并发不一定是并行的，并行一定是并发的。 如果某个系统支持两个或者多个动作（Action）同时存在，那么这个系统就是一个并发系统。如果某个系统支持两个或者多个动作同时执行，那么这个系统就是一个并行系统。并发系统与并行系统这两个定义之间的关键差异在于“存在”这个词。在并发程序中可以同时拥有两个或者多个线程。这意味着，如果程序在单核处理器上运行，那么这两个线程将交替地换入或者换出内存。这些线程是同时“存在”的——每个线程都处于执行过程中的某个状态。如果程序能够并行执行，那么就一定是运行在多核处理器上。此时，程序中的每个线程都将分配到一个独立的处理器核上，因此可以同时运行。“并行”概念是“并发”概念的一个子集。也就是说，你可以编写一个拥有多个线程或者进程的并发程序，但如果没有多核处理器来执行这个程序，那么就不能以并行方式来运行代码。因此，凡是在求解单个问题时涉及多个执行流程的编程模式或者执行行为，都属于并发编程的范畴。 其他概念： 线程同步（synchronized） 线程间通信 线程死锁 线程控制：挂起、停止和恢复 问题：Java程序运行至少启动几个线程？至少启动两个线程，每当使用 Java 命令执行一个类时，实际上都会启动一个 JVM，每一个JVM实际上就是在操作系统中启动一个线程，Java 本身具备了垃圾的收集机制。所以在 Java 运行时至少会启动两个线程，一个是 main 线程，另外一个是垃圾收集线程。 二、线程的生命周期新建状态:使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。 就绪状态:当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。 运行状态:如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。 阻塞状态:如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种： 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。 死亡状态:一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。 线程在Running的过程中可能会遇到阻塞(Blocked)情况： 调用join()和sleep()方法，sleep()时间结束或被打断，join()中断,IO完成都会回到Runnable状态，等待JVM的调度。 调用wait()，使该线程处于等待池(wait blocked pool),直到notify()/notifyAll()，线程被唤醒被放到锁定池(lock blocked pool )，释放同步锁使线程回到可运行状态（Runnable） 对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。此外，在runnable状态的线程是处于被调度的线程，此时的调度顺序是不一定的。Thread类中的yield方法可以让一个running状态的线程转入runnable。 二、线程的优先级每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。 Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。 默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。 具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。 四、线程的实现Java提供了三种创建线程的方法： (1)实现Runnable接口 声明实现 Runnable 接口的类。该类然后实现 run 方法。然后创建Runnable的子类对象，传入到某个线程的构造方法中，开启线程。 将线程的任务从线程的子类中分离出来，进行了单独的封装。按照面向对象的思想将任务的封装成对象。 避免了java单继承的局限性。步骤： 1、定义类实现Runnable接口。2、覆盖接口中的run方法。。3、创建Thread类的对象4、将Runnable接口的子类对象作为参数传递给Thread类的构造函数。5、调用Thread类的start方法开启线程。 示例：123456789101112public class MyThread2 implements Runnable &#123; int num; public MyThread2(int num) &#123; this.num = num; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + ":" + i + num); &#125; &#125;&#125; (2)继承Thread类本身Thread是程序中的执行线程。Java 虚拟机允许应用程序并发地运行多个执行线程。继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。步骤：12341.定义一个类继承Thread。2.重写run方法。3.创建子类对象，就是创建线程对象。4.调用start方法，开启线程并让线程执行，同时还会告诉jvm去调用run方法 示例：1234567891011121314151617181920212223242526public class MyThread extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(getName() + ":" + i); &#125; &#125;&#125;public class ThreadDemo &#123; public static void main(String[] args) &#123; //创建线程实例 MyThread mt = new MyThread(); //修改线程名字 mt.setName("thread1"); //启动线程 mt.start(); //创建线程实例 MyThread mt2 = new MyThread(); mt2.setName("thread2"); //启动线程 mt2.start(); &#125;&#125; (3)通过Callable和FutureTask创建线程步骤：12341. 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。2. 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。3. 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。4. 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。 示例：123456789101112131415161718192021222324252627282930313233343536public class CallableThreadTest implements Callable&lt;Integer&gt; &#123; public static void main(String[] args) &#123; CallableThreadTest ctt = new CallableThreadTest(); //创建Callable实现类的实例 FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(ctt); //用FutureTask类包装Callble对象，FutureTask对象封装了Callable对象call方法的返回值，因为它实现了Future()接口。 for(int i = 0;i &lt; 100;i++) &#123; System.out.println(Thread.currentThread().getName()+" 的循环变量i的值"+i); if(i==20) &#123; new Thread(ft,"有返回值的线程").start(); //使用FutureTask对象作为Thread对象的target创建并启动新线程 &#125; &#125; try &#123; System.out.println("子线程的返回值："+ft.get()); //使用FutureTask的get方法来获得子线程结束后的返回值。 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; @Override public Integer call() throws Exception //线程执行体，有返回值 &#123; int i = 0; for(;i&lt;100;i++) &#123; System.out.println(Thread.currentThread().getName()+" "+i); &#125; return i; &#125; &#125; 三种方式对比 采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。 使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。 相比于Callable接口，另外两种方式的run()方法没有返回值，而Callable接口的call()方法有返回值，并且可用FutureTask对象捕获。 call() 方法可以抛出异常，run()方法不可以的。 Thread的run()和start()方法的区别start()：该方法是在当前线程中启动一个新的线程，而新启动的线程会调用run()方法，同时该方法不能重复调用；run() ：该方法和普通的方法一样，可以重复执行，不会创建新的线程。 五、终止线程1、当run方法执行完毕，自动终止； 2、使用stop方法，不过这个方法不推荐使用，会有意料不到的后果； 3、使用interrupt方法 六、源码解析Runnable 和 Callable 接口的源码1234567public interface Runnable &#123; public void run();&#125;public interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125; 从源码看返回值的差别： 1）Callable 接口下的方法是 call()，Runnable 接口的方法是 run()。 2）Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值的。 3）call() 方法可以抛出异常，run()方法不可以的。 4）运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。 FutureTask类源码比较FutureTask的源码，从声明来看： 123456public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123; ...&#125;public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; void run();&#125; FutureTask 实现了 Runnable 和 Future，所以兼顾两者优点，既可以在 Thread 中使用，又可以在 ExecutorService 中使用。 其中，Future接口的源码如下：12345678910111213public interface Future&lt;V&gt; &#123; //尝试取消线程任务 boolean cancel(boolean mayInterruptIfRunning); //如果在任务正常完成前将其取消，则返回 true。 boolean isCancelled(); //如果任务已完成，则返回 true。 可能由于正常终止、异常或取消而完成，在所有这些情况中，此方法都将返回 true。 boolean isDone(); //如有必要，等待计算完成，然后获取其结果。 V get() throws InterruptedException, ExecutionException; //如有必要，最多等待为使计算完成所给定的时间之后，获取其结果（如果结果可用）。 V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; FutureTask 实现了 Runnable 和 Future，所以兼顾两者优点，既可以在 Thread 中使用，又可以在 ExecutorService 中使用。 ExecutorService是Java提供的线程池。需要使用线程的时候，可以通过ExecutorService获得线程。它可以有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞，同时提供定时执行、定期执行、单线程、并发数控制等功能，比TimerTask更好。 FutureTask 是为了弥补 Thread 的不足而设计的，它可以让程序员准确地知道线程什么时候执行完成并获得到线程执行完成后返回的结果。 FutureTask 是一种可以取消的异步的计算任务，它的计算是通过 Callable 实现的，它等价于可以携带结果的 Runnable，并且有三个状态：等待、运行和完成。完成包括所有计算以任意的方式结束，包括正常结束、取消和异常。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>Java源码</tag>
        <tag>Java并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库(2)-SQL其他须知]]></title>
    <url>%2F2018%2F09%2F07%2F%E6%95%B0%E6%8D%AE%E5%BA%93(2)-MySQL%E9%AB%98%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[MySQL特性，多表查询，SQL注入以及数据库设计的三范式的介绍。 一、MySQL正则表达式 在数据库(1)-SQL初识中介绍了SQL基础语句。MySQL可以通过 LIKE 来进行模糊匹配。 同时，MySQL也支持使用 REGEXP 操作符来进行正则表达式匹配。 12--查找name字段中以'st'为开头的所有数据：SELECT name FROM tabel_name WHERE name REGEXP '^st'; 二、导入导出数据（1）导出数据 使用 SELECT … INTO OUTFILE 语句导出数据12SELECT * FROM table_nameINTO OUTFILE 'test.txt'; （2）导入数据 A.mysql 命令导入1mysql -u用户名 -p密码 &lt; in_database.sql B.source 命令导入1source /path/in_database.sql C.使用 LOAD DATA 导入数据1LOAD DATA LOCAL INFILE 'database.txt' INTO TABLE mytbl; D.使用 mysqlimport 导入数据1mysqlimport -u root -p --local database_name database.txt 三、多表查询多表查询需要用到各种连接查询，包括内连接和外链接。 (1)多表的建表原则 在事务性数据库中，table一般有三种关系：1 to 1, n to m, 1 to n。 （a）1 to 1 当作是一对多情况，在任意一张表添加一个唯一外键,指向另外一张表。 直接将两张表合并成一张表 （b）n to m 建立一张中间表,将多对多的关系,拆分成一对多的关系,中间表至少要有两个外键,分别指向原来的那两张表 （c）1 to n 在多的一方添加一个外键,指向一的一方的主键 (2)内连接 隐式内连接12SELECT * FROM atable a,btable bWHERE a.col1=b.col2; 显式内连接12SELECT * FROM atable a INNER JOIN btable bON a.col1=b.col2; 区别 隐式内连接: 在查询出结果的基础上去做的WHERE条件过滤 显示内连接: 带着条件去查询结果, 执行效率要高 (3)外连接外连接可分为：左连接、右连接、完全外连接、交叉连接。 左连接:left join 或left outer join.左外连接包含join左表所有行，如果左表中某行在右表没有匹配，则结果中对应行右表的部分全部为空(NULL). 12SELECT * FROM a_table LEFT JOIN b_tableON a.col1=b.col2; 右连接: right join或right outer join右外连接包含right join右表所有行，如果左表中某行在右表没有匹配，则结果中对应左表的部分全部为空(NULL)。 12SELECT * FROM a_table RIGHT JOIN b_tableON a.col1=b.col2; 完全外连接 full join 或 full outer join.完全外连接包含full join左右两表中所有的行，如果右表中某行在左表中没有匹配，则结果中对应行右表的部分全部为空(NULL)，如果左表中某行在右表中没有匹配，则结果中对应行左表的部分全部为空(NULL)。 12SELECT * FROM a_table FULL JOIN b_tableON a.col1=b.col2; 注意：**内外连接中INNER、OUTER都可以省略** (4)交叉连接12--cross joinSELECT * FROM a_table CROSS JOIN b_table 等效于笛卡尔积：1SELECT * FROM a_tabl,b_table; 如果加上条件，ON a.col1=b.col2，则效果等价于INNER JOIN. 四、SQL注入概念 SQL注入是未经授权的人可以访问各种关键和私人数据的漏洞。在SQL注入中，攻击者使用各种命令与DB服务器交互，并从中获取各种数据。SQL注入不是Web或数据库服务器中的缺陷，而是由于编程实践较差且缺乏经验而导致的。它是从远程位置执行的最致命和最容易的攻击之一。 常见SQL注入（1）绕过登陆1SELECT USER from database WHERE username ='admin' AND password ='admin' username和password字段为用户在登陆表单的输入，若服务器将这个命令评估为True，则将授予用户访问权限。 攻击者可以在登录表单中输入以下用户数据：12username:a or 1=1--password:blank 查询变为了：123SELECT USER from databaseWHERE username='a' or 1=1-- AND password='' 这条语句始终为True，因此用户可以访问该数据库。 （2）获得数据库中隐私数据对于一个页面：1site.com/article.php?id=50 网站后台如果没有经过过滤，可能包含这样的SQL查询：1Select * from [表名] where id=50 如果我们将URL修改为：1site.com/article.php?id=5+UPDATE+article+SET+title=&apos;Hacked&apos; 则SQL变成了12Select * from [表名] where id=50;UPDATE article SET title='Hacked'; 甚至可以改为：1site.com/article.php?id=5+SHUTDOWN+WITH+NOWAIT; 从而关闭服务器。 解决办法 1).永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和 双”-“进行转换等。 2).永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。 3).永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。 4).不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。 5).应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装 6).sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky，网站平台就有亿思网站安全平台检测工具。MDCSOFT SCAN等。采用MDCSOFT-IPS可以有效的防御SQL注入，XSS攻击等。 六、数据库设计的三范式第一范式：原子性与属性不可分。 当关系模式R的所有属性都不能在分解为更基本的数据单位时，称R是满足第一范式的，简记为1NF。满足第一范式是关系模式规范化的最低要求，否则，将有很多基本操作在这样的关系模式中实现不了。 第二范式：确保每一列都和主键相关。（符合1NF，同时非主属性完全依赖于主键） 如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式，简记为2NF。 第三范式：确保每列都和主键列直接相关,而不是间接相关。（符合2NF，并且消除传递依赖） 设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，简记为3NF. 总结： 1NF是对属性的原子性约束，要求属性具有原子性，不可再分解； 2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性； 3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。 参考资料：史上最完整的MySQL注入MySQL 事务]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库(1)-SQL初识]]></title>
    <url>%2F2018%2F08%2F05%2F%E6%95%B0%E6%8D%AE%E5%BA%93(1)-SQL%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[SQL语法总结。增、删、改、查，与内建函数。 概念SQL:Structure Query Langeage 结构化查询语言 DDL：数据定义，定义数据库、数据表结构，create,drop,alter,showDML：数据操纵，用来操作数据，insert,update,deleteDCL：数据控制，访问权限和安全，grantDQL：数据查询，select,from,where… (0)用户操作用户权限相关数据保存在mysql数据库的user表中，所以也可以直接对其进行操作 创建用户1create user '用户名'@'IP地址' identified by '密码'; 删除用户1drop user '用户名'@'IP地址'; 修改用户1rename user '用户名'@'IP地址'; to '新用户名'@'IP地址';; 修改密码1set password for '用户名'@'IP地址' = Password('新密码') 用户权限设置123456--授权grant all privileges on db1.tb1 TO '用户名'@'IP'grant select on db1.* TO '用户名'@'IP'grant select,insert on *.* TO '用户名'@'IP'--取消revoke select on db1.tb1 from '用户名'@'IP' (1)数据库操作 安装教程 123初始化后第一次使用数据库要修改密码：ALTER USER 'root'@'localhost' IDENTIFIED BY '新密码';exit;（退出mysql） 创建数据库 123create database name;create database name character set utf8;create database name character set utf8 collate utf8_bin; 查看数据库 1234--查看所有数据库show databases;--查看数据库的定义show create database name; 修改数据库 12--修改字符集alter database name character set 字符集; 删除数据库 1drop database name; 切换数据库 1use name; 查看当前数据库 1select database(); (2)表的操作**create, drop, alter, show** 创建 1234567create tabel tabel_name( 列名 列的类型(长度) 约束,);--创建表的索引CREATE INDEX index_nameON table_name (column_name DESC) 数据类型有： int byte char varchar double float boolean date: YYYY-MM-DD time: hh:mm:ss datetime: YYYY-MM-DD hh:mm:ss(默认null) timestamp: YYYY-MM-DD hh:mm:ss(默认当前时间) text 文本-memo(大数量文本) blob 二进制 约束有： primary key unique not null foreign key check default AUTO_INCREMENT:每次插入新记录时，自动地创建主键字段的值。 查看 123456--查看所有表show tables;--查看指定表show create table name;--查看表结构desc name; 修改表 12345678910--修改表名字rename table table_name to new_name;--添加列colalter table table_name add col_name int not null;--修改列alter table table_name modify 属性 char(3);-- 修改列名alter table table_name change old_name new_name int notnull;--删除列alter table table_name drop col_name; （3）表数据的CRUD操作**insert, delete, update, select** 插入数据12345678insert into table_name values(value1,value2,value3);--当只插入部分字段时,列名不能省略insert into table_name(col1,col2) values(value1,value2);--批量插入insert into table_name values(value1,value2,value3),(value4,value5,value6),(value7,value8,value9); 删除记录12345delete from table_name [where]；--同时，truncate也可以删除表，但是和delete有区别。//delete:DML 一条一条删除数据；(适合删除数据少)truncate table 表名;//truncate：DDL 先删除表再重建表。(适合删除数据多) 修改记录1update table_name set col_name = new_value[where ] ; 查询12345678910111213141516171819202122232425distinct 去重AND &amp; OR 条件Order by (Desc &amp; Asc) 排序Top 查询个数Like+通配符 模糊查询In (1，2，3) 范围匹配Aliases，即as 别名，可省略BetweenUnion：合并两个或多个 SELECT 语句的结果集。Union ALL允许重复。Select into：从一个表中选取数据，然后把数据插入另一个表中。View:基于 SQL 语句的结果集的可视化的表。Nullsisnull()```sql[**Join：引用多个表**][1]&gt;JOIN: 如果表中有至少一个匹配，则返回行```sqlselect column_name(s)from table 1INNER JOIN table 2ONtable 1.column_name=table 2.column_name LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行1234select column_name(s)from table 1LEFT JOIN table 2ON table 1.column_name=table 2.column_name RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行. 1234select column_name(s)from table 1RIGHT JOIN table 2ON table 1.column_name=table 2.column_name FULL OUTER JOIN: 会从左表和右表那里返回所有的行。如果其中一个表的数据行在另一个表中没有匹配的行，那么对面的数据用NULL代替 1234select column_name(s)from table 1FULL OUTER JOIN table 2ON table 1.column_name=table 2.column_name （4）函数用法：1SELECT function(列) FROM 表 包括： avg() count() first() last() max() min() sum() group by 分组 having条件过滤[后面可以接聚合函数] ucase():把字段的值转换为大写。 lcase():把字段的值转换为小写。 mid():用于从文本字段中提取字符。 123我们使用如下 SQL 语句从 "City" 列中提取前 3 个字符。SELECT MID(City,1,3) as SmallCity FROM Persons len() round()：ROUND 函数用于把数值字段舍入为指定的小数位数。 now()：NOW 函数返回当前的日期和时间。 1SELECT ProductName, UnitPrice, Now() as PerDate FROM Products format():FORMAT 函数用于对字段的显示进行格式化。 12SELECT ProductName, UnitPrice, FORMAT(Now(),'YYYY-MM-DD') as PerDateFROM Products 参考链接：SQL 快速参考一千行MySQL学习笔记]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CUDA安装问题解决]]></title>
    <url>%2F2018%2F07%2F29%2FCUDA%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[摘要：CUDA安装失败问题解决。 问题 CUDA安装失败都是由于其中Visual Studio(VS) Intergration无法安装导致： 解决办法 择自定义安装，并不要安装VS组件： 将“CUDAVisualStudioIntegration\extras\visual_studio_integration\MSBuildExtensions”下的文件直接拷贝到“C:\Program Files (x86)\MSBuild\Microsoft.Cpp\v4.0\V140\BuildCustomizations”文件夹中。 “CUDAVisualStudioIntegration”这个可以在默认文件：“C:\Users\用户名\AppData\Local\Temp\CUDA”下找到，但是如果你把NVIDIA安装程序关闭了，那么这个默认文件就会消失的，所以可以等NVIDIA安装程序将数据解压完毕后再去找，肯定能找到。 复制解压后的cudnn文件到cuda对应目录下即可。最后验证安装成功： 12345C:\Users\wufan&gt;nvcc -Vnvcc: NVIDIA (R) Cuda compiler driverCopyright (c) 2005-2017 NVIDIA CorporationBuilt on Fri_Sep__1_21:08:32_Central_Daylight_Time_2017Cuda compilation tools, release 9.0, V9.0.176]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>cuda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux]]></title>
    <url>%2F2018%2F07%2F22%2FLinux%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[摘要：记录使用Linux遇到的问题与解决办法。 1. 无法解析或打开软件包的列表或是状态文件问题的解决方案在通过sudo apt-get install安装软件的时候，可能会出现:1234正在读取软件包列表... 有错误！E: Encountered a section with no Package: headerE: Problem with MergeList /var/lib/apt/lists/??E: 无法解析或打开软件包的列表或是状态文件。 解决方案执行下面两条语句：12sudo rm /var/lib/apt/lists/* -vf #删掉apt下的lists文件下的内容sudo apt-get update # 更新软件源 2. kill -9 与kill 有什么区别?面试的时候遇到这个问题，答案如下： 1、kill -9 id：一般不加参数kill是使用15来杀，这相当于正常停止进程，停止进程的时候会释放进程所占用的资源；他们的区别就好比电脑关机中的软关机（通过“开始”菜单选择“关机”）与硬关机（直接切断电源），虽然都能关机，但是程序所作的处理是不一样的。 2、kill - 9 表示强制杀死该进程；而 kill 则有局限性，例如后台进程，守护进程等； 3、执行kill命令，系统会发送一个SIGTERM信号给对应的程序。SIGTERM多半是会被阻塞的。kill -9命令，系统给对应程序发送的信号是SIGKILL，即exit。exit信号不会被系统阻塞，所以kill -9能顺利杀掉进程。 3. linux 644 权限是什么？在linux系统中,文件或目录的权限可以分为3种: r:4 读 w:2 写 x:1 执行 比如: 最高权限777:(4+2+1)-(4+2+1)-(4+2+1) 第一个7:表示当前文件的拥有者的权限,7=4+2+1 可读可写可执行权限 第二个7:表示当前文件的所属组（同组用户）权限,7=4+2+1 可读可写可执行权限 第三个7:表示当前文件的组外权限,7=4+2+1 可读可写可执行权限 常用的linux文件权限： 12345678444 r--r--r--600 rw-------644 rw-r--r--666 rw-rw-rw-700 rwx------744 rwxr--r--755 rwxr-xr-x777 rwxrwxrwx]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JupyterNotebook教程]]></title>
    <url>%2F2018%2F07%2F15%2FJupyterNotebook%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[摘要：简单总结Jupyter Notebook的教程,方便以后使用。 notebook 界面组成 notebook 的名称 主工具栏，提供了保存、导出、重载 notebook，以及重启内核等选项 快捷键 notebook 主要区域，包含了 notebook 的内容编辑区 两种模式Command mode 和 Edit mode。 在一个cell中，按下Enter,进入Edit模式，按下Esc,进入Command 模式 运行当前cell，并移动到下一个Cell在一个cell中（在command模式下）, Shift + Enter 创建Cell在一个cell中（在command模式下） 按下 a ,即可在这个cell之前创建一个新的cell； 按下 b,即可在这个cell之后创建一个新的cell; Cell中 Code 和 Markdown的切换在一个cell中（在command模式下） 按下y, 进入Code; 按下m, 进入Markdown; 显示Cell中的行数在一个cell中（在command模式下），按下 l 删除Cell在一个cell中（在command模式下）, 按两次d 保存Notebook在一个cell中（在command模式下）, 按下s 启动命令面板在一个cell中（在command模式下）, 按下 Ctrl + Shift + P界面中的小键盘图标也可以启动。 可以通过这个命令面板快速的执行命令。比如我这里将一个cell移动到它下一个cell的下面：在一个cell中（在command模式下），然后按下 Ctrl + Shift + P ，输入 move ，键盘方向键选择要执行的命令即可，然后按下回车即可执行。 Matplotlib 集成如果你用 Python 绘制过图形，那你肯定知道 matplotlib。Matplotlib 是一个用于创建漂亮图形的 Python 库，结合 Jupyter notebook 使用时体验更佳。 要想在 Jupyter notebook 中使用 matplotlib，需要告诉 Jupyter 获取 matplotlib 生成的所有图形，并将其嵌入 notebook 中。为此，需要计算：1%matplotlib inline 译注：要想执行成功，需要先1pip install matplotlib。 运行这个指令可能要花个几秒钟，但是在 notebook 中需要执行一次即可。接下来，我们来绘制一个图形，看看具体的集成效果： 1234567import matplotlib.pyplot as pltimport numpy as npx = np.arange(20)y = x**2plt.plot(x, y) 上面的代码将绘制方程式 y=x^2 。计算单元格后，会得到如下图形： 终极奥义按下键盘的 h。查看所有快捷键~~]]></content>
      <categories>
        <category>Guidances</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Donkeycar教程]]></title>
    <url>%2F2018%2F07%2F13%2FDonkeycar%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[摘要：本教程是基于Donkeycar的智能小车教程。DonkeyCar小车是基于树莓派和Python，利用Keras深度学习框架实现的自动驾驶小车。 一、简介本教程是基于Donkeycar的智能小车教程。DonkeyCar小车是基于树莓派和Python，利用Keras深度学习框架实现的自动驾驶小车。本文档参考和整合Donkeycar文档和创客智造的中英文教程，以及安装可能碰到的问题，以“HSP无限94186 ——1比16有刷无控车型”为模型作详细演示，从硬件，软件，系统整合，模型修改等方面介绍Donkeycar智能小车的实现。整体框架：1) Vehicle - a container class to hold and manage all aspects of the vehicle.2) Parts - modular components of the vehicle that read/write to the memory. This includes sensors, actuators, remote controlers and a datastore.3) Memory - holds the state of the vehicle and is used to pass variables between parts.4) Drive loop - a function of the vehicle that runs ensures each part interacts with the memory. 二、硬件硬件清单配件明细模型要求：我们需要选择：①独立ESC（电子调速器）和接收机的RC小车②选择三线连接器，三线舵机③选择速度更慢的有刷小车模型更容易实现。 推荐配置参考：1:16模型配置 1:10模型配置参数解释：motor是电机的参数，2040就是表示定子外径是20mm，定子高度是40mm，定子的外径和高度越多，定子的铁芯越大，线圈绕的匝数也越多，表现出来就是电机的功率越大。无刷电机KV值定义为转速/V，意思为输入电压增加1伏特(V)，无刷电机空转转速（转/分钟）增加的转速值。ESC的25A是指持续电流25A，这个峰值电流是85A，BEC输出5V，1A。Tcaction：四驱，双差速器。Groung Clearance：小车底部离地面的距离。 购买配置清单（价格仅供参考，更新于2018-7-3） 名称 淘宝地址 价格（税点费+邮费）/元 备注 小车主体 https://item.taobao.com/item.htm?spm=a1z10.1-c.w4004-10687857697.2.14566a1aBpsYGj&amp;id=524795742343 329.8(+20) 无限94182——1比16有刷无控车架（有刷不要遥控）电调（已包含）舵机（已包含） USB电池 https://detail.tmall.com/item.htm?spm=a230r.1.14.9.2c9e646ctC49zM&amp;id=564303977283&amp;cm_id=140105335569ed55e27b&amp;abbucket=13&amp;skuId=3563362700791 49(0.2) 2A 5V输出，小米充电宝 树莓派3B+ https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-14802299686.14.485c40da2EhCk5&amp;id=527630316715 354(21.64) 3B E14中国版 套餐16G，包括SD卡及配件 广角摄像头 https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-14802299686.26.54ba6ae1HJKd7d&amp;id=537191521576 100(6.72) 树莓派摄像头5MP 树莓派杜邦线 https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-14802299686.23.2fd00909E38MRt&amp;id=18189793269 2 树莓派连接线 电机驱动芯片 PCA 9685 https://detail.tmall.com/item.htm?spm=a230r.1.14.1.3bc5178b59bMmJ&amp;id=538283746663&amp;cm_id=140105335569ed55e27b&amp;abbucket=1 15(+5.4) 资料下载https://pan.baidu.com/s/1miRuKti 3D打印架 CAD Files: a360.co/2pf3Dam STL Files: thingiverse.com/thing:2260575 x 需要3D打印机 配件介绍HSP无限94182模型参数：模型结构： 电调（Electronic Speed Control，ESC）电子调速器，主要有两个作用，一是将电池降压，适合接收机和其他舵机的工作电压；二是从接收机获得油门信号，控制马达的转速，从而改变飞机的速度。❤连接方式为：1、电调的输入线与电池连接；2、电调的输出线（有刷两根、无刷三根）与电机连接；（在我们用到的有刷模型中，是红色和黑色的两根比较粗的线）3、电调的信号线（三根红色，白色和黑色的较细的线）与接收机（PCA驱动芯片）连接。 舵机舵机的工作原理：舵机常用的控制信号是一个周期为20毫秒左右，宽度为1毫秒到2毫秒的脉冲信号。当舵机收到该信号后，会马上激发出一个与之相同的，宽度为1.5毫秒的负向标准的中位脉冲。之后二个脉冲在一个加法器中进行相加得到了所谓的差值脉冲。输入信号脉冲如果宽于负向的标准脉冲，得到的就是正的差值脉冲。如果输入脉冲比标准脉冲窄，相加后得到的肯定是负的脉冲。此差值脉冲放大后就是驱动舵机正反转动的动力信号。舵机电机的转动，通过齿轮组减速后，同时驱动转盘和标准脉冲宽度调节电位器转动。直到标准脉冲与输入脉冲宽度完全相同时，差值脉冲消失时才会停止转动。❤连接方式：将输出的三线与对应的PCA驱动板引脚连接。电调和舵机都是标准3线母插头连接只要按照对应的引脚插入驱动板就可以了。(地线一般为黑色或棕色、信号线一般为黄色或白色)。 树莓派+miscro SD存储卡：Raspberry Pi(中文名为“树莓派”,简写为RPi，(或者RasPi / RPI) 1 是为学习计算机编程教育而设计，只有信用卡大小的微型电脑，其系统基于Linux。关于树莓派的详细教程参考7。Raspberry Pi 3B+主板图解：树莓派主板图解 树莓派引脚GPIO定义❤连接方式：1、USB电源接口接入充电宝电源2、摄像头接口连接摄像头3、树莓派和PCA9685连接：只连四根线，3.3v，两根 I2C 引脚 (SDA 和 SCL)，地线 ground。 PCA电机驱动芯片9685（舵机驱动板）资料下载：https://pan.baidu.com/s/1miRuKti详细教程参考9。 PCA9685是一款基于IIC总线通信的12位精度16通道PWM波输出的芯片, 可用于控制舵机、led、电机等设备，i2c通信，节省主机资源。❤连接和使用方式：1、 连接树莓派：GND -&gt; RPi GND（9脚）SCL -&gt; RPi SCL1（5脚）SDA -&gt; RPi SDA1（3脚）VCC -&gt; RPi 3.3V （1脚）V+ -&gt; RPi 5V（本实验中PCA上的V+接口不需要接入电源） 树莓派和PCA9685连接图2、 连接舵机和电调：电调和舵机都是标准3线母插头连接只要按照对应的引脚插入驱动板就可以了。(地线一般为黑色或棕色、信号线一般为黄色或白色，所以对应黑色的线要插在GND对应的针头)。 PCA9685连接图在上图中，两股标准3线母插头分别连接舵机与电调。 广角摄像头WARNING：不要在树莓派开机时插拔摄像头！摄像头需要满足的参数：购买的Camera 5MP广角摄像头参数： 充电宝提供5v2A的usb输出和12V输出，主要给树莓派供电❤连接方式：将充电宝的输出microusb输出连接到树莓派的电源输入端。 3D打印架❤用螺丝和销钉固定在小车车架上。 杜邦线杜邦线可用于实验板的引脚扩展，增加实验项目等。可以非常牢靠地和插针连接,无需焊接,可以快速进行电路试验。本实验中，用来连接树莓派与PCA驱动芯片的对应引脚。 硬件组装组装流程1)，2)两步为3D打印步骤，如果不适用3D打印，可以用纸板和小刀手工完成顶部结构。1) 打印部件（3D打印）用黑色PLA打印零件，层高2毫米，没有支撑。顶部翻转杆设计成倒置打印。用黑色PLA打印零件，0.3mm层高，一个0.5mm喷嘴，没有支撑。顶部翻转杆设计成倒置打印。打印的结构图：2) 清理零件（手工修正）几乎所有3D打印部件都需要清理。重新钻孔，并清理多余的塑料。 3) 组装顶板结构，树莓派电源充电宝顶部结构手工完成后的图片： 4) 将PCA驱动板连接到树莓派利用杜邦线连接，对应的针脚如下：GND -&gt; RPi GND（9脚）SCL -&gt; RPi SCL1（5脚）SDA -&gt; RPi SDA1（3脚）VCC -&gt; RPi 3.3V （1脚）V+ -&gt; RPi 5V（本实验中PCA上的V+接口不需要接入电源）本实验只需要连接四个针脚即可。 5) 将树莓派和PCA驱动板附加到3D打印的底板上。 6) 安装摄像头使用摄像头前，取下相机镜头上的塑料薄膜。安装方式：将树莓派上摄像头插销扒开，插入相机电缆，注意触点的位置，随后按入插销即可。 7) 硬件整合舵机与电调已经在小车上固定好，所以接下来只需用三线母插头把PCA驱动板连接舵机与电调。因为电调和舵机都是标准3线母插头连接只要按照对应的引脚插入驱动板就好。(地线一般为黑色或棕色、信号线一般为黄色或白色，所以对应黑色的线要插在GND对应的针头)。 组装完成几种不同形态智能小车的完成体： 三、软件软件清单❤系统：树莓派系统Ubuntu系统❤在linux下安装donkeycar安装依赖：virtualenv build-essential python3-dev gfortran libhdf5-devhttps://github.com/wroscoe/donkey❤在Windows下安装donkeycarhttps://conda.io/miniconda.htmlhttps://git-scm.com/download/wingit库https://github.com/wroscoe/donkey❤在MAC下安装donkeycarhttps://conda.io/miniconda.htmlhttps://www.atlassian.com/git/tutorials/install-gitxcode-select —installpip install https://storage.googleapis.com/tensorflow/mac/cpu/tensorflow-1.3.0-py3-none-any.whl开源机器学习框架：❤pip install keras==2.0.6❤pip install tensorflow==1.3.0 软件安装安装树莓派系统将SD卡用读卡器连接到本地PC。首先为树莓派安装固件，下载地址：https://www.dropbox.com/s/wiudnm2dcsvoquu/donkey_v22.img.zip?dl=0安装步骤：方法1：使用6中的推荐步骤方法2：利用安装软件Etcher。 安装方法参考教程（For ubuntu）,（For windows）。 设置wifi连接我们需要让树莓派连接wifi热点，从而可以无线操控小车。方法有两种：方法1：SD卡插入树莓派，显示屏，键盘和鼠标连入树莓派，开机后通过界面链接wifi。方法2：（没有显示屏和键鼠条件下）首先，新建一个无线热点。可以使用本地PC新建wifi热点。记录ssid和password。接下来修改树莓派的系统文件：在boot部分的根目录下，新建文件名为wpa_supplicant.conf的文件，文件内容为1234567country=USctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network=&#123; ssid=&quot;&lt;your network name&gt;&quot; psk=&quot;&lt;your password&gt;&quot;&#125; 分别在ssid和psk设置自己的WiFi用户名和密码，注意不能有&lt;&gt;， 设置主机名如果网络中有多个树莓派，还需要修改本树莓派的用户名,以下命令需要将sd卡挂载到Linux上运行，由于创建本文档时只有一个树莓派，所以并没有修改用户名，本文档的所有用户名均为pi，若读者对树莓派的用户名有修改，登录时需要改成自己的用户名和密码。12sudo vi /media/userID/UUID/etc/hostnamesudo vi /media/userID/UUID/etc/hosts 注意用户名只能是小写。然后把SD卡插进树莓派里，给树莓派上电。 设置SSH远程登录首先查看网络环境，树莓派连接的网络是本地连接13创建的共享热点：用抓包工具或者nmap扫描工具查找树莓派的ip地址：或者可以用cmd自带的ARP命令查看相应地址的ARP缓存也可以找到小车地址，arp -a从上图可以找到树莓派的ip地址是192.168.155.2，接着通过ssh登录树莓派，用户名pi,密码asdfasdf ，登录进去之后界面如图所示：另外，可以通过win10自带的移动热点看到连接设备的IP地址：推荐使用的ssh客户端登录软件比如Xshell。 在树莓派镜像安装，升级donkeycar存储卡图像上的donkeycar Python代码可能比Github repo上的要早，所以一旦你运行了Pi，需要更新，在ssh客户端连接树莓派后，键入命令如下：123cd ~/donkeycargit pullpip install -e . 在本地PC安装donkeycar并创建本地工作目录接下来是在本地笔记本电脑或服务器上设置相同的代码库，以便测试和训练智能小车。安装因平台而异。有如下三种方法，仅给出了windows上的安装结果。 Windows系统❤安装miniconda Python 3.6 64 bit. https://conda.io/miniconda.html❤确保选中该框以允许它修改您的系统路径变量以添加conda。❤安装git 64 bit，https://git-scm.com/download/win❤从开始菜单启动Anaconda❤更改为您希望用作项目主管的目录12mkdir projectscd projects ❤安装donkeycar12git clone https://github.com/wroscoe/donkeycd donkey ❤创建Python Anaconda环境12conda env create -n donkeycar -f install\envs\windows.ymlactivate donkey ❤安装代码源并创建您的本地工作目录：12pip install -e .donkey createcar --path ~/d2 #本地工作目录名称设置为d2，可以自己定义 安装结果：注意：在关闭Anaconda提示符后，当再次打开它时，您需要键入activate donkey以重新启用映射到特定于donkey的Python库。（关于anaconda的使用，可以参考10）项目主管目录示例：创建的本地工作目录示例： Linux系统❤安装依赖和python环境12345sudo apt-get install virtualenv build-essential python3-dev gfortran libhdf5-devvirtualenv env -p python3source env/bin/activatepip install keras==2.0.6pip install tensorflow==1.3.0 ❤安装donkeycar12git clone https://github.com/wroscoe/donkey donkeycarpip install -e donkeycar Mac系统❤安装miniconda Python 3.6 64 bit. https://conda.io/miniconda.html❤安装git 64 bit，https://git-scm.com/download/win❤启动终端❤如果Xcode or gcc 没安装1xcode-select --install ❤创建项目根目录12mkdir projectscd projects ❤下载donkeycar12git clone https://github.com/wroscoe/donkeycd donkey ❤创建Python Anaconda环境12conda env create -f envs/mac.ymlsource activate donkey ❤安装Tensorflow1pip install https://storage.googleapis.com/tensorflow/mac/cpu/tensorflow-1.3.0-py3-none-any.whl ❤安装donkey12pip install -e .donkey createcar --path ~/d2 注意：关闭终端后，当您再次打开终端时，您需要键入1source activate donkey 来重新启用映射到特定于donkey的Python库。 四、运行智能小车WARNING：先放置到安全地方并让轮子离地！ Windows系统-打开Anaconda-激活映射到donkey的Python设置：donkey123```-进入管理donkey的本地目录：```cd ~/d2 远程登录树莓派-用Xshell登录，详细见3.2.4节。 启动和控制小车-在Xshell连接成功后，打开你小车目录，并开启小车12cd ~/d2python manage.py drive -这个脚本将启动你的小车，其中包括一个作为Web服务器的部件，以便控制你的小车。-现在可以通过以下网址从网络浏览器控制您的汽车：1&lt;your car&apos;s IP&apos;s address&gt;:8887 接下来在本地PC通过浏览器（推荐Chrome浏览器）登录上述网址，在web端控制智能小车： 校准小车小车的配置信息是存在config.py脚本中的，这个脚本会在运行1donkey createcar --path ~/d2 这个命令之后出现在”./d2”这个目录下，如下所示：其内容是各个部件的参数配置：校准小车的目的就是将上述参数调整到合适的值，这样才能顺利的驾驶小车，以及共享同款小车的校准数据。 舵机校准（转向校准）要填的数据有：注意，此时应让小车离开地面，避免乱跑1、打开小车，找到舵机伺服电缆插到了PCA的那个通道上了，应该是1或者0.2、运行命令1donkey calibrate --channel &lt;your_steering_channel&gt; 3、输入 360’会看到小车的轮子轻微转动，如果没有的话就输入400或者3004、左右调整 +/- 10，一直到轮子完全转向左边或者右边，记录此时的值，并填入config.py 马力校准（电机控制）需要校准的参数：1、找到ESC的电缆，看看它插到PCA的哪个位置，这就是马力通道。2、运行命令1donkey calibrate --channel &lt;your_throttle_channel&gt; 当提示输入PWM值的时候输入370，此时应该能听到ESC发出哔哔声，表示已经经过校准。3、输入400，这时小车应该就能往前走了，如果不能往前，则有可能是反向的，此时应该输入3304、多尝试几次，直到找到你认为比较合适的最大速度，记下此时的PWM值。 校准微调现在小车已经校准过了，可以开动小车查看是否按照预期运行：1、运行1python manage.py drive 命令启动小车2、在浏览器中访问1&lt;your_cars_ip_address&gt;:8887 3、按j，一直到小车的方向完全转向右边4、按i，一直到小车的方向完全朝向前方5、测量转弯直径，并将它记录在表格中6、在不同的转向值下重复同样的测量7、绘制表格看看小车在各个方向的转向是否相同（角度相同时）如果你的转向在80%PWM和100%PWM相同时，将PWM值变为80%PWM,如果你的车往一边偏，改变另一边的PWM值经过微调之后你的表格大概会是这个样子 五、训练智能小车赛道设置可以用带颜色的胶带、丝带或者绳子，赛道最好宽4英尺，并且有2英寸的白色边框和黄色虚线中线。 数据收集① 先不记录数据，在跑道上跑几圈，当熟练跑道之后（10圈以上不出错）点击按钮Start Recording② 如果出错或者有意外发生时马上点击Stop Car停止记录③ 至少收集10-20圈好的数据之后即可以停止收集，Ctrl-c即可，收集的数据在data文件夹里 需要注意的细节： 1.清除d2/data目录下的之前的数据2.回到d2目录下python namage.py drive启动小车3.到浏览器中model选择user，然后用电脑控制小车在场景下跑几圈4.等到操作小车在场景下基本不出错之后点击start recording开始记录数据5.记录大约半个小时的数据就可以了注意在记录数据的过程中，可能会出现小车没电的情况，解决的办法就是，刚开始在config.py文件中把THROTTLE_FORWARD_PWM设置的小一点，本车是335或者330，过一会感觉小车跑的变慢了，停止记录，停下小车，关闭程序。调整THROTTLE_FORWARD_PWM变大一点到440，重启程序，记得保持小车的运行速度以及Throttle差不多一致。同理慢慢可以变为445和4506.记录完数据，筛选数据。手动删除数据中撞墙等不好的数据7.将数据考到电脑上装的donkey的d2/data目录下（小文件太多，速度会特别慢）8.进入d2目录，运行命令 python manage.py train --model ~/d2/models/mypilot9.等待训练结束，到到d2/models下将mypilot文件发送到小车的对应目录下10.用命令python manage.py drive --model ~/d2/models/mypilot启动小车，然后到浏览器中选择local pilot模式启动自动驾驶 拷贝数据至本地PC由于树莓派计算能力有限，需要将数据迁移到电脑上进行模型的训练，有两种方法： 方法1：新开一个SSH窗口用rsync命令从树莓派复制数据。命令如下：1rsync -r pi@&lt;your_pi_ip_address&gt;:~/d2/data/ ~/d2/data/ 方法2：利用Xshell里面的新建文件传输直接复制粘贴。 利用keras训练模型复制好数据之后就可以运行训练脚本：1python ~/d2/manage.py train --tub &lt;tub folder names comma separated&gt; --model ./models/mypilot 或者：1python ~/d2/manage.py train --model ~/d2/models/mypilot 拷贝模型至树莓派训练好之后再讲pilot迁移回树莓派：1rsync -r ~/d2/models/ pi@&lt;your_ip_address&gt;:~/d2/models/ 用自动驾驶模型启动小车重新启动小车，将训练好的模型穿进去：1python manage.py drive --model ~/d2/models/mypilot 用模拟器训练小车*用于生成训练用的图片，测试自动驾驶仪等。当然你也可以不用这种方法，根据网页【http://docs.donkeycar.com/guide/build_hardware/】的描述，你也可以先用手机控制小车在赛道上开10-20次来收集训练数据。下载之后直接双击EXE文件运行，你可以在input里面看到控制按钮信息。模拟器中共有三个场景，但是网站【http://docs.donkeycar.com/guide/simulator/】中只给了前两种的描述，第三种是sparkfun AVC机器人大赛的场景：Generated Road Scene：通用场景The purpose of this is to create a randomly generated road so that you can have miles of curves on different road surfaces. You can train on one road and test on something similar, or a totally different surface.Warehouse Scene：专用场景The purpose of this is to create a specific track that is somewhat similar to an actual course in use as the primary track for the Oakland DIYRobocars Meetup. 进入模拟器，右上角可以选择操作选项，根据网站【http://docs.donkeycar.com/guide/simulator/】的介绍，Joystick/Keyboard No Rec的意思就是摇杆或者键盘控制，但是数据不记录，其他选项意思类推。Next Track：在生成的道路场景中，这将改变路面和轨道宽度。Regen Track：使用当前的表面类型，但生成一个新的随机路径和路径。下图为我用键盘控制时的截图，在网站【http://docs.donkeycar.com/guide/simulator/】的介绍中，有一个注意事项是这样描述的：Note: Keyboard data produces steering information that is stepped (ie. -1, 0, +1) and may be difficult to train with. See below for joystick setup.大意是说由于键盘控制并不像摇杆可以产生连续的转向信息，而只能是间断的，所以并不适合用来训练。键盘控制页面下图为自动驾驶页面，可以看到左下角一共有四个参数，目前并没有搞得很清楚这四个参数的具体含义，暂且先贴出网页【http://docs.donkeycar.com/guide/simulator/】上的解释：Max Speed：这个应该就是决定了自动驾驶的最大速度This setting determines the target speed during the PID auto drive. It will also affect the speed when driving by keyboard controls (not recommended).Prop：转向角度This is short for proportional. This is the P part of PID that attempts to adjust steering back to the path in proportion to the deviation.Diff：为了防止角度调整过大This is the D part of PID that attempts to limit steering back to the path as derivative to the trend of deviation, designed to limit overshoot.Max SteeringMax steering can only be adjusted when using Auto Drive No Rec. It will also affect joystick and keyboard steering range, and should be saved and reloaded for you.另外关于这个参数，原文中有一个注意事项： Max Steering is an important adjustment. This affects categorical training quite strongly. As the steering data is normalized when written, and multiplies after coming from Python, this angle should remain constant over training and simulation. Take care when changing this value. And separate data and models by max steering setting.自动驾驶时的截图训练结束后，在log目录中会有训练的图片，图片大小为160*120像素贴一个网页【http://docs.donkeycar.com/guide/simulator/】上给出的典型用法，方便以后使用。 六、更新DonkeycarV2.5教程 用Etcher给SD卡写入树莓派系统镜像文件名为：donkey_2.5.0_pi3.img，新建并编辑boot目录下的wpa_supplicant.conf文件。 SSH连接树莓派并登陆。 12用户名：pi密码：raspberry 在树莓派上安装Donkeycar V2.5.1环境 12pip install donkeycar[pi]donkey createcar ~/ 在windows上安装DonkeycarV2.5.1（注意区分本地工作目录与本地代码目录）a)新建一个本地代码目录，存放代码库： 12mkdir projectscd projects b)从github上clone最新的donkeycar代码库12git clone https://github.com/wroscoe/donkeycd donkey c)安装donkeycar资源环境，新建本地工作目录（mycar）12pip install -e .donkey createcar C:\Users\WuFan\new_mycar(自己修改) 会遇到的问题：a)ModuleNotFoundError: No module named ‘controller’：解决办法：将文件（可直接复制粘贴word中的这个文件）拷贝至\donkey\donkeycar\parts对应的本地代码目录下。修改本地工作目录中文件“manage.py”中第24行，修改为：1from donkeycar.parts.controller import LocalWebController, JoystickController b)训练后的数据存放在树莓派tub文件夹下，而不是data训练的时候，把tub文件夹下所有数据复制到本地工作目录下的data文件夹下。再开始训练。c)用训练的模型驾驶的时候，切换到local pilot时，可能会遇到类似摄像头框消失，树莓派报错的情况。这是因为树莓派上有的python文件版本和本地电脑从github上面clone的文件不一致。如果有报这种错误，可以把本地代码库上面的对应文件覆盖到树莓派上解决。 七、参考创新方向无人驾驶车障碍竞速无人取件车/送餐车/领路车无人捡球车参考文献 [ ] https://docs.donkeycar.com/ [ ] https://www.ncnynl.com/archives/201804/2398.html [ ] https://github.com/OSSDC/donkey [ ] https://github.com/wroscoe/donkey\ [ ] https://docs.donkeycar.com/guide/build_hardware/ [ ] https://www.donkeycar.com/ [ ] http://www.makerspace.cn/thread-5681-1-1.html [ ] https://www.raspberrypi.org/blog/self-driving-car/ [ ] https://blog.csdn.net/nicekwell/article/details/53616277 [ ] https://python.jobbole.com/87522/ [ ] https://bbs.pediy.com/thread-221193.htm [ ] https://www.xue51.com/soft/2044.html]]></content>
      <categories>
        <category>Guidances</category>
      </categories>
      <tags>
        <tag>donkeycar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Conda常用命令]]></title>
    <url>%2F2018%2F05%2F02%2FConda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[摘要：使用Anaconda管理python各种python环境和库，可以极大提高在不同项目切换的效率。 帮助与版本 查看当前conda版本 12conda -Vconda -version 更新conda 12conda update condaconda update anaconda #更新anaconda 某个命令的帮助信息 1conda install --help 环境管理 查看当前环境 1conda info -e 查看所有环境 12conda info --envsconda env list 创建新的环境 123456conda create --name environment_name#创建不同python版本的环境conda create --name environment_name python=3.6conda create --name environment_name python=2.7#创建时添加库的环境conda create --name environment_name numpy scipy 切换环境 123456#切换到新环境activate environment_name#在linux于macos系统中，激活环境的命令为：source active environment_name#退出环境deactivate environment_name 移除环境 12#conda remove --name environment_name --allconda remove -n py36 --all 复制某个环境 1conda create --name new_name --clone old_name 保存环境配置信息 1conda env export &gt; environment.yml 读取环境配置信息 1conda env create -f environment.yml Note: 当遇到错误”SpecNotFound: Can’t process without a name”时，因为导入环境时目录有问题，所以需要检查.yml文件的path是否有误。 包管理 列举当前环境下所有包 1conda list 列举某个环境下所有包 1conda list -n environment_name 查找某个包 1conda search package_name 为指定环境安装某个包 1conda install -n environment_name package_name 更新包 1conda update package_name 卸载包 1conda remove package_name 设置镜像访问国外资源网速较低时，可以考虑改变源，使用国内镜像1conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --set show_channel_urls yes]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对抗攻击防御策略一览]]></title>
    <url>%2F2018%2F04%2F17%2F%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E9%98%B2%E5%BE%A1%E7%AD%96%E7%95%A5%E4%B8%80%E8%A7%88%2F</url>
    <content type="text"><![CDATA[摘要：根据最近的学习，按照自己的理解给不同对抗攻击的防御方法作简单总结。对抗防御从形式上看可以被分为三类：①对抗样本检测；②改变对抗样本；③增强模型。 ①对抗样本检测：指根据对抗样本与原始样本的分布差异，在模型Inference阶段将对抗样本区分出来。 检测对抗样本的方法有： 1） 基于统计检验的检测（Sample statistic）：这种方法比较直接，效果也比较差，并且因为是基于大量对抗样本的统计结论，因此需要大量对抗样本挖掘其统计规律，在检测的时候也不适于检测单个对抗样本。常见的统计检验方法如下：A． Maximum mean discrepancy and energy distance.【Kathrin Grosse, Praveen Manoharan, Nicolas Papernot, Michael Backes, and Patrick McDaniel. On the (Statistical) Detection of Adversarial Examples. arXiv preprint arXiv:1702.06280, 2017.】 但是这种方法不能对单个样本作出预测，只能揭示对抗样本与原始样本在平均偏差和距离的差异，不具有检测对抗样本的可行性。B． Kernel density estimation【Reuben Feinman, Ryan R Curtin, Saurabh Shintre, and Andrew B Gardner. Detecting Adversarial Samples from Artifacts. arXiv preprint arXiv:1703.00410, 2017.】这种方法即是在折叠的空间中计算一个测试样本和所有初始样本的距离，根据数据特征降维之后的差异区分对抗样本和真实样本。这种方法的缺陷是需要很大的计算资源，并且只能检测出对抗攻击时添加的对抗扰动比较大，让对抗样本和原始样本差异比较大的情况。C. 输入特征差异：包括JSMA攻击的论文中提到的，利用相邻像素间的平方差检测对抗样本。（这个方法前面的讨论中提到过，缺乏直观的合理性，所以也没什么价值） 2） 训练检测器（Detector）：将对抗样本和原始样本作为训练集进行监督训练。而检测器的训练包括两种：一种是直接将对抗样本和原始样本，打上label作为训练集训练一个分类器；另一种是将原始数据和对抗样本数据通过原始分类模型后，在输出层的值（或某一层神经网络层的输出值）打上label作为训练集训练一个分类器。 3） 预测结果差异（Prediction Inconsistency）根据预测结果差异来检测对抗样本主要有三种：(1)对抗样本和正常样本在原始模型的输出层差异。利用这种差异来检测对抗样本和原始样本，需要利用第2）点中构建一个检测器来实现；或者像我们前面的工作——根据模型输出层的统计差异来区分，但是这种方法不能对单个对抗样本做出判断。(2)对抗样本和原始样本经过特征处理之后，他们在输出层的变化不同。这种方法在前面的报告中提到了，这部分内容在后面的部分详细给出。(3)对抗样本在不同的模型下输出差异。这部分内容和前面和老师讨论的依据Byzantine Generals problem来设计系统相关联，让对抗样本经过多个分类模型，按照3t+1的原则，保证分类输出的正常。其中，不同的模型获得方式有很多，一种是其他能应用于同一个任务的分类模型，比如在用VGG16分类时，用ResNet，WRN，DenseNet等同样能用作分类的网络模型作为参照，检测出对抗样本。另外一种就是基于原始模型的修改，包括结构的修改和训练过程的修改，不同的修改过程可以得到不同的子模型。比如在训练过程中，每次训练采用不同的dropout策略，可以得到几个类似功能的分类模型，只要测试样本在这几个分类模型上满足拜占庭问题的解，就可以判断为是原始样本。 ②改变对抗样本：1）用对抗攻击的方法处理对抗样本，让对抗样本重新被分类准确。2）用特征处理的方法处理对抗样本，让对抗样本重新被分类准确。3) Denoise the adversarial perturbation4）添加去噪器，构建生成式模型，例如APE-GAN ③增强模型：1） 用更多数据训练，增强模型的泛化能力。包括对抗训练。2） 修改模型的激活函数或者损失函数。3） 使用network add-on，包括利用GAN，Defensive distillation。]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>papernotes</tag>
        <tag>adversarial attack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Academic Writing Lessons]]></title>
    <url>%2F2018%2F03%2F30%2FAcademic%20Writing%20Lessons%2F</url>
    <content type="text"><![CDATA[Academic Writing Lessons Use Better alternative words Original Better alternative consider evaluate,assess check verify,confirm different distinct,diverse,various,varied little/few seldom,slightly problem limitaion,restriction,obstacle,hindrance need require,stipulate affect influence,shape carry out implement,execute,primulgate,conduct change modify,adjust,alter,vary complicated complex,cumbersome,intricate correct/incorrect precise/imprecise,accurate/inaccurate find determine,derive,attain,locate,identify help assist,facilitate,guide,direct important critical,crucial,essential,pertinent,relevant,significant,vital improve enhance,upgrade,elevate is made of consists of,comprises,is composed of make clear elucidate,clarify makesure ensure,assure meet satisfy,fulfill,adhere to much/strongly markedly,considerably,substantially realize comprehend,preceive,understand solve alleviate,modify,resolve,eliminate,eradicate suitable appropriate,adequate tries attempts,aims,aspires usually normally,typically,generally very highly,rather,quite,extremely way method,means,approach,strategy whole complete,entire,comprehensive is found to be is is capable of can is view of the fact that because in this case here in some cases occasionally in no case never the question as to whether subsequent to after,following serves the function of is reach a conclusion is put an end to end provided that if come to a conclusion conclude by means of by in a position to can be deficient in lack at this point in time now at the present time now notwithstanding the fact that although manner in which how make inquiry regrading ask about,inquire about it is possible that may,might,could,can in most cases uaually in many cases often in large measure largely is in excess of exceeds,surpasses in proximity to near in case if in all cases always a number of several,many,numerous if conditions are such that if happens to be am,is,are give indication of indicate,suggest give consideration to consider for this reason because for the reason that so for the purpose of for/to during the time that while due to the fact that because despite the fact that althought at such time as when ascertain the location of find along the lines of such as a majority of most Formal Grammer and Style Avoid contracion Export figures will not improve until the economy is stronger. Export figures won&#39;t improve until the economy is stronger. Use the more appropriate formal negative forms. not...much -&gt; little not...any -&gt; no not...many -&gt; few Limit the use of “run on” expressions, such as “and so forth” and “etc.” These semiconductors can be used in robots, CD players, etc. —&gt; These semiconductors can be used in robots, CD players, and other electronic devices. Avoid addressing the reader as “you” You can see the results in Table 1. The results can be seen in Table 1. Limit the use of direct questions. Instead, use &quot;we now need to consider...&quot; Place adverbs within the verb. Then the solution can be discarded. The solution can then be discarded. The blood is withdraw slowly. The blood is slowly withdraw. Do not be wordy. (To be continued…)]]></content>
      <categories>
        <category>Guidances</category>
      </categories>
      <tags>
        <tag>lessons</tag>
        <tag>english</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数式编程]]></title>
    <url>%2F2018%2F03%2F29%2Fpython%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[python函数式编程 高阶函数map()和reduce()参考论文map(): 这个函数接收两个参数，一个是函数，一个是Iterable（可迭代对象），map将传入的函数$f(x)$依次作用到序列的每个元素上，并把结果作为新的Iterator（迭代器）返回。12#实现将一个数字序列转化成字符序列list(map(str,[1,2,3,4,5])) reduce(): 把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数$f(x,y)$，reduce把结果继续和序列的下一个元素做累积计算。1234567#对一个序列求和&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; def add(x, y):... return x + y...&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])25 filter()用于过滤序列，和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。返回一个Iterator（这说明返回的依旧是一个惰性序列）。 12345678910111213#删掉一个序列中的空字符串"""注意filter()给函数默认加bool()修正比如：bool(" a")=Truebool(" ")=Truebool(" ".Strip())=Falsebool(None)=False"""def not_empty(s): return s and s.strip()list(filter(not_empty, ['A', '', 'B', None, 'C', ' ']))# 结果: ['A', 'B', 'C'] 1234567891011121314151617#用filter()求素数的方法——埃氏筛法#定义一个筛选函数def _not_divisible(n): return lambda x: x % n &gt; 0#初始化自然数序列def _iter(): n = 1 while True: n = n + 2 yield ndef primes(): yield 2 it = _iter() while True: n = next(it) yield n it = filter(_not_divisible(n), it) 12345678910"""def _iter(): n = 1 while True: yield n n = n + 1"""def is_palindrome(n): return str(n) == str(n)[::-1]list(filter(is_palindrome),range(1000)) sorted()可以实现对list进行排序。同时，可以接受一个key 函数来实现自定义排序。12&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)[5, 9, -12, -21, 36] key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。1234&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'])['Credit', 'Zoo', 'about', 'bob']&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)['about', 'bob', 'Credit', 'Zoo'] 返回函数高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。1234567def lazy_sum(*args): def sum(): ax = 0 for n in args: ax = ax + n return ax return sum &hearts;&hearts;&hearts;&hearts; 闭包&hearts;&hearts;&hearts;&hearts;建议参考教程——知乎专栏闭包概念：在一个内部函数中，对外部作用域的变量进行引用，(并且一般外部函数的返回值为内部函数)，那么内部函数就被认为是闭包。&emsp;在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这称为“闭包（Closure）”的程序结构。&emsp;需要注意的问题是，循环在python中没有域的概念，向列表中添加函数的时候并不会保存循环中变量的值。返回的函数并没有立刻执行，而是直到调用了f()才执行。123456789def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fsf1, f2, f3 = count() 你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是：123456&gt;&gt;&gt; f1()9&gt;&gt;&gt; f2()9&gt;&gt;&gt; f3()9 返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。原因：闭包函数调用外部循环变量时，并没有保存这个值，只保存了变量的地址，要等到调用闭包函数时才会取具体的值，然而此时函数值可能已经发生了变化。解决办法：再定义一个函数，将g()形成闭包。主要是要在函数内部，把可变的循环值i作为函数参数调用。简单来说，一定要有f(i),在调用过程中，i就会被传入。123456789def count(): def f(j): def g(): return j*j return g fs = [] for i in range(1, 4): fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f() return fs 利用闭包返回一个计数器函数，每次调用它返回递增整数：1234567def createCounter() s=[0] def conter(): s[0] += 1 return s[0] return counter 外函数返回了内函数的引用：当我们在python中定义一个函数def demo(): 的时候，内存当中会开辟一些空间，存下这个函数的代码、内部的局部变量等等。这个demo只不过是一个变量名字，它里面存了这个函数所在位置的引用而已。我们还可以进行x = demo， y = demo， 这样的操作就相当于，把demo里存的东西赋值给x和y，这样x 和y 都指向了demo函数所在的引用，在这之后我们可以用x() 或者 y() 来调用我们自己创建的demo() ，调用的实际上根本就是一个函数，x、y和demo三个变量名存了同一个函数的引用。 闭包中内函数修改外函数局部变量： 在闭包内函数中，我们可以随意使用外函数绑定来的临时变量，但是如果我们想修改外函数临时变量数值的时候发现出问题了！ 在基本的python语法当中，一个函数可以随意读取全局数据，但是要修改全局数据的时候有两种方法:1 global 声明全局变量 2 全局变量是可变类型数据的时候可以修改 在闭包内函数也是类似的情况。在内函数中想修改闭包变量（外函数绑定给内函数的局部变量）的时候： 在python3中，可以用nonlocal 关键字声明 一个变量， 表示这个变量不是局部变量空间的变量，需要向上一层变量空间找这个变量。 在python2中，没有nonlocal这个关键字，我们可以把闭包变量改成可变类型数据进行修改，比如列表。 闭包的作用： 装饰器！！！装饰器是做什么的？？其中一个应用就是，我们工作中写了一个登录功能，我们想统计这个功能执行花了多长时间，我们可以用装饰器装饰这个登录模块，装饰器帮我们完成登录函数执行之前和之后取时间。 面向对象！！！经历了上面的分析，我们发现外函数的临时变量送给了内函数。大家回想一下类对象的情况，对象有好多类似的属性和方法，所以我们创建类，用类创建出来的对象都具有相同的属性方法。闭包也是实现面向对象的方法之一。在python当中虽然我们不这样用，在其他编程语言入比如avaScript中，经常用闭包来实现面向对象编程 实现单利模式！！ 闭包可以保存当前的运行环境，以一个类似棋盘游戏的例子来说明。假设棋盘大小为50*50，左上角为坐标系原点(0,0)，我需要一个函数，接收2个参数，分别为方向(direction)，步长(step)，该函数控制棋子的运动。 这里需要说明的是，每次运动的起点都是上次运动结束的终点。 匿名函数在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。 1234567&gt;&gt;&gt; list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))[1, 4, 9, 16, 25, 36, 49, 64, 81]"""其中，lambda x: x * x相当于：def f(x): return x * x""" 同时，匿名函数可以作为返回函数。 装饰器（decorator）装饰器就是一个返回函数的高阶函数，基于闭包原理。定义一个打印日志的decorator:12345def log(func): def wrapper(*args, **kw): print('call %s():' % func.__name__) return func(*args, **kw) return wrapper 定义一个带参数的decorator:1234567def log(text): def decorator(func): def wrapper(*args, **kw): print('%s %s():' % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator 函数也是对象，它有name等属性，但你去看经过decorator装饰之后的函数，123@logdef now(): print('2015-3-25') 它们的name已经从原来的’now’变成了’wrapper’：12&gt;&gt;&gt; now.__name__'wrapper' 因为返回的那个wrapper()函数名字就是’wrapper’，所以，需要把原始函数的__name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。 不需要编写wrapper.__name = func.\name__这样的代码，Python内置的functools.wraps就是干这个事的，所以，一个完整的decorator的写法如下：12345678import functoolsdef log(func): @functools.wraps(func)#复制依赖函数 def wrapper(*args, **kw): print(&apos;call %s():&apos; % func.__name__) return func(*args, **kw) return wrapper 偏函数（Partial function）偏函数可以通过设定参数的默认值，降低函数调用的难度。由Python的functools模块提供。举例说明：123456&gt;&gt;&gt; import functools&gt;&gt;&gt; int2 = functools.partial(int, base=2)&gt;&gt;&gt; int2('1000000')64&gt;&gt;&gt; int2('1010101')85 上面的新的int2函数，仅仅是把base参数重新设定默认值为2，但也可以在函数调用时传入其他值：12&gt;&gt;&gt; int2(&apos;1000000&apos;, base=10)1000000 创建偏函数时，实际上可以接收函数对象、args和*kw这3个参数，当传入：1234int2 = functools.partial(int, base=2)#相当于kw = &#123; &apos;base&apos;: 2 &#125;int(&apos;10010&apos;, **kw) Reference教程]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python可变与不可变对象]]></title>
    <url>%2F2018%2F03%2F19%2Fpython%E5%8F%AF%E5%8F%98%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Abstract：介绍python中的可变对象与不可变对象的概念。 定义 不可变对象，该对象所指向的内存中的值不能被改变。当改变某个变量时候，由于其所指的值不能被改变，相当于把原来的值复制一份后再改变，这会开辟一个新的地址，变量再指向这个新的地址。 可变对象，该对象所指向的内存中的值可以被改变。变量（准确的说是引用）改变后，实际上是其所指的值直接发生改变，并没有发生复制行为，也没有开辟新的出地址，通俗点说就是原地改变。 例子 不可变（immutable）：int、字符串(string)、float、（数值型number）、元组（tuple) 可变（mutable）：字典型(dictionary)、列表型(list)、集合（set） 定义默认参数要牢记默认参数必须指向不变对象！1234567def add_end(L=[]): L.append('END') return L&gt;&gt;&gt; add_end()['END', 'END']&gt;&gt;&gt; add_end()['END', 'END', 'END'] Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。123456789def add_end(L=None): if L is None: L = [] L.append('END') return L&gt;&gt;&gt; add_end()['END']&gt;&gt;&gt; add_end()['END'] 代码示例123456789101112&gt;&gt;&gt; a = [1]&gt;&gt;&gt; id(a)2278158310408&gt;&gt;&gt; a += [2]&gt;&gt;&gt; id(a)2278158310408&gt;&gt;&gt; a = 4 #不可变&gt;&gt;&gt; id(a)1944540032&gt;&gt;&gt; a += 3&gt;&gt;&gt; id(a)1944540128 但是当不可变对象比较大时，这个规律不符合，并不会创建新的对象。常量池 python中的复制，浅拷贝和深拷贝复制只传递对象的引用，也就是对象的地址123456789101112131415&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = a&gt;&gt;&gt; a[1, 2, 3]&gt;&gt;&gt; b[1, 2, 3]&gt;&gt;&gt; id(a)1264995283336&gt;&gt;&gt; id(b)1264995283336&gt;&gt;&gt; a.append(2)&gt;&gt;&gt; a[1, 2, 3, 2]&gt;&gt;&gt; b[1, 2, 3, 2] 浅拷贝指把存放变量的地址值传给被赋值，最后两个变量引用了同一份地址。copy会根据数据类型为可变还是不可变进行判断：如果是不可变类型，和复制相同；如果是可变类型，只是拷贝第一层（也就是对于list类型中，其中的元素中指向的其他地址不变化）。用到的方法是 copy.copy()1234567891011121314151617181920212223&gt;&gt;&gt;import copy&gt;&gt;&gt; c=copy.copy(a)&gt;&gt;&gt; c[1, 2, 3, 2]&gt;&gt;&gt; id(c)1264997856200&gt;&gt;&gt; id(a)1264995283336&gt;&gt;&gt; a[1, 2, 3, 2]&gt;&gt;&gt; b=2&gt;&gt;&gt; c=copy.copy(a)&gt;&gt;&gt; id(a)1264995283336&gt;&gt;&gt; id(c)1264997856264&gt;&gt;&gt; d=copy.copy(b)&gt;&gt;&gt; id(b)1354853888&gt;&gt;&gt; id(d)1354853888 发现，同样是浅拷贝，拷贝后的a和b却给了不同的处理。因为a是list，是可变对象，而b是int数据类型，属于不可变对象。换言之，对于可变对象，浅拷贝与复制不同，拷贝的结果存放在一个新的空间。而对于不可变对象，拷贝和复制的意义相同，都指向同一个地址空间。12345678&gt;&gt;&gt; id(c)1264997856200&gt;&gt;&gt; id(a)1264995283336&gt;&gt;&gt; id(b)1354853888&gt;&gt;&gt; id(d)1354853888 但是，对于不可变对象，当改变某个变量时候，由于其所指的值不能被改变，相当于把原来的值复制一份后再改变，这会开辟一个新的地址，变量再指向这个新的地址。因此，改变一个变量，其地址会发生改变，而原来复制出的变量则指向原来的值。1234567891011121314151617181920212223242526272829&gt;&gt;&gt; a = 2&gt;&gt;&gt; b = a&gt;&gt;&gt; c = copy.copy(a)&gt;&gt;&gt; d = copy.deepcopy(a)&gt;&gt;&gt; id(a)1354853888&gt;&gt;&gt; id(b)1354853888&gt;&gt;&gt; id(c)1354853888&gt;&gt;&gt; id(d)1354853888&gt;&gt;&gt; a = a + 3&gt;&gt;&gt; a5&gt;&gt;&gt; b2&gt;&gt;&gt; c2&gt;&gt;&gt; d2&gt;&gt;&gt; id(a)1354853984&gt;&gt;&gt; id(b)1354853888&gt;&gt;&gt; id(c)1354853888&gt;&gt;&gt; id(d)1354853888 可见，对于不可变对象，深拷贝，浅拷贝，复制 效果一样。 深拷贝包含对象里面的内容的拷贝，重新开辟一个新的空间，所以原始对象的改变不会造成深拷贝里任何子元素的改变。（实际上，一般所谓的拷贝操作，都是在list上进行的，所以只需要知道在lists上着三种拷贝操作的意义和结论即可）深拷贝和浅拷贝的区别直接看代码：123456789101112131415161718192021222324252627282930313233&gt;&gt;&gt; a = [[1,1,1],[2,2,2]]&gt;&gt;&gt; b = copy.copy(a)&gt;&gt;&gt; c = copy.deepcopy(a)&gt;&gt;&gt; id(a)1264997889288&gt;&gt;&gt; id(b)1264997862472&gt;&gt;&gt; id(c)1264997889736#深拷贝和浅拷贝的区别在，深拷贝复制了整个对象，而浅拷贝只是复制了第一层的元素&gt;&gt;&gt; id(a[0])1264997875208&gt;&gt;&gt; id(b[0])1264997875208&gt;&gt;&gt; id(c[0])1264997861640&gt;&gt;&gt; a.append(2)&gt;&gt;&gt; b[[1, 1, 1], [2, 2, 2]]&gt;&gt;&gt; c[[1, 1, 1], [2, 2, 2]]&gt;&gt;&gt; a[[1, 1, 1], [2, 2, 2], 2]&gt;&gt;&gt; a[0].append(2)&gt;&gt;&gt; a[[1, 1, 1, 2], [2, 2, 2], 2]&gt;&gt;&gt; b[[1, 1, 1, 2], [2, 2, 2]]&gt;&gt;&gt; c[[1, 1, 1], [2, 2, 2]]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python惰性序列]]></title>
    <url>%2F2018%2F03%2F17%2Fpython%E6%83%B0%E6%80%A7%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[python中的高级特性——惰性序列 生成器generator一边计算一边循环的机制，称为生成器。generator非常强大。相比于传统的for循环直接生成一个list，generator可以节省大量的空间。1234567891011121314&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; for n in g:... print(n)...0149162536496481 如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。著名的斐波拉契数列（Fibonacci）1234567def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return &apos;done&apos; 杨辉三角：12345678910def yanghui(max): line=[1] while True: yield line nextline = line+[1]#注意这个表达 for i in range(len(line)): if i != 0: nextline[i] = line[i-1] + line[i] line = nextline return &quot;done&quot; Iterable与Iterator，iter()Iterablepython中直接作用于for循环的对象统称为可迭代对象：Iterabale.一类是集合数据类型，如list、tuple、dict、set、str等；一类是generator，包括生成器和带yield的generator function。判断一个对象是否是可迭代对象,可以使用collections模块的Iterable类型判断。 Iterator能够被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。 iter()可以使用isinstance()判断一个对象是否是Iterator对象。可以使用iter()函数把list，dict，str获得一个Iterator对象，用next()计算。 code examples123&gt;&gt;&gt;from collections import Iterable&gt;&gt;&gt;isinstance(&quot;abc&quot;,Iterable)True 12345&gt;&gt;&gt;from collections import Iterator&gt;&gt;&gt;isinstance([],Iterator)False&gt;&gt;&gt;isinstance(iter([]),Iterator)True 12345678910#注意下面的区别&gt;&gt;&gt;isinstance((x for x in range(10)),Iterator)#返回的是一个生成器对象，不是tupleTrue&gt;&gt;&gt;isinstance((),Iterator)#tuple不是迭代器False&gt;&gt;&gt;isinstance([x for x in range(10)],Iterator)#返回一个listFalse 为什么list、dict、str等数据类型不是Iterator？ 这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。 Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。 惰性序列惰性计算惰性序列python中的惰性序列多数指Iterator。对于存在巨大甚至无限多的元素的序列，迭代器仅仅在迭代至某个元素时才计算该元素，在此之前或者之后，元素可以不存在或者被销毁。 意义一是这样我们就可以实现的无限序列的表示，比如全部的自然数(无穷尽)，而不需要真的在内存中计算出所有的自然数(那根本不可能，因为内存也不是无限的)，而是需要哪个数，计算到哪个数，或者需要哪些数，计算到那些数(比如前1000个)。二是在大规模数据处理中起到延迟计算的作用。当你处理大规模数据时，一次性进行处理往往是不方便的。而惰性序列就可以解决这个问题，它把计算的步骤延迟到了要实际使用该数据的时候。惰性序列可以看作是一个”流”，需要的时候从其中取一滴水。 reference博客博客2教程]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“Google机器学习速成课程”概念浏览]]></title>
    <url>%2F2018%2F03%2F13%2F%E2%80%9CGoogle%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%80%9F%E6%88%90%E8%AF%BE%E7%A8%8B%E2%80%9D%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[摘要 ：简单总结几个最近发布的“机器学习速成课程”中的概念 正文: 随机梯度下降法（SGD）：在梯度下降法中，批量指的是用于在单次迭代中计算梯度的样本总数。到目前为止，我们一直假定批量是指整个数据集。就 Google 的规模而言，数据集通常包含数十亿甚至数千亿个样本。此外，Google 数据集通常包含海量特征。因此，一个批量可能相当巨大。如果是超大批量，则单次迭代就可能要花费很长时间进行计算。 包含随机抽样样本的大型数据集可能包含冗余数据。实际上，批量大小越大，出现冗余的可能性就越高。一些冗余可能有助于消除杂乱的梯度，但超大批量所具备的预测价值往往并不比大型批量高。 如果我们可以通过更少的计算量得出正确的平均梯度，会怎么样？通过从我们的数据集中随机选择样本，我们可以通过小得多的数据集估算（尽管过程非常杂乱）出较大的平均值。 随机梯度下降法 (SGD) 将这种想法运用到极致，它每次迭代只使用一个样本（批量大小为 1）。如果进行足够的迭代，SGD 也可以发挥作用，但过程会非常杂乱。“随机”这一术语表示构成各个批量的一个样本都是随机选择的。 小批量随机梯度下降法（小批量 SGD）是介于全批量迭代与 SGD 之间的折衷方案。小批量通常包含 10-1000 个随机选择的样本。小批量 SGD 可以减少 SGD 中的杂乱样本数量，但仍然比全批量更高效。 特征工程：从原始数据创建特征的过程。会花费实际工作中百分之70的时间。良好特征具有下列特点：1.避免很少使用的离散特征值2.最好具有清晰明确的定义3.异常的数值不要和实际数据混为一谈4.考虑随着时间的不稳定性 数据清洗：1.缩放特征值2.处理极端离群值3.分箱4.清查（遗漏值，重复样本，不良标签，不良特征值）5.了解数据 特征组合:是指通过将两个或多个输入特征相乘来对特征空间中的非线性规律进行编码的合成特征。 [A X B]：将两个特征的值相乘形成的特征组合。 [A x B x C x D x E]：将五个特征的值相乘形成的特征组合。 [A x A]：对单个特征的值求平方形成的特征组合。 机器学习训练过程问题：梯度消失较低层（更接近输入）的梯度可能会变得非常小。在深度网络中，计算这些梯度时，可能涉及许多小项的乘积。当较低层的梯度逐渐消失到 0时，这些层的训练速度会非常缓慢，甚至不再训练。ReLU 激活函数有助于防止梯度消失。 梯度爆炸如果网络中的权重过大，则较低层的梯度会涉及许多大项的乘积。在这种情况下，梯度就会爆炸：梯度过大导致难以收敛。批标准化可以降低学习速率，因而有助于防止梯度爆炸。 ReLU 单元消失一旦 ReLU 单元的加权和低于 0，ReLU 单元就可能会停滞。它会输出对网络输出没有任何贡献的 0 激活，而梯度在反向传播算法期间将无法再从中流过。由于梯度的来源被切断，ReLU 的输入可能无法作出足够的改变来使加权和恢复到 0 以上。降低学习速率有助于防止 ReLU 单元消失。]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>lessons</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode15-3sum解题报告]]></title>
    <url>%2F2018%2F02%2F21%2Fleetcode15%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. 题目Note:Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)The solution set must not contain duplicate triplets. For example, given array S = {-1 0 1 2 -1 -4}, A solution set is: (-1, 0, 1) (-1, -1, 2) 解题思路 先把无序数组排序 固定一个数，找出其余两个数让它们的和为固定数的相反数（相加为0） 答案1234567891011121314151617181920212223242526272829303132333435363738public class Solution &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;List&lt;Integer&gt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] num) &#123; if (num == null || num.length &lt; 3) return ret; Arrays.sort(num); int len = num.length; for (int i = 0; i &lt; len-2; i++) &#123; if (i &gt; 0 &amp;&amp; num[i] == num[i-1]) continue; find(num, i+1, len-1, num[i]); //寻找两个数与num[i]的和为0 &#125; return ret; &#125; public void find(int[] num, int begin, int end, int target) &#123; int l = begin, r = end; while (l &lt; r) &#123; if (num[l] + num[r] + target == 0) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;(); ans.add(target); ans.add(num[l]); ans.add(num[r]); ret.add(ans); //放入结果集中 while (l &lt; r &amp;&amp; num[l] == num[l+1]) l++; while (l &lt; r &amp;&amp; num[r] == num[r-1]) r--; l++; r--; &#125; else if (num[l] + num[r] + target &lt; 0) &#123; l++; &#125; else &#123; r--; &#125; &#125; &#125; &#125; Note这个题目要注意得出的结论可能出现重复的可能，另外要考虑的所有特殊情况如下： 结果重复 输入数组长度不够 输入数组为空另外，在搜寻三个数使得其和为0的思路上，不能采取用三个循环的思想，这样会导致时间复杂度很高。可以固定其中的一个数，设置两个指针，让这两个指针移动计算,降低时间复杂度。]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>algorithms</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04安装OpenCV3.3教程]]></title>
    <url>%2F2017%2F12%2F22%2FUbuntu16.04%E5%AE%89%E8%A3%85OpenCV3.3%2F</url>
    <content type="text"><![CDATA[摘要：搭建OpenCV3.3的过程 安装依赖环境1234567$ sudo apt-get install build-essential libopencv-dev$ sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev$ sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev # 处理图像所需的包$ sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev liblapacke-dev$ sudo apt-get install libxvidcore-dev libx264-dev # 处理视频所需的包$ sudo apt-get install libatlas-base-dev gfortran # 优化opencv功能$ sudo apt-get install ffmpeg 获取源代码1$ git clone https://github.com/opencv/opencv.git 编译源代码123456789$ cd opencv$ mkdir build$ cd build$ cmake ..$ make -j 10 替换旧版本1$ sudo make install 编译出错的处理执行cmake的时候，可能会出现下面的错误信息：12345678910CMake Error at CMakeLists.txt:11 (message): FATAL: In-source builds are not allowed. You should create separate directory for build files.-- Configuring incomplete, errors occurred! 则是在代码根目录下直接执行过 cmake，导致根目录下生成了 CMakeCache.txt，需要删除 CMakeCache.txt再次执行编译即可。]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python字符串切片操作]]></title>
    <url>%2F2017%2F11%2F26%2Fpython%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E5%8F%96%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[详述在python中如何切片？ 字符index首先需要明白字符的index是什么？对于一个字符串：1&gt;&gt;&gt;str = &quot;abcdefg&quot; 其各个字符的index分别为 0 1 2 3 4 5 6如果用负数表示，就是 -7 -6 -5 -4 -3 -2 -1 取字符串中第几个字符根据index获取即可：12&gt;&gt;&gt;str[2]a 字符串分割表达式 str[a:b]，表示从字符串index为a的字符，截取到index为b-1的字符12&gt;&gt;&gt;str[1:2]b 步长截取str[a:b:c]:表示从第a个字符串开始，截取到第b个字符的前一个为止。不过这里要&lt;\font color = ‘red’&gt;注意&lt;\font&gt;:当c小于0时，字符串的index是反向数的，也就是从index为b的到index为a+1的字符，每隔-c个字符取一个字符。比如：12&gt;&gt;&gt;str[3:1:-1]dc]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Can you fool AI with adversarial examples on a visual Turing test?》论文笔记]]></title>
    <url>%2F2017%2F11%2F21%2F%E3%80%8ACan-you-fool-AI-with-adversarial-examples-on-a-visual-Turing-test-%E3%80%8B%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Xu X. Can you fool AI with adversarial examples on a visual Turing test?[J]. 2017. citationXu X. Can you fool AI with adversarial examples on a visual Turing test?[J]. 2017. introduction先介绍VQA(Visual Question Answering)：也叫做visual Turing test，也就是让机器学习模型回答一个关于图片的用自然语言表述的问题。可以通过回答的正确度判断模型的效果。VQA问题是深度学习的引用问题中比较复杂的一个分支，涉及的面也比较广，但是同样也会受到对抗样本攻击的影响。在这篇文章中，研究目标就是利用目标对抗攻击，让模型生成特定的question-answer pair。（这是对VQA系统进行对抗攻击的第一次尝试） content and contributions本文的研究内容如下： 1. 实验证明了一个训练好的VQA模型也会被对抗攻击影响。这里的攻击设定为白盒攻击：即是已知这个VQA模型的结构和权重。 2. 进一步用对抗样本攻击目前效果最好的VQA模型，发现了两个现象： 1) 如果目标question-answer对出现频率越大，内容更加想关，回答更加有意义，那么以这个“问答对”作为目标构造的对抗样本成功率更高。（这个现象叫做language prior，也比较好解释，模型往往会选择更加有意义，关联性更强的问答组合作为最终的结果。这种现象在针对具有显示推理特征的VQA模型时更加明显） 2) 在VQA问题中构造的对抗样本具有可移植性，说明可以用这个方法构造黑盒攻击。 3. 研究在两种训练好的模型的上进行了对抗攻击，一种模型是 bilinear fusion model MCG（结合问题和图片的特征预测答案），一种是组合模型NMN（建立依赖问题的网络布局，让这个网络处理图片得到预测答案）。比较之下，后者更不容易受到对抗样本的影响，说明了这种结构的模型更加稳定。 研究的contribution如下： 1. 第一个提出针对VQA模型的对抗攻击 2. 提出生成对抗样本的新算法 3. 实验发现了当目标问答对出现频率比较高时，VQA模型存在目标对抗样本。且这种对抗样本有可移植性 4. 发现了language prior现象，即是当以一些问答对作为攻击目标时，效果很差 5. 发现组合的神经网络模型更加稳定，这种增强模型稳定性的结构可以作为提升模型鲁棒性的参考。 backgroundVQA所谓的VQA，也就是Given an image and a natural language question as an input, the goal of VQA is to predict a natural language answer. 它的应用很广，研究中用到的组合VQA和非组合VQA如下： non-compositional以[A. Fukui, D. H. Park, D. Yang, A. Rohrbach, T. Darrell, and M. Rohrbach, “Multimodal compact bilinear pooling for visual question answering and visual grounding,” in Proceedings of the Conference on Empirical Methods in Natural Language Processing (EMNLP), 2016.]提出的MCB方法为例。这个方法是先用两个网络模型$f_1$和$f_2$分别映射原始图片和question。它依赖的模型是一个整体结构，可以直观理解为输入端问题和图片到输出端答案的映射，输出就是计算出的$argmax_j(softmax(Wu^.))$。 compositional这种组合模型，比如[R. Hu, J. Andreas, M. Rohrbach, T. Darrell, and K. Saenko,“Learning to reason: End-to-end module networks for visual question answering,” in Proc. of ICCV, 2017.]提出的方法。这种组合可以解释为两步：首先计算根据问题和图片的表达式$u_i^.$；然后基于问题question和$u_i^.$预测答案。也就是这种模型有两步操作，两步依次执行最终给出预测答案。而在Hu等人的研究中，将这两步又拆分成了九个module，比如找到图片中的相关区域算为一个module。这种不同module组合形成的模型，也就叫做组合模型。adversarial examples、Transferability and Black-box Attacks的相关背景比较熟悉，不再赘述 model details研究有几个前提： 1. **白盒攻击**，即是攻击者知道模型的结构和网络权重。因此，攻击者可以计算模型的输出关于输入的梯度值。而本实验就是在这个假设的前提下进行的。利用这个梯度信息，就可以生成降低模型准确度的对抗攻击。 2. 目标模型没有任何防御策略：并不会影响本实验的典型性，因为 most existing defense proposals are either not properly evaluated and vulnerable to strong attacks, or only designed for black-box attacks 。 3. 攻击形式是指定目标的target attack：原因一是因为非目标攻击威胁不大，其二是因为真实攻击者用目标攻击往往能产生更好的攻击效果。 4. attack success rate：攻击成功率用来衡量生成的对抗样本，也是一个标准测量方法。 5. 提高模型的输出概率：因为模型是根据输出的概率向量来预测问题的答案，如果这个概率比较低，就容易被防御策略检测出来，因此，提高对抗样本的输出概率值，也能反映攻击的有效性。 algorithmsVQA模型定义为$f_\theta(I,Q)$,$\theta$是模型的参数，I是输入图片，Q是输入问题，f的结果是预测的答案概率值。与传统将VQA问题视作分类问题不同，作者将对这个模型$f_\theta$攻击抽象为，构建一个对抗样本图片$I^{adv}$,让模型的输出为问答对$(Q^{target},A^{target})$的概率最大，即是 f_\theta(Q^{target},A^{target})=A^{target} s.t.d(I^{adv},I^{ori})\le B整体的优化问题即是： argmin_{I^{adv}}L(J_\theta (I^{adv},Q^{target}),A^{target}) s.t.d(I^{adv},I^{ori})\le B本文提出的算法优化，主要就是用一种替代目标函数来逼近优化函数，从而提升效率。 \xi(A^{predict})= L(J_\theta (I^{adv},Q^{target})+\lambda _1.l(A_{target}\ne A^{predict}.(\tau-L(J_\theta(x,Q^{target},A^{predict})))+\lambda _2.ReLU(d(x,I^{ori})-B+\epsilon)整体的算法如下： conclusion文章的结论有三个方面： 1. 目标对抗攻击（本文是目标对抗攻击）的成功率主要受到所选择的question-answer pair的类别的影响，跟参考图片的选择关系不大。 2. 发现了language prior phenomenon，给针对特定question-answer pair能产生对抗样本提供了一种可能的解释。 3. 发现组合VQA模型结构更加稳定。 这篇文章对对抗攻击的创新主要就是1）应用在了VQA新场景下2）优化目标函数的方法比较新颖]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>papernotes</tag>
        <tag>adversarial attack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Delving into adversarial attacks on deep policies》论文笔记]]></title>
    <url>%2F2017%2F11%2F19%2F%E3%80%8ADelving-into-adversarial-attacks-on-deep-policies%E3%80%8B%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Kos J, Song D. Delving into adversarial attacks on deep policies[J]. 2017. citationKos J, Song D. Delving into adversarial attacks on deep policies[J]. 2017. introduction这篇文章是关于深度增强学习策略网络模型的对抗攻击研究。主要的研究内容有： 1. 比较对抗样本和随机噪声的攻击性 2. 提出了一个基于值函数的可以提高对抗样本生成效率，减少实现一个成功的对抗攻击时需要“入侵”目标模型的次数。 3. 研究如何重新训练来增强模型对随机噪声和FGSM攻击的稳定性。 study content这篇文章contribution和objects都是三个： 1. 比较了随机噪声和对抗样本对深度增强学习策略模型deep reinforcement learning (DRL) 的影响。发现了采用这种DRL策略的模型也容易受到对抗样本的攻击。 2. 提出了利用增强学习策略中的值函数来引导攻击者选择在原始样本中添加对抗扰动的时间。（这种构造对抗样本的方法相比于以前在图片分类等等任务中，间隔固定时间添加对抗扰动的策略更复杂一些，但是作者发现这样效率更高） 3. 通过re-training可以增强策略的稳定性。初步结果表明，通过re-training，agents可以对FGSM生成的对抗样本和随机噪音都更加稳定。同时，作者也研究了这种提高的稳定性是否会根据扰动的不同规模和不同种类而发生改变。发现这种方法并不能增强模型对其他攻击类型的防御能力。 对第二个研究目标，作者提出了三个方法来探究是否减少了添加perturbation的频率也能生成有效的对抗样本：1)每隔N步给原始样本注入一次扰动，在间隔中计算扰动但是不添加到样本中；2)每隔N步计算一次扰动，并加入到数据样本中；3)引入一个“值函数”，计算什么时候添加扰动效果最好，确保添加的时机让这个值函数处于阈值。 experimental evaluation这部分首先是介绍两个概念，A3C算法是一个应用在深度增强学习任务中的比较成功的算法：通过策略权值的异步更新权值。[Volodymyr Mnih, Adria Puigdomenech Badia, Mehdi Mirza, Alex Graves, Timothy P Lillicrap, Tim Harley, David Silver, and Koray Kavukcuoglu. Asynchronous methods for deep reinforcement learning. In International Conference on Machine Learning, 2016.]另一个概念是FGSM，也就是 Goodfellow等人提出的比较典型的对抗样本生成算法。实验首先在base-line的情况下得到了一个在Atari Pong任务中训练得到的增强模型，然后设定FGSM中的对抗扰动规模超参数$\epsilon$，并得到对抗样本。同时从均匀分布$unif(0,β)$随机取样得到随机噪声。实验结果上，第一个任务没有什么值得注意的。对于第二个任务，这里的N设为10，实验结果如图：在$\epsilon$为0.005，扰动规模一定的情况下，第一个方法生成的对抗样本效果不如每隔10步计算一次perturbation得到的样本（方法2）效果更好。同时，用一个让值函数大于一个阈值时才加入对抗扰动的策略，如下图：红色的线表示值函数的变化，这个值函数即是增强学习的反馈值。当这个函数大于一定值的时机加入对抗扰动，即是这个扰动也更加贴近模型训练时的反馈。最终的结论是，在增强学习背景下，用基于值函数得到的对抗样本，尽管更加复杂，但是也更加高效，得到的样本对抗性更强。 conclusion今年才开始有将对抗样本应用到增强学习领域的相关研究。相比于《Vulnerability of Deep Reinforcement Learning to Policy Induction Attacks》，，前者是通过改变对抗样本训练策略，将对抗样本的训练和增强学习的反馈结合起来，得到更高效且效果更好的攻击样本。后者针对的策略是Deep Q-networks，并且是利用了对抗样本的transferability。]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>papernotes</tag>
        <tag>adversarial attack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Generative Face Completion》论文笔记]]></title>
    <url>%2F2017%2F11%2F18%2F%E3%80%8AGenerative-Face-Completion%E3%80%8B%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Title: Generative Face CompletionAuthors: Li, Yijun; Liu, Sifei; Yang, Jimei; Yang, Ming-HsuanPublication: eprint arXiv:1704.05838Publication Date: 04/2017Origin: ARXIVKeywords: Computer Science - Computer Vision and Pattern RecognitionComment: Accepted by CVPR 2017Bibliographic Code: 2017arXiv170405838L citationLi Y, Liu S, Yang J, et al. Generative Face Completion[J]. 2017. Content论文用深度生成模型实现了一个高效面部补全算法。与传统从已给数据集中搜寻相似图片块儿来进行补全和合成残缺图片的方法不同，作者是直接使用一个神经网络来合成残缺部分的内容。整个模型由三部分构成：a reconstruction loss、two adversarial losses、a semantic parsing loss。 a) 论文目的： 传统以复制-粘贴的方式来进行图片补全在背景填充方面效果不错，但在面对填充脸部图片这种目标图片比较独特时却效果不佳。作者于是想用深度生成模型构建一个有效的目标补全算法，能不需要参照外部数据集快速完成对图片的补全。 b) 论文贡献： 首先提出了一个深度生成补全图片补全模型，这个模型通过encoding-decoding 生成器、两个对抗判别器来合成用随机噪声遮挡的部分；其次对挑战性的脸部补全任务进行处理，并且实现提出的模型能够根据学习到的目标特征，产生整体比较和谐的图片；最后，作者证明了生成semantic parsing部分的有效性。 c) 模型结构： 整体结构如下图：生成器G：结构有encoder层、两个全连接层和decoder层，输入的残缺图片通过encoder层映射成隐藏特征，然后再通过decoder层得出生成的图片。里面的encoder层是两层以上卷积层加上一层以上池化层，decoder层与encoder对称。 判别器D：如果只有一个生成器，那么生成的图片将会非常模糊，只有一个粗略的轮廓。因此，采用了两个判别器来对生成图片的细节进行完善，使得生成的图片更加真实。其中，有两个判别器：local discriminator和global discriminator。其中，局部判别器是为了让生成器生成图片中补全的部分更加真实，而整体的判别器是为了让整个生成的图片看起来更加真实。 Semantic Regularization：前面的两个部分其实就是原始GAN的变形，作者加上后面这一部分的原因是，前面生成的图片虽然整体上轮廓清晰比较真实，但是看上去却不像是人脸的图片。如下图： 加上autoencoder结构的semantic parsing network之后，生成的图片会更加和谐： d) 损失函数： 因为模型分为三部分，因此损失函数也有三部分： 整体的损失函数如下： $$L = L_r + λ_1L_{a1} + λ_2L_{a2} + λ_3L_p$$ 其中， ①$L_r$是生成器的损失，就是输入与输出的二阶范数。 ②$L_{a1}$与$L_{a2}$是两个判别器的损失，其形式跟GAN的判别器损失大同小异： ③Lp就是semantic parsing network的损失，就是简单的softmax层损失。 它们前面的参数是用来平衡各个部分损失不同影响的。 e) 训练步骤： 与我上一篇看的pix2pix两步走的训练步骤类似，作者采用了三步训练： ①用生成器直接训练，得到模糊的结果； ②用局部判别器损失来微调生成模型； ③联合整体判别器和意义转化网络损失来调整生成模型参数。 这个方法据说可以避免训练开始阶段判别器的作用过强。和我毕设的预训练类似。 f) 数据集选择： 作者用到了两个数据集，一个是Celeb A，一个是Helen test数据集，这两个数据集都是面部图片的集合，并且后者还有segment label。以后做实验可以考虑使用。 g) 实验结果： 作者将自己模型产生的结果与CE模型产生的结果进行直接对比，并用了三种测量标准测试，证明作者提出的模型效果更好。作者还做了遮挡不同面积的图片，来观察结果的效果，并得出在size是32×32时效果是最好的，因为此时的遮挡面积刚好是面部器官的一部分，比如半只眼睛。 心得体会a) 训练步骤也有一个预训练部分（只训练生成器），和我毕设中对生成器预训练类似。以前一直以为只是用来让后面的训练时间更短，论文中提到这样训练也可以避免在训练的初始阶段，判别器的作用太强，影响训练效果。 b) 论文对GAN的变形方式值得借鉴，采用两个判别器的模型分别完成对局部和整体的训练，思路很好。d） 作者在模型的最后部分还采用了一个semantic parsing networks结构，这个部分能让整体的输出更加和谐，具体的参考论文还没了解，因此其原理了解很模糊。e) 论文的目的是对独特的目标图片进行补全，以面部图片为例，但是论文一直是以脸部图片作为实验训练集，如果能加入其他比较独特的图片，比如建筑、动物等，可能说服力会更强。]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>papernotes</tag>
        <tag>adversarial attack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《NO Need to Worry about Adversarial Examples in Object Detection in Autonomous Vehicles》论文笔记]]></title>
    <url>%2F2017%2F11%2F02%2F%E3%80%8ANO-Need-to-Worry-about-Adversarial-Examples-in-Object-Detection-in-Autonomous-Vehicles%E3%80%8B%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[citationLu J, Sibai H, Fabry E, et al. NO Need to Worry about Adversarial Examples in Object Detection in Autonomous Vehicles[J]. 2017. Introduction这篇文章是在《Adversarial examples in the physical world》（A. Kurakin, I. J. Goodfellow, and S. Bengio. Adversarial examples in the physical world. CoRR, abs/1607.02533, 2016.）的基础上的进一步研究。因为在传统的对抗攻击构建过程中，对抗perturbation直接和数字图片叠加，作为神经网络模型的输入。Kurakin等人的研究中，对抗的perturbation被生成之后，如果和原始数据叠加后，不是直接作为模型的输入，而是通过相机拍摄的方式输入到模型中。Kurakin等人的研究模拟了实际physical场景下的对抗攻击场景，并且证明了对抗扰动在从对抗样本到拍照后的对抗样本的转化过程中，虽然有相机的noise，仍然是具有对抗性的。同时，也因为《Concrete Problems for Autonomous Vehicle Safety: Advantages of Bayesian Deep Learning》（Mcallister R, Gal Y, Kendall A, et al. Concrete Problems for Autonomous Vehicle Safety: Advantages of Bayesian Deep Learning[C]// Twenty-Sixth International Joint Conference on Artificial Intelligence. 2017:4745-4753.）中应用对抗攻击到自动汽车驾驶问题中的挑战问题。另一个相关研究是《Accessorize to a crime: Real and stealthy attacks on state-ofthe-art face recognition》（M. Sharif, S. Bhagavatula, L. Bauer, and M. K. Reiter. Accessorize to a crime: Real and stealthy attacks on state-ofthe-art face recognition. In Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security, CCS ’16, pages 1528–1540, New York, NY, USA, 2016. ACM. ），本文的研究证明了在面部识别的实际应用中，通过构建对抗样本，不论是否已知面部识别模型的结构（黑盒或者白盒攻击），都可以在把实际拍摄脸部照片作为模型输入的情况下，极大地影响识别的结果。上述研究都给神经网络模型的实际应用带来了很多concern。 本文的研究则是通过一些实验，证实物理世界中的对抗攻击在多种距离和角度效果不佳。在汽车驾驶中交通标示识别实验中，大部分的在汽车行进过程中拍摄对抗样本都被分类模型正确分类。 methods论文的实验方法是使用多种攻击方法测试得到训练好的模型的稳定性。并且训练的模型有两种不同的结构。所用的数据集是widthlengthdepth的三维向量。所用的攻击方法有： Goodfellow提出的FGSM[I. J. Goodfellow, J. Shlens, and C. Szegedy. Explaining and harnessing adversarial examples. arXiv preprint arXiv:1412.6572, 2014.] Kurakin等人提出的迭代FGSM[A. Kurakin, I. J. Goodfellow, and S. Bengio. Adversarial examples in the physical world.CoRR, abs/1607.02533, 2016.] Szegedy 等提出的L-BFGS方法[C. Szegedy, W. Zaremba, I. Sutskever, J. Bruna, D. Erhan,I. Goodfellow, and R. Fergus. Intriguing properties of neural networks. arXiv preprint arXiv:1312.6199, 2013.] 与一般的对抗攻击研究只针对分类问题不同，本文所攻击的目标模型也采用了探测器模型：the YOLO multiple object detector [J. Redmon, S. Divvala, R. Girshick, and A. Farhadi. You only look once: Unified, real-time object detection. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pages 779–788, 2016.]本文中classifier与detector的不同之处在于： classifier使用交叉熵损失函数，衡量输入图片真正的标签($y_{true}$)和输出的one-hot标签($y_{fool}$)的差别。 detector中，模型的输出是向量$p_{output}$ ，但是输入样本却没有one-hot标示的标签（因为输入的数据是即时的，一直变化的）。因此实验设置是输入的标签的维度和输出一样，都为 $ l_{p_{output}} $ 。 本文的实验方法与前面提到的攻击算法研究中修改图片不同，关注的是在物理世界的攻击，也就是打印应用这些攻击之后的图片并测试目标模型的稳定性。应用到实际场景时，作者考虑了拍摄相机与目标的距离和拍摄角度的变量影响。 experimental results 分析生成的对抗样本结果首先是针对detector目标模型生成的对抗样本：对比针对traffic sign classifier生成的对抗样本：可以发现前者的密度更低。从直观理解也很容易，因为密度越高的对抗扰动可以让探测器的实时监测扰动更加困难。 整体的对抗样本稳定性的实验结果DR%代表这个stop标志被识别的概率。表格中的Ori指的是完整的图片，Crop则指的是裁剪出只有交通标志的部分。表格的左边是对抗样本在直接作为模型输入时的对抗效果，右边是在现实场景下的实验结果。从表格可以得出下面的结论： 只关注标志本身的，经过裁剪之后的对抗样本效果更好 在实际应用场景下，对抗样本的对抗性会随着距离的增加而减弱，模型的识别准确率会更高 从结果来看对抗攻击方法的效果，L-BFGS整体要差于FGSM方法。 而这篇文章主要关注的变量，也就是对样本效果影响最大的变量，就是距离的变化。从实验结果中最后两列可以看出，随着距离的增加，对抗样本的对抗性衰减十分明显。但是这种情况也有例外，这说明了对抗扰动的效果在随着距离而变化。因此，在实际应用场景下，探测系统/分类模型只需要调整距离和角度，是可以实现正确识别输入样本的。 conclusion此外，这两天的对比看文章，和前几天看的《Standard detectors aren’t (currently) fooled by physical adversarial stop signs》比较相似，这一类的文章的内容只是通过实验推翻了前面研究的实验结果。不过本文的观点显然也有一定的缺陷，因为在很多场景下，人们允许的失误率阈值会比较低，甚至不能容忍模型的识别错误。本文只是说明了对抗的效果没有Kurakin等人的研究中那么显著而已。]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>papernotes</tag>
        <tag>adversarial attack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Standard detectors aren’t (currently) fooled by physical adversarial stop signs》论文笔记]]></title>
    <url>%2F2017%2F10%2F31%2F%E3%80%8AStandard-detectors-aren%E2%80%99t-currently-fooled-by-physical-adversarial-stop-signs%E3%80%8B%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[citationLu J, Sibai H, Fabry E, et al. Standard detectors aren’t (currently) fooled by physical adversarial stop signs[J]. 2017. IntroductionEvtimov等人在《Robust Physical-World Attacks on Machine Learning Models》提出了RP2算法，可以构建对抗样本，通过添加精心设计的扰动，使交通标示探测器的结果错误，达到对抗攻击的目的。但是本文的作者认为，Evtimov等人在构建对抗样本的实验过程中，对原始图片进行了两种处理：一是对原始图片进行了剪切，二是重新设定了图片的尺寸。本文的作者认为，这样的处理会让模型在训练时能有效的适应视觉角度和规模变化，但是处理之后就消除了这种训练结果。同时，增加的对抗扰动也会有这种视觉角度和规模的变化，因此是否有效需要通过实验验证。不止这种视觉角度和图片规模的改变，针对探测器的对抗攻击也要考虑到大量参数变化（scale; view angle; box shift inside the detector;illumination;等）。另外，对一个classifier和detector进行的对抗攻击应该是有区别的，后者因为不能准确地估计探测边界，所以构造对抗样本也会更加困难。最后，本文中用（YOLO and Faster RCNN）[J. Redmon and A. Farhadi. Yolo9000: better, faster, stronger.arXiv preprint arXiv:1612.08242, 2016.][S. Ren, K. He, R. Girshick, and J. Sun. Faster r-cnn: Towards real-time object detection with region proposal networks. In Advances in neural information processing systems, pages 91–99, 2015.]训练得到的探测器进行测试，发现不会受到对抗攻击的影响。 Difference between Classifiers and Detectors 两者不会明显区分分类边界，因为对于探测器来说，确定物体边界十分困难。（The key feature of detection systems is that they tend not to get the boxes exactly right） 原因分析： Close cropping can remove scale and translation effects Low resolution boxes Cropping and variance Cropping and context experimental resultsEvtimov等人的实验主要是两个方面，一种是poster attacks (the stop sign is covered with a poster that looks like a faded stop sign) ，一种是 sticker attacks (the attacker makes stickers placed on particular locations on a stop sign)，因此本文的对照实验采用同样的攻击方式。 首先是在YOLO探测模型上的探测对抗结果：然后是在Faster RCNN探测模型上的探测结果：从这两个结果上来看，原来的对抗攻击的成功率已经下降到0，说明了Evtimov等人提出的对抗样本构建方法失效了。 conclusion探测器并不能声称完全免疫物理对抗攻击，然而目前没有证据证明物理对抗样本能对detector产生效果。这篇文章实验主要就是实验部分，通过实验证明了Evtimov的研究的不充分，说明了实际中，对探测器的攻击的存在性还待进一步研究。找到这种攻击的存在还有很大的挑战。]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>papernotes</tag>
        <tag>adversarial attack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Robust Physical-World Attacks on Machine Learning Models》论文笔记]]></title>
    <url>%2F2017%2F10%2F30%2F%E3%80%8ARobust-Physical-World-Attacks-on-Machine-Learning-Models%E3%80%8B%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Title: Robust Physical-World Attacks on Machine Learning ModelsAuthors: Evtimov, Ivan; Eykholt, Kevin; Fernandes, Earlence; Kohno, Tadayoshi; Li, Bo; Prakash, Atul; Rahmati, Amir; Song, DawnPublication: eprint arXiv:1707.08945Publication Date: 07/2017Origin: ARXIVKeywords: Computer Science - Cryptography and Security, Computer Science - LearningBibliographic Code: 2017arXiv170708945E citationEvtimov I, Eykholt K, Fernandes E, et al. Robust Physical-World Attacks on Machine Learning Models[J]. 2017. 概述&emsp;最近的研究中，许多对抗样本构造方法在真实自然世界效果不好。已有的对抗攻击研究在现实世界中，往往不能使分类模型误分类，或者只在非常有限的情况比如复杂原始图像经修改后打印出来才能达到对抗攻击的目的。&emsp;本论文要点如下： 提出Robust Physical Perturbations(RP2)算法，能产生鲁棒且自然有效的对抗扰动。 使用RP2算法用两种方式构造对抗攻击：— subtle perturbations：对整个标志进行微小的、很难探测到的改动。把整个受到攻击后的图片打印后覆盖到原标志上面，尺寸和原图一样。— camouflage perturbations：以涂鸦或艺术画的形式对原图进行可见的改变。攻击者直接将扰动攻击打印出来，然后贴到已经存在的标志上面。 因为目前缺乏衡量自然界对抗攻击效果的标准方法，因此论文提出了一种评估方法。 Introduction 提出在physical world也有效的对抗样本生成算法的原因： 一方面，《No need to worry about adversarial examples in object detection in autonomous vehicles》（J. Lu, H. Sibai, E. Fabry, and D. Forsyth, “No need to worry aboutadversarial examples in object detection in autonomous vehicles,” arXivpreprint arXiv:1707.03501, 2017.）研究FGSM和L-BFGS算法，发现生成的路面警示标志的对抗样本在多种观察条件下效果很差（改变角度和距离）。另一方面，《Synthesizing robust adversarial examples》（A. Athalye and I. Sutskever, “Synthesizing robust adversarial examples,”arXiv preprint arXiv:1707.07397, 2017.）说明可以通过更好的对抗样本算法来生成扰动图片，在图片被打印出来用相机来观察时在各种情况下都是鲁棒的。 在针对分类的对抗攻击可行性上面，仍然有许多遗留问题。首先，给目标的背景增加扰动不可实现。第二，相比于目前所用的复杂图片，将扰动隐藏在像路标这种简单的目标中是更加困难的。第三，对于难以感知的扰动， 还有额外的物理上的限制，因为轻微的扰动可能让相机在多种自然情况下不能获取这些扰动信息（如长距离和多角度情况下）。 本论文的主要目的：对真实世界目标构建robust且轻微的扰动是否可行。 需要解决的问题： 汽车中的相机与路标的距离一直在变化 汽车中的探测相机与路标的角度一直在变化 光线强弱变化 在路标或者汽车上的遮挡物 Related work这一部分先总结了三种对抗样本的生成方法： （I. J. Goodfellow, J. Shlens, and C. Szegedy, “Explaining and harnessing adversarial examples,” arXiv preprint arXiv:1412.6572, 2014.） 提出的FGSM方法。 （N. Carlini and D. Wagner, “Towards evaluating the robustness of neural networks,” in Security and Privacy (SP), 2017 IEEE Symposium on.IEEE, 2017, pp.39–57.）提出的基于迭代优化算法在一定限制下查找perturbation。 （S.-M. Moosavi-Dezfooli, A. Fawzi, O. Fawzi, and P. Frossard, “Universal adversarial perturbations,” arXiv preprint arXiv:1610.08401, 2016.）提出的能应用到黑盒攻击中的无目标攻击，在各种对抗图片生成上都有效果。 这三种方法都假设能得到输入向量的数字层面的特征，这在自然情况自动汽车背景下不适用。同时，它们都需要perturbation程度比较小且不可见，因为直接以数字向量作为神经网络输入时，这种微小的perturbation不会被破坏。但是，如果把修改后的样本打印到纸张上，那么这种在自然界重建perturbation的过程就会在每个步骤造成信息的损失。因此（J. Lu, H. Sibai, E. Fabry, and D. Forsyth, “No need to worry about adversarial examples in object detection in autonomous vehicles,” arXiv preprint arXiv:1707.03501, 2017.）证实了这些方法在真实世界中效果不好。 然后介绍了本论文中两种攻击方式的由来： Subtle Perturbations:（A. Kurakin, I. J. Goodfellow, and S. Bengio, “Adversarial examples in the physical world,” CoRR, vol. abs/1607.02533, 2016. [Online].Available: http://arxiv.org/abs/1607.02533）里面修改控制图片的数字表示，然后将图片打印出来，通过手机相机来读取图片并作为分类器的输入。 Camouflage Perturbations：（“Best practices for developing with kairos,” 2017. [Online]. Available:https://www.kairos.com/docs/api/best-practices）和（M. Sharif, S. Bhagavatula, L. Bauer, and M. K. Reiter, “Accessorize to a crime: Real and stealthy attacks on state-of-the-art face recognition,” in Proceedings of the 23rd ACM SIGSAC Conference on Computer and Communications Security, Oct. 2016. [Online]. Available: https://www.ece.cmu.edu/~lbauer/papers/2016/ccs2016-face-recognition.pdf）中显示了有着对抗perturbation的眼睛能够欺骗面部识别系统，与本论文的目的一致——通过重建物理目标，给已经存在的目标加入新的对象能够欺骗深度神经网络。与面部识别的不同之处仅仅在于环境不同。 Experiment数据集：LISA数据集，包含47种不同的路标图片，在本实验中重设尺寸为32×32 实验用TensorFlow工具构建分类器，神经网络结构为：三成带有全连接层的卷积层。最终的分类器准确率为91%。攻击过程的选择，本实验只能修改测试集数据，即是evasion attacks。攻击流程： 1. 得到没有对抗perturbation的干净目标路标图 2. 预处理路标图（维度等）将之作为分类器的输入 3. 用攻击算法处理分类器和提取的路标图片 4. 用映射函数在路标上输出相应的对抗perturbation的物理位置 5. 构建数字对抗perturbation，并基于上面函数的输出将这个改动应用到物理目标中。 自然对抗perturbation的评估方法： 受自然情况下环境条件、空间限制、样本构建误差、维度变化和不可探测的物理限制等影响，在评估对抗样本效果时，论文考虑了三个主要的方面：距离、角度和维度。 Robust Physical Perturbations(RP2)算法： 是一种优化的扰动生成方法，在untarget对抗攻击时，目标函数为 $$argmin_λ||δ||_p − J(fθ(x + δ),y)$$ 即是让加入扰动后的输出损失越大越好。 在target对抗攻击时，目标函数为 argmin_λ||δ||_p + J(f_θ(x + δ),y_0) 即是让加入扰动后输出损失与特定目标差别越小越好。 其中λ都代表对扰动规模的限制。 Future work 因为论文用的交通标志比较有限，考虑使用更多的交通标志完成target classification attack。 增加一种扰动补偿的步骤到已有的对抗攻击生成流程中。 在更多现实场景下测试算法，比如标志遮挡。 因为自动汽车的视觉次级系统主要有两个组成部分：一个是目标探测器，一个是分类器。本文主要是研究了对分类器的攻击，但是对目标探测器的攻击也可以达到攻击目的。（P. Viola and M. Jones, “Rapid object detection using a boosted cascade of simple features,” in Computer Vision and Pattern Recognition, 2001.CVPR 2001. Proceedings of the 2001 IEEE Computer Society Conference on, vol. 1. IEEE, 2001, pp. I–I.）和（P. F. Felzenszwalb, R. B. Girshick, D. McAllester, and D. Ramanan, “Object detection with discriminatively trained part-based models,” IEEE transactions on pattern analysis and machine intelligence, vol. 32, no. 9,pp. 1627–1645, 2010.） 问题 还没有实验证明，对原始数据perturbation的程度应该是多少才不至于被人类观察者注意到。 构建perturbation的时候，如果只讲这种对抗攻击的信息体现在黑白灰度层面而不是彩色，可能会让生成的对抗样本更加robust。]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>papernotes</tag>
        <tag>adversarial attack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Concrete Problems for Autonomous Vehicle Safety:Advantages of Bayesian Deep Learning》论文笔记]]></title>
    <url>%2F2017%2F10%2F29%2F%E3%80%8AConcrete-Problems-for-Autonomous-Vehicle-Safety-Advantages-of-Bayesian-Deep-Learning%E3%80%8B%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Rowan McAllister, Yarin Gal†, Alex Kendall, Mark van der Wilk, Amar Shah, Roberto Cipolla, Adrian Weller†Department of Engineering, University of Cambridge, UK† also Alan Turing Institute, London, UK，Proceedings of the Twenty-Sixth International Joint Conference on Artificial Intelligence (IJCAI-17) CitationMcallister R, Gal Y, Kendall A, et al. Concrete Problems for Autonomous Vehicle Safety: Advantages of Bayesian Deep Learning[C]// Twenty-Sixth International Joint Conference on Artificial Intelligence. 2017:4745-4753. 概要这篇论文主要讲的是安全的实际应用。在自动汽车领域，软件方面就是通过一系列流程，将各种传感器的输入链接到发动机的输出上。而在这种传播过程中，如果有信息的损失就会有差错（比如将80%几率不会相撞直接判断为不会相撞） 。各个部分的差错也会被依次累积传递下去，最终输出错误的结果。同时，要让客户信任自动汽车，并使用这个系统，必须在三个方面开展研究：自动汽车的安全性（通过量化每个部分输出的不确定性，并且将这个不确定性也顺着流程传递下去）、可解释性（向客户解释自动汽车所看到的，并且为什么作出一系列决策，从而让客户安心）、顺从性（指的是让客户在自动汽车驾驶过程中维持对汽车的控制）。 自动汽车软件系统由多个单独的子系统组合而成。主要有object detection and localisation components负责场景识别，scene prediction component负责根据场景来预测汽车的运动，最后，decision components做出汽车最终动作决定，控制发动机完成汽车驾驶。而目前，这三个方面渐渐使用深度学习工具搭建，比传统的方法在多个任务上具有更好地效果。但是，基于深度学习的自动汽车软件系统也有许多挑战。正如容易受到对抗样本的干扰，从而做出错误的决断。 提升自动汽车可靠性的三个方面 Safety在自动汽车的软件部分由多个单独的部分联合构成。为了提升系统的安全性，提升每个部分是必要但不是充分的，因为单个部分的错误会随着整体流程而累积。因此，为了避免最终输出的结果出现错误，应该把每个部分的错误和不确定性都体现在其输出上，最终的输出也就体现了所有部分的不确定性。而传播这种不确定性主要有两种方法：一种是贝叶斯概率理论，一种是ensembling。而利用贝叶斯工具掌握这种不确定性在传统自动汽车研究中已经使用过。但是与深度学习系统结合，还存在很多困难。因此，论文提出了贝叶斯深度学习（Bayesian Deep Learning）模型。 如上图，利用BDL模型的自动汽车，可以得到汽车有可能会相撞的结果，从而采取相应的停车措施。而在自动汽车的各个部分，都采用BDL工具。 Interpretability解释性算法能让客户掌握自动汽车作的每一个决策以及得到的输出。这种掌握可以采取三种形式：图像、文字语言或者听觉。这样，每一个客户对自动汽车整个系统就有了比较直观的理解。比如，可以通过在路程中询问：“你为什么突然左转”，自动汽车就会给出作出左转决策的原因。而对这个问题的探索，有两个技术方面：model saliency 和 auxiliary outputs。前者根据图片显示与系统决策关联最显著的部分；后者是根据传感器的输入得到辅助输出，显示系统的控制信息。 Compliance这部分即是让自动汽车也能服从人的命令，而不是一味按照自己的算法模型作出决策。这样也能让客户感觉可靠。而自动汽车服从命令主要是按照两个方面：passenger reassurance和 law abiding。前者是根据乘客的需要改变决策，后者是所有的决策要在法律允许的范围内，要满足社会常识的前提。 这篇论文和对抗攻击的关联不大，只是给针对各种攻击的defence提供了一种利用贝叶斯公式传递不确定性的思想。]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>papernotes</tag>
        <tag>adversarial attack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[范数总结]]></title>
    <url>%2F2017%2F10%2F26%2F%E8%8C%83%E6%95%B0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[关于范数的知识总结 什么是范数 范数是一种强化了的距离概念。他在定义上比距离多了一条数乘的运算法则。数学上，范数包括向量范数和矩阵范数。向量范数表征向量空间中向量的大小，矩阵范数表征矩阵引起变化的大小。一种非严密的解释就是，对应向量范数，向量空间中的向量都是有大小的，这个大小如何度量，就是用范数来度量的，不同的范数都可以来度量这个大小。对于矩阵范数，已知AX=B，可以将向量X变化为B，而矩阵范数就是来度量这个变化大小的。 L-P范数 L-P范数不是一个范数，而是一组范数。定义如下： L_p = \sqrt[p]{\sum_{i=1}^n x_i^p}, x=(x_1,x_2,...,x_n)L0范数 上式中，当p=0时，就是L0范数。L0范数并不是一个真正的范数，它主要用来度量向量中非零元素的个数。L-0的定义为： ||x|| = \sqrt[0]{\sum_1^n{x_i^0}},x=(x_1,x_2,...,x_n)其优化问题为： min||x||_0 \\ s.t. Ax=b在实际应用中，由于L0范数本身不容易有一个好的数学表示形式，给出上面问题的形式化表示是一个很难的问题，故被人认为是一个NP难问题。所以在实际情况中，L0的最优问题会被放宽到L1或L2下的最优化。 L-1范数 L1范数是我们经常见到的一种范数，它的定义如下： ||x||_1=\sum_i{|x_i|}表示向量x中非零元素的绝对值之和。L1范数有许多别称，比如曼哈顿距离，最小绝对误差等等。使用L1范数可以度量两个向量间的差异，如绝对误差和（Sum of Absolute Difference）： SAD(x_1,x_2) = \sum_i{|x_{1i}-x_{2i}|}对于L1范数，他的优化问题如下： min||x||_1 s.t. Ax = b由于L1范数的天然性质，对L1优化的解是一个稀疏解，因此L1范数也被叫做稀疏规则算子。通过L1可以实现特征的稀疏，去掉一些没有信息的特征，例如在对用户的电影爱好做分类的时候，用户有100个特征，可能只有十几个特征是对分类有用的，大部分特征如身高体重等可能都是无用的，利用L1范数就可以过滤掉。 L2范数 我们来度量欧式距离的就是一种L2范数，它的定义如下： ||x||_2 = \sqrt{\sum_i{x_i^2}}表示向量元素的平方和再开平方。L2也可以用来度量两个向量之间的差异，如平方差和（Sum of Squared Difference）： SSD(x_1,x_2) = \sum_i{(x_{1i}-x_{2i})^2}对于L2范数，它的优化问题如下： min||x||_2 s.t. Ax = bL2范数通常会被用来做优化目标的正则化项，防止模型为了迎合训练集而过于复杂造成过拟合的情况，从而提高模型的泛化能力。 L-∞范数 当P=∞时，也就是L-∞范数，它主要被用来度量向量元素的最大值。用上面的L-P定义可以得到的L∞的定义为： ||x||_∞ = \sqrt[∞]{\sum_1^n{x_i^∞}},x=(x_1,x_2,...,x_n)通常情况下，大家用的都是： ||x||_∞ = max(|x_i|)来表示L-∞范数。]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My Notes Of Adversarial Attack]]></title>
    <url>%2F2017%2F10%2F18%2FMy-Notes-Of-Adversarial-Attack%2F</url>
    <content type="text"><![CDATA[摘要:对抗攻击简介正文: 一、对抗攻击简介对抗攻击是机器学习与计算机安全的结合（Intersection），是一个新兴的研究领域。以前设计的机器学习模型在面对攻击者精心设计的对抗攻击时往往会达不到预期的准确度，这种错误在如自动驾驶汽车等的实际应用中的影响是致命的。按照攻击者是否知道目的网络的结构参数，可以将对抗攻击分为白盒攻击和黑盒攻击。对抗攻击采取的形式，就是攻击者根据某种算法给原始输入数据加入人为难以分辨的微小扰动从而构成对抗样本。目的网络将对抗样本作为输入时，往往会输出错误的分类结果。实际中，根据目的网络最终得到的分类结果是否是攻击者预先设计好的，将对抗攻击分为目标攻击和非目标攻击。 研究对抗攻击的意义如下： 能让机器学习模型处理大规模数据； 以“计算机速度”处理攻击威胁； 不依赖数据的明显特征，发现实际应用中的各种内在威胁； 阻止已知和未知的恶意软件； 阻止恶意软件的提前执行； 优化模型，让分类模型达到更加高的分类准确率和更加低的错误率。我总结的对抗攻击方面的研究可以概括为下面几个方面：攻击原理探究、对抗攻击、对抗攻击防御、实际应用。 二、攻击原理对产生对抗攻击的原理的探究，目前主要有以下几个方面的观点： 《Intriguing properties of neural networks》提出：深度神经网络模型的非线性导致的输入与输出映射的不连续性，加上不充分的模型平均和不充分的正则化导致的过拟合使得对抗攻击成为可能。（It discovered was that several machine learning models, including state-of-the-art neural networks, are vulnerable to adversarial examples. That is, these machine learning models can misclassify examples that are only slightly different (imperceptibly so in many cases) from correctly classified examples drawn from the data distribution. In many cases, a wide variety of models with different architectures trained on different subsets of the training data misclassify the same adversarial example (this is kind of shocking). The implication is that adversarial examples expose fundamental problems in popular training algorithms.） 《Explaining And Harnessing Adversarial Examples》提出：高维空间中的线性就足以造成对抗样本，深度模型对对抗样本的脆弱性最主要的还是由于其线性部分的存在。通过将模型转变成非线性的RBF模型，就能减少神经网络模型对对抗攻击的脆弱性。(It shows that generic regularization strategies such as dropout, pre-training and model averaging or ensembling do not confer a significant reduction in a model’s vulnerability to adversarial examples. On the other hand, changing to nonlinear model families such as RBF networks can confer some resistance (to such adversarial examples).) 三、Adversarial Attack目前构建对抗样本的方法很多，总结如下： 传统的梯度下降、牛顿法、BFGS、L-BFGS：这些方法在2013年发表的文章《Evasion attacks against machine learning at test time》和2014年发表的文章《Intriguing properties of neural networks》中提到并运用来生成对抗样本，同时，这两篇文章也是最早提出对抗攻击这个概念的。前者用到的约束方式是传统的梯度下降法，同时约束目标上为了克服分类器函数的非凸性导致的局部最优解问题，提出给约束函数增加一个KDE（kernel density estimator）。 《Evasion attacks aginst machine learning at test time》这篇文章提出将KED部分放入到目标函数中，其作用类似于network intrusion detection(《Polymorphic blending attacks.》)，因此这个方法也可以算作是mimicry 攻击方法的一种。 《Intriguing properties of neural networks》 The authors estimated adversarial examples by solving penalized optimization problems and presented an analysis showing that the high complexity of neural networks might be a reason explaining the presence of adversarial examples. Unfortunately, the optimization method employed in this article is time-consuming and therefore does not scale to large datasets. FGSM：《Explaining And Harnessing Adversarial Examples》（2015.3） 这篇Goodfellow提出的FGSM方法，是比较经典的对抗样本生成方法。 这篇文章提出将KED部分放入到目标函数中，其作用类似于network intrusion detection(《Polymorphic blending attacks.》)，因此这个方法也可以算作是mimicry 攻击方法的一种。 缺点：Despite its efficiency, this method provides only a coarse approximation of the optimal perturbation vectors. In fact, it performs a unique gradient step, which often leads to sub-optimal solutions. Iterative version of FGSM（The Basic Iterative Method ）：《Adversarial examples in the physical world》（2017.2）这个方法可以视作是Fast Gradient Method的迭代应用。这篇文章针对上一篇FGSM方法的扰动规模比较大的缺陷，提出构造规模更加受限的对抗样本。 Jacobian saliency map attack (JSMA) ：《The limitations of deep learning in adversarial settings》（2015.10）这篇文章提出的对抗样本构建方法，是建立在攻击者已知目标网络的结构和参数等信息的情况下。这种方法的核心思想，是通过计算神经网络前向传播过程中的导数生成对抗样本。（Notes: This algorithm used the Jacobian matrix to determine which features to modify when generating adversarial examples. The Jacobian matrix based approach is also a kind of gradient based algorithm.） DeepFool：《Deepfool: a simple and accurate method to fool deep neural networks》（2015.10）这是第一个通过计算出最小的必要扰动，并应用到对抗样本构建的方法，使用的限制扰动规模的方法是L2范数。最终得到的对抗样本效果优于前面的FGSM和JSMA方法，但是这三者都需要比较大的计算资源。 Papernot Method：《 Adversarial perturbations against deep neural networks for malware classification》（2016.6）论文笔记：（https://www.zybuluo.com/wuxin1994/note/854417）这篇论文提到的对抗样本生成方法，更多的是针对于特定的应用场景——在输入是比较离散的数据情况下如何构建对抗样本。 Universal Perturbations： 《Universal adversarial perturbations》（2016.10）：这是一种对DeepFool方法的延伸。论文笔记：（https://www.zybuluo.com/wuxin1994/note/847422）（分析：Universal Perturbations is an untargeted attack that creates perturbations that can be applied to any image and is therefore useful as a black-box attack. Since this algorithm seeks the nearest class for misclassification, it is not easy to generate universal perturbations for targeted attacks.）《Analysis of universal adversarial perturbations》（2017.5） RP2： 《Robust Physical-World Attacks on Machine Learning Models》（2017.7）论文笔记：（https://www.zybuluo.com/wuxin1994/note/839621） CW（The Carlini and Wagner）：《Towards evaluating the robustness of neural networks》（2017.3）这篇文章的作者将Szegedy在《Explaining And Harnessing Adversarial Examples》提出的攻击方式转化成了一个更加高效的优化问题，能够以添加更小扰动的代价得到更加高效的对抗样本。(这篇文章是对《Explaining And Harnessing Adversarial Examples》的改进，能够用更小规模的扰动构造出效果更好的对抗样本，并且说明了distillation防御策略《Distillation as a defense to adversarial perturbations against deep neural networks》的不完备性) Virtual adversarial examples：《Virtual adversarial training: a regularization method for supervised and semi-supervised learning》（2017.4） 《Generating Adversarial Malware Examples for Black-Box Attacks Based on GAN》(2017.2)论文笔记：（https://www.zybuluo.com/wuxin1994/note/867495） 《Machine Learning as an Adversarial Service: Learning Black-Box Adversarial Examples》（2017.8）论文笔记：(https://www.zybuluo.com/wuxin1994/note/860472) 《Towards Deep Learning Models Resistant to Adversarial Attacks》（2017.6）提到如何深入解释对抗样本的原理，如何构建universal的对抗样本。 四、Defence Policy对抗攻击的防御策略总结如下： Adversarial Training（augmenting the training data with perturbed examples）：《Intriguing properties of neural networks》（2014）所谓的对抗训练，就是防卫者通过自己构造对抗攻击，并且将人为增加扰动的对抗样本也加入到训练数据中，从而增强训练集，让训练后得到的模型更加稳定。（10.5新增）《Towards deep learning models resistant to adversarial attacks 》提到对抗训练用比较弱的攻击时，往往并没有增加模型对更强的攻击的鲁棒性。（这篇文章对对抗训练的方法提出了质疑，即是这种方法是否真的可以应对未来将要遇到的更强的攻击？） PCA whitening ：《Early methods for detecting adversarial images》（2016.8） Defensive distillation：《Distillation as a defense to adversarial perturbations against deep neural networks》（2016.3）这个方法通过两个步骤完成对模型稳定性的提升：第一步是训练分类模型，其最后一层的softmax层除以一个常数T；第二步是用同样的输入训练第二个模型，但是训练数据的标签不用原始标签，而是用第一步中训练的模型最后一层的概率向量作为最后softmax层的目标。《Extending Defensive Distillation》（2017.5）《Towards evaluating the robustness of neural networks》中推翻了这个防御策略，说明他效果不怎么好。 Feature squeezing：《Feature squeezing: Detecting adversarial examples in deep neural networks》（2017.4）《Feature squeezing mitigates and detects carlini/wagner adversarial examples》（2017.5） Detection systems: （这种defence方法采取的策略是在目的网络模型前面增加一个额外的探测系统，判断输入是否是经过人为扰动的对抗样本）Performe statistical tests:《On the (statistical) detection of adversarial examples》（2017.2）Use an additional model for detection:《Adversarial and clean data are not twins》（2017.4）《On detecting adversarial perturbations》（2017.2）Apply dropout at test time:《Detecting adversarial samples from artifacts》（2017.3） Generative Adversarial Networks (GAN):《Generative Adversarial Trainer Defense to Adversarial Perturbations with GAN》（2017.5）《AE-GAN: adversarial eliminating with GAN》（2017.7）论文笔记：（https://www.zybuluo.com/wuxin1994/note/881171） 《Efficient Defenses Against Adversarial Attacks》（2017.7）论文笔记：(https://www.zybuluo.com/wuxin1994/note/863551) 五、其他研究对抗攻击可移植性研究：《Transferability in Machine Learning: from Phenomena to Black-Box Attacks using Adversarial Samples》（2016.5）论文笔记：(https://www.zybuluo.com/wuxin1994/note/850755) 《The space of transferable adversarial examples》（Florian Tramèr, Nicolas Papernot, Ian J. Goodfellow, Dan Boneh, and Patrick D. McDaniel.The space of transferable adversarial examples. arXiv preprint arXiv:1704.03453, 2017.）：propose a linear algebraic notion of adversarial subspaces. 《Towards Deep Learning Models Resistant to Adversarial Attacks》里面对可移植性也有一些研究：we find that larger model capacity and adversarial training reduces the transferability of adversarial examples） 六、实际应用对抗攻击在实际中的应用： 面部识别：《Accessorize to a crime: Real and stealthy attacks on state-of-the-art face recognition》（2016.10） 实际拍照图片：《Adversarial examples in the physical world》（2017.2）这篇文章是在实际应用中，对抗攻击往往不能将数字化的对抗样本作为目的分类器的输入，只能将对抗样本打印到纸张上，然后用拍照之类的方式得到目的网络的输入时，人为添加的扰动比较小，在拍照过程中产生了失真，不能达到攻击目的。 路标：《Robust Physical-World Attacks on Machine Learning Models》（2017.7）论文笔记：(https://www.zybuluo.com/wuxin1994/note/839621) 自动汽车：《Concrete Problems for Autonomous Vehicle Safety: Advantages of Bayesian Deep Learning》（2017）论文笔记：(https://www.zybuluo.com/wuxin1994/note/843327) 恶意软件分类：《Adversarial Perturbations Against Deep Neural Networks for Malware Classification》（2016.6）论文笔记：(https://www.zybuluo.com/wuxin1994/note/854417)《Generating Adversarial Malware Examples for Black-Box Attacks Based on GAN》（2017.5）论文笔记：（https://www.zybuluo.com/wuxin1994/note/867495） 七、总结根据目前学习的对抗攻击研究，我觉得以后的研究方向主要有以下几个方面： 效率更高的对抗样本构造方法； 更好的Defence策略构建； 根据特定的应用场景探究攻击和防御策略（垃圾邮件分类、恶意软件识别、人脸识别等与安全相关的领域）； 得到对抗样本，在模型的训练集中加入对抗攻击样本，可以增强神经网络的鲁棒性； 理解对抗攻击背后的数学原理，实际就是探索深度网络的原理，尝试打开这个黑盒子。 （9.18更新）已经知道了根据对目的模型的了解程度可以造成不同的影响结果，那么能否根据这一点来探究各个影响因素分别的效果呢？ （10.4更新）存在这样一个问题：很难去评判一个defence方法是否是足够有效的，也很难去评价一个攻击方法是否是足够成功的。因为往往在对抗攻击研究进程中，一个提出的defence策略总是会被后来提出的攻击方法证明是不够鲁棒的。反之，一个攻击方法也往往会被后面提出的defence方法证明是无效的。这种往复的循环博弈，给研究指出了一个新的方向:可以研究一种评估攻击方法或者防御策略的有效性的评估方法。这一部分参考《Ground-Truth Adversarial Examples》：a defensive technique that was at first thought to produce robust networks was later shown to be susceptible to new kinds of attacks. 最近将GAN与对抗攻击研究相结合的方向让我很感兴趣。它可以同时构建效果更加好的对抗样本和实现让模型更加鲁棒的defence策略。因为在我看来，对抗攻击可以实现，其本质一方面是因为神经网络乃至深度学习可以实现分类和预测目的的原理还比较模糊，因此可以利用这种不确定性来混淆模型；另一方面是因为数据本身就不能按照抽取的特征得到固定的分类结果，每一个个体具有比较大的误差因素。因此，模型容易受到对抗攻击是因为模型的泛化能力不够，在处理非训练数据时容易得到错误的结果。提高模型的泛化能力才是最好的defence策略。而最近特别火的GAN网络正是一种提高网络泛化能力的手段，在多个方面都被证明能让训练得到的模型具有更好的效果。]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>adversarial attack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爱你一万年]]></title>
    <url>%2F2017%2F04%2F07%2FLoving%2F</url>
    <content type="text"><![CDATA[相爱已有，两年。 730天，17520小时，1051200分钟，63072000秒。时间很多，却清晰记得在一起的每时每刻。 两个人，两个地方，1224.9公里，上百张车票，无数电磁波传递的问候。距离很远，但一起努力的方向未变。 旅途的苦与乐，工作的累与得，生活的哭与笑，彼此的分与合。事情很多，但经历的人，一直都有你和我。 也许花钱还要精打细算，也许工作实习烦事总是不断，也许同桌的她和隔壁的他又矮又丑，也许好像要去的旅途没有别人写的这么美，也许你大姑小姨我大妈二舅的姑妈生了二胎，也许国庆90周年阅兵很壮观却不能去现场看，…也许我们还是会吵，会争执，也许你会无理取闹，我会喋喋不休。 但我相信，有你有我的每一天，就是最好最美的一天天。 回想两年来共同的经历与交集，仿佛很远，又似乎就在昨天。两年？还爱不够。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python去掉文章中所有的符号]]></title>
    <url>%2F2017%2F01%2F05%2FPython%E5%8C%B9%E9%85%8D%E6%89%80%E6%9C%89%E7%AC%A6%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[如何去掉一个字符串中所有的符号 使用python中的正则相关的库：1import re 然后用写出对应的正则表达式：1r = &quot;[+\.\!\/_,$%^*(+\&quot;\&apos;]+|[+——！，。？?、~@《￥》\&#123;\&#125;#￥%…“•”…&amp;*（）\n\t\s]+&quot; 接着用替换1re.sub(r,&apos;&apos;,&quot;nishog.;dfs$fd*&quot;)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
